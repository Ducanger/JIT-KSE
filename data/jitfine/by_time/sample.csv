commit_id,diff,label,message
0008afc59c240271827d8a0fc747179da905050f,"@@ -279,7 +279,7 @@ int dv_assemble_frame(DVMuxContext *c, AVStream* st,
 
 DVMuxContext* dv_init_mux(AVFormatContext* s)
 {
-    DVMuxContext *c;
+    DVMuxContext *c = (DVMuxContext *)s->priv_data;
     AVStream *vst = NULL;
     int i;
 
@@ -287,10 +287,6 @@ DVMuxContext* dv_init_mux(AVFormatContext* s)
     if (s->nb_streams > 3)
         return NULL;
 
-    c = av_mallocz(sizeof(DVMuxContext));
-    if (!c)
-        return NULL;
-
     c->n_ast = 0;
     c->ast[0] = c->ast[1] = NULL;
 
@@ -345,7 +341,6 @@ DVMuxContext* dv_init_mux(AVFormatContext* s)
     return c;
 
 bail_out:
-    av_free(c);
     return NULL;
 }
 
@@ -359,8 +354,7 @@ void dv_delete_mux(DVMuxContext *c)
 #ifdef CONFIG_MUXERS
 static int dv_write_header(AVFormatContext *s)
 {
-    s->priv_data = dv_init_mux(s);
-    if (!s->priv_data) {
+    if (!dv_init_mux(s)) {
         av_log(s, AV_LOG_ERROR, ""Can't initialize DV format!\n""
                     ""Make sure that you supply exactly two streams:\n""
                     ""     video: 25fps or 29.97fps, audio: 2ch/48Khz/PCM\n""
",0,* fixing a memory leak in DV format.
000cacf6f9dce7d71f88aadf7e9b3688eaa3ab69,"@@ -3568,17 +3568,16 @@ static void gen_sse(DisasContext *s, int b, target_ulong pc_start, int rex_r)
             reg = ((modrm >> 3) & 7) | rex_r;
             gen_op_mov_reg_T0(OT_LONG, reg);
             break;
-        case 0x038:
         case 0x138:
+            if (s->prefix & PREFIX_REPNZ)
+                goto crc32;
+        case 0x038:
             b = modrm;
             modrm = ldub_code(s->pc++);
             rm = modrm & 7;
             reg = ((modrm >> 3) & 7) | rex_r;
             mod = (modrm >> 6) & 3;
 
-            if (s->prefix & PREFIX_REPNZ)
-                goto crc32;
-
             sse_op2 = sse_op_table6[b].op[b1];
             if (!sse_op2)
                 goto illegal_op;
",0,"Fix crc32w decoding, fix a constant width in blendvpd."
0023ea4e20b0bec70e1dedb7f1183dd58f9122d8,"@@ -465,7 +465,9 @@ static void fill_buffer(AVIOContext *s)
     /* make buffer smaller in case it ended up large after probing */
     if (s->read_packet && s->orig_buffer_size && s->buffer_size > s->orig_buffer_size) {
         if (dst == s->buffer) {
-            ffio_set_buf_size(s, s->orig_buffer_size);
+            int ret = ffio_set_buf_size(s, s->orig_buffer_size);
+            if (ret < 0)
+                av_log(s, AV_LOG_WARNING, ""Failed to decrease buffer size\n"");
 
             s->checksum_ptr = dst = s->buffer;
         }
",0,avformat/aviobuf: Check for ffio_set_buf_size() failure
0034314a69e76a53534a74cceef865cfcb7b42cc,"@@ -2817,11 +2817,10 @@ reconnect:
     }
 
     if (rt->is_input) {
-        int err;
         // generate FLV header for demuxer
         rt->flv_size = 13;
-        if ((err = av_reallocp(&rt->flv_data, rt->flv_size)) < 0)
-            return err;
+        if ((ret = av_reallocp(&rt->flv_data, rt->flv_size)) < 0)
+            goto fail;
         rt->flv_off  = 0;
         memcpy(rt->flv_data, ""FLV\1\0\0\0\0\011\0\0\0\0"", rt->flv_size);
 
@@ -2832,7 +2831,7 @@ reconnect:
         // audio or video packet arrives.
         while (!rt->has_audio && !rt->has_video && !rt->received_metadata) {
             if ((ret = get_packet(s, 0)) < 0)
-               return ret;
+               goto fail;
         }
 
         // Either after we have read the metadata or (if there is none) the
",0,rtmp: Always call rtmp_close() on rtmp_open() failure
003fad6e2cae5311d3aea996388c90e3ab17de90,"@@ -638,7 +638,7 @@ void qcow2_free_clusters(BlockDriverState *bs,
     ret = update_refcount(bs, offset, size, -1);
     if (ret < 0) {
         fprintf(stderr, ""qcow2_free_clusters failed: %s\n"", strerror(-ret));
-        abort();
+        /* TODO Remember the clusters to free them later and avoid leaking */
     }
 }
 
",0,qcow2: Remove abort on free_clusters failure
0044a8f80df366643bcfaf74011e41a2658c88f8,"@@ -604,10 +604,6 @@ static int mpegts_write_end(AVFormatContext *s)
     }
     av_free(ts->services);
 
-    for(i = 0; i < s->nb_streams; i++) {
-        st = s->streams[i];
-        av_free(st->priv_data);
-    }
     return 0;
 }
 
",0,double free patch by (Måns Rullgård <mru inprovide com>)
0048b4837affd153897ed1222283492070027aa9,"@@ -73,6 +73,7 @@
 
 #include ""blk.h""
 #include ""blk-mq.h""
+#include ""blk-mq-tag.h""
 
 /* FLUSH/FUA sequences */
 enum {
@@ -226,7 +227,12 @@ static void flush_end_io(struct request *flush_rq, int error)
 	struct blk_flush_queue *fq = blk_get_flush_queue(q, flush_rq->mq_ctx);
 
 	if (q->mq_ops) {
+		struct blk_mq_hw_ctx *hctx;
+
+		/* release the tag's ownership to the req cloned from */
 		spin_lock_irqsave(&fq->mq_flush_lock, flags);
+		hctx = q->mq_ops->map_queue(q, flush_rq->mq_ctx->cpu);
+		blk_mq_tag_set_rq(hctx, flush_rq->tag, fq->orig_rq);
 		flush_rq->tag = -1;
 	}
 
@@ -308,11 +314,18 @@ static bool blk_kick_flush(struct request_queue *q, struct blk_flush_queue *fq)
 
 	/*
 	 * Borrow tag from the first request since they can't
-	 * be in flight at the same time.
+	 * be in flight at the same time. And acquire the tag's
+	 * ownership for flush req.
 	 */
 	if (q->mq_ops) {
+		struct blk_mq_hw_ctx *hctx;
+
 		flush_rq->mq_ctx = first_rq->mq_ctx;
 		flush_rq->tag = first_rq->tag;
+		fq->orig_rq = first_rq;
+
+		hctx = q->mq_ops->map_queue(q, first_rq->mq_ctx->cpu);
+		blk_mq_tag_set_rq(hctx, first_rq->tag, flush_rq);
 	}
 
 	flush_rq->cmd_type = REQ_TYPE_FS;

@@ -429,7 +429,7 @@ static void bt_for_each(struct blk_mq_hw_ctx *hctx,
 		for (bit = find_first_bit(&bm->word, bm->depth);
 		     bit < bm->depth;
 		     bit = find_next_bit(&bm->word, bm->depth, bit + 1)) {
-		     	rq = blk_mq_tag_to_rq(hctx->tags, off + bit);
+			rq = hctx->tags->rqs[off + bit];
 			if (rq->q == hctx->queue)
 				fn(hctx, rq, data, reserved);
 		}
@@ -453,7 +453,7 @@ static void bt_tags_for_each(struct blk_mq_tags *tags,
 		for (bit = find_first_bit(&bm->word, bm->depth);
 		     bit < bm->depth;
 		     bit = find_next_bit(&bm->word, bm->depth, bit + 1)) {
-			rq = blk_mq_tag_to_rq(tags, off + bit);
+			rq = tags->rqs[off + bit];
 			fn(rq, data, reserved);
 		}
 

@@ -89,4 +89,16 @@ static inline void blk_mq_tag_idle(struct blk_mq_hw_ctx *hctx)
 	__blk_mq_tag_idle(hctx);
 }
 
+/*
+ * This helper should only be used for flush request to share tag
+ * with the request cloned from, and both the two requests can't be
+ * in flight at the same time. The caller has to make sure the tag
+ * can't be freed.
+ */
+static inline void blk_mq_tag_set_rq(struct blk_mq_hw_ctx *hctx,
+		unsigned int tag, struct request *rq)
+{
+	hctx->tags->rqs[tag] = rq;
+}
+
 #endif

@@ -559,23 +559,9 @@ void blk_mq_abort_requeue_list(struct request_queue *q)
 }
 EXPORT_SYMBOL(blk_mq_abort_requeue_list);
 
-static inline bool is_flush_request(struct request *rq,
-		struct blk_flush_queue *fq, unsigned int tag)
-{
-	return ((rq->cmd_flags & REQ_FLUSH_SEQ) &&
-			fq->flush_rq->tag == tag);
-}
-
 struct request *blk_mq_tag_to_rq(struct blk_mq_tags *tags, unsigned int tag)
 {
-	struct request *rq = tags->rqs[tag];
-	/* mq_ctx of flush rq is always cloned from the corresponding req */
-	struct blk_flush_queue *fq = blk_get_flush_queue(rq->q, rq->mq_ctx);
-
-	if (!is_flush_request(rq, fq, tag))
-		return rq;
-
-	return fq->flush_rq;
+	return tags->rqs[tag];
 }
 EXPORT_SYMBOL(blk_mq_tag_to_rq);
 
",0,blk-mq: fix race between timeout and freeing request
005145378c9ad7575a01b6ce1ba118fb427f583a,"@@ -1012,8 +1012,8 @@ EXPORT_SYMBOL(dvb_usbv2_probe);
 void dvb_usbv2_disconnect(struct usb_interface *intf)
 {
 	struct dvb_usb_device *d = usb_get_intfdata(intf);
-	const char *name = d->name;
-	struct device dev = d->udev->dev;
+	const char *devname = kstrdup(dev_name(&d->udev->dev), GFP_KERNEL);
+	const char *drvname = d->name;
 
 	dev_dbg(&d->udev->dev, ""%s: bInterfaceNumber=%d\n"", __func__,
 			intf->cur_altsetting->desc.bInterfaceNumber);
@@ -1023,8 +1023,9 @@ void dvb_usbv2_disconnect(struct usb_interface *intf)
 
 	dvb_usbv2_exit(d);
 
-	dev_info(&dev, ""%s: '%s' successfully deinitialized and disconnected\n"",
-			KBUILD_MODNAME, name);
+	pr_info(""%s: '%s:%s' successfully deinitialized and disconnected\n"",
+		KBUILD_MODNAME, drvname, devname);
+	kfree(devname);
 }
 EXPORT_SYMBOL(dvb_usbv2_disconnect);
 
",0,[media] dvb-usb-v2: avoid use-after-free
0062869ae25007c8506517dcfcbe6f439dc6958a,"@@ -92,11 +92,14 @@ static const uint8_t smk_pal[64] = {
 
 static int smacker_probe(AVProbeData *p)
 {
-    if(p->buf[0] == 'S' && p->buf[1] == 'M' && p->buf[2] == 'K'
-        && (p->buf[3] == '2' || p->buf[3] == '4'))
-        return AVPROBE_SCORE_MAX;
-    else
+    if (   AV_RL32(p->buf) != MKTAG('S', 'M', 'K', '2')
+        && AV_RL32(p->buf) != MKTAG('S', 'M', 'K', '4'))
         return 0;
+
+    if (AV_RL32(p->buf+4) > 32768U || AV_RL32(p->buf+8) > 32768U)
+        return AVPROBE_SCORE_MAX/4;
+
+    return AVPROBE_SCORE_MAX;
 }
 
 static int smacker_read_header(AVFormatContext *s)
",0,avformat/smacker: check width/height in probe
0072d2a9fce4835ab2b9ee70aaca0169fb25fa0c,"@@ -48,6 +48,7 @@ static int qcrypto_ivgen_essiv_init(QCryptoIVGen *ivgen,
                            &salt, &nhash,
                            errp) < 0) {
         g_free(essiv);
+        g_free(salt);
         return -1;
     }
 
",0,crypto: fix leak in ivgen essiv init
007498fc1a639ecee2cda1892cbcff66c7c8c951,"@@ -1184,7 +1184,7 @@ av_cold int sws_init_context(SwsContext *c, SwsFilter *srcFilter,
     c->chrDstW = FF_CEIL_RSHIFT(dstW, c->chrDstHSubSample);
     c->chrDstH = FF_CEIL_RSHIFT(dstH, c->chrDstVSubSample);
 
-    FF_ALLOC_OR_GOTO(c, c->formatConvBuffer, FFALIGN(srcW*2+78, 16) * 2, fail);
+    FF_ALLOCZ_OR_GOTO(c, c->formatConvBuffer, FFALIGN(srcW*2+78, 16) * 2, fail);
 
     c->srcBpc = 1 + desc_src->comp[0].depth_minus1;
     if (c->srcBpc < 8)
",0,swscale/utils: clear formatConvBuffer on allocation
007cd223de527b5f41278f2d886c1a4beb3e67aa,"@@ -232,6 +232,9 @@ static int tx_consume(Rocker *r, DescInfo *info)
         frag_addr = rocker_tlv_get_le64(tlvs[ROCKER_TLV_TX_FRAG_ATTR_ADDR]);
         frag_len = rocker_tlv_get_le16(tlvs[ROCKER_TLV_TX_FRAG_ATTR_LEN]);
 
+        if (iovcnt >= ROCKER_TX_FRAGS_MAX) {
+            goto err_too_many_frags;
+        }
         iov[iovcnt].iov_len = frag_len;
         iov[iovcnt].iov_base = g_malloc(frag_len);
         if (!iov[iovcnt].iov_base) {
@@ -244,10 +247,7 @@ static int tx_consume(Rocker *r, DescInfo *info)
             err = -ROCKER_ENXIO;
             goto err_bad_io;
         }
-
-        if (++iovcnt > ROCKER_TX_FRAGS_MAX) {
-            goto err_too_many_frags;
-        }
+        iovcnt++;
     }
 
     if (iovcnt) {
",0,net: rocker: fix an incorrect array bounds check
0096453f70c42db403ced2e8c89a1d92c5343109,"@@ -156,6 +156,7 @@ static int alloc_buffers(AVCodecContext *avctx)
 
     if ((ret = ff_set_dimensions(avctx, s->coded_width, s->coded_height)) < 0)
         return ret;
+    avctx->pix_fmt = s->coded_format;
 
     avcodec_get_chroma_sub_sample(avctx->pix_fmt, &s->chroma_x_shift, &s->chroma_y_shift);
 
@@ -213,6 +214,7 @@ static int alloc_buffers(AVCodecContext *avctx)
 
     s->a_height = s->coded_height;
     s->a_width  = s->coded_width;
+    s->a_format = s->coded_format;
 
     return 0;
 }
@@ -227,7 +229,7 @@ static int cfhd_decode(AVCodecContext *avctx, void *data, int *got_frame,
     int ret = 0, i, j, plane, got_buffer = 0;
     int16_t *coeff_data;
 
-    avctx->pix_fmt = AV_PIX_FMT_YUV422P10;
+    s->coded_format = AV_PIX_FMT_YUV422P10;
     init_frame_defaults(s);
 
     bytestream2_init(&gb, avpkt->data, avpkt->size);
@@ -405,9 +407,9 @@ static int cfhd_decode(AVCodecContext *avctx, void *data, int *got_frame,
         } else if (tag == 84) {
             av_log(avctx, AV_LOG_DEBUG, ""Sample format? %i\n"", data);
             if (data == 1)
-                avctx->pix_fmt = AV_PIX_FMT_YUV422P10;
+                s->coded_format = AV_PIX_FMT_YUV422P10;
             else if (data == 3)
-                avctx->pix_fmt = AV_PIX_FMT_GBRP12;
+                s->coded_format = AV_PIX_FMT_GBRP12;
             else {
                 avpriv_report_missing_feature(avctx, ""Sample format of %""PRIu16"" is unsupported\n"", data);
                 ret = AVERROR_PATCHWELCOME;
@@ -417,8 +419,10 @@ static int cfhd_decode(AVCodecContext *avctx, void *data, int *got_frame,
             av_log(avctx, AV_LOG_DEBUG,  ""Unknown tag %i data %x\n"", tag, data);
 
         /* Some kind of end of header tag */
-        if (tag == 4 && data == 0x1a4a && s->coded_width && s->coded_height && avctx->pix_fmt != AV_PIX_FMT_NONE) {
-            if (s->a_width != s->coded_width || s->a_height != s->coded_height) {
+        if (tag == 4 && data == 0x1a4a && s->coded_width && s->coded_height &&
+            s->coded_format != AV_PIX_FMT_NONE) {
+            if (s->a_width != s->coded_width || s->a_height != s->coded_height ||
+                s->a_format != s->coded_format) {
                 free_buffers(avctx);
                 if ((ret = alloc_buffers(avctx)) < 0) {
                     free_buffers(avctx);
@@ -431,6 +435,7 @@ static int cfhd_decode(AVCodecContext *avctx, void *data, int *got_frame,
 
             s->coded_width = 0;
             s->coded_height = 0;
+            s->coded_format = AV_PIX_FMT_NONE;
             got_buffer = 1;
         }
         coeff_data = s->plane[s->channel_num].subband[s->subband_num_actual];
@@ -557,7 +562,8 @@ static int cfhd_decode(AVCodecContext *avctx, void *data, int *got_frame,
         }
     }
 
-    if (!s->a_width || !s->a_height || s->coded_width || s->coded_height) {
+    if (!s->a_width || !s->a_height || s->a_format == AV_PIX_FMT_NONE ||
+        s->coded_width || s->coded_height || s->coded_format != AV_PIX_FMT_NONE) {
         av_log(avctx, AV_LOG_ERROR, ""Invalid dimensions\n"");
         ret = AVERROR(EINVAL);
         goto end;
",0,cfhd: reallocate internal buffers on format change.
009f829dde811af654af7110326aea3a72c05d5e,"@@ -1001,6 +1001,7 @@ int sws_init_context(SwsContext *c, SwsFilter *srcFilter, SwsFilter *dstFilter)
         c->lumPixBuf[i] = c->lumPixBuf[i+c->vLumBufSize];
     }
     c->uv_off = dst_stride_px;
+    c->uv_offx2 = dst_stride;
     for (i=0; i<c->vChrBufSize; i++) {
         FF_ALLOC_OR_GOTO(c, c->chrUPixBuf[i+c->vChrBufSize], dst_stride*2+1, fail);
         c->chrUPixBuf[i] = c->chrUPixBuf[i+c->vChrBufSize];

@@ -897,16 +897,16 @@ static inline void RENAME(yuv2yuyv422_X)(SwsContext *c, const int16_t *lumFilter
     YSCALEYUV2PACKEDX_END
 }
 
-#define REAL_YSCALEYUV2RGB_UV(index, c, uv_off) \
+#define REAL_YSCALEYUV2RGB_UV(index, c) \
     ""xor            ""#index"", ""#index""  \n\t""\
     "".p2align              4            \n\t""\
     ""1:                                 \n\t""\
     ""movq     (%2, ""#index""), %%mm2     \n\t"" /* uvbuf0[eax]*/\
     ""movq     (%3, ""#index""), %%mm3     \n\t"" /* uvbuf1[eax]*/\
-    ""add           ""#uv_off"", ""#index""  \n\t"" \
+    ""add           ""UV_OFFx2""(""#c""), ""#index""  \n\t"" \
     ""movq     (%2, ""#index""), %%mm5     \n\t"" /* uvbuf0[eax+2048]*/\
     ""movq     (%3, ""#index""), %%mm4     \n\t"" /* uvbuf1[eax+2048]*/\
-    ""sub           ""#uv_off"", ""#index""  \n\t"" \
+    ""sub           ""UV_OFFx2""(""#c""), ""#index""  \n\t"" \
     ""psubw             %%mm3, %%mm2     \n\t"" /* uvbuf0[eax] - uvbuf1[eax]*/\
     ""psubw             %%mm4, %%mm5     \n\t"" /* uvbuf0[eax+2048] - uvbuf1[eax+2048]*/\
     ""movq ""CHR_MMX_FILTER_OFFSET""+8(""#c""), %%mm0    \n\t""\
@@ -969,8 +969,8 @@ static inline void RENAME(yuv2yuyv422_X)(SwsContext *c, const int16_t *lumFilter
 
 #define YSCALEYUV2RGB_YA(index, c, b1, b2) REAL_YSCALEYUV2RGB_YA(index, c, b1, b2)
 
-#define YSCALEYUV2RGB(index, c, uv_off) \
-    REAL_YSCALEYUV2RGB_UV(index, c, uv_off) \
+#define YSCALEYUV2RGB(index, c) \
+    REAL_YSCALEYUV2RGB_UV(index, c) \
     REAL_YSCALEYUV2RGB_YA(index, c, %0, %1) \
     REAL_YSCALEYUV2RGB_COEFF(c)
 
@@ -984,12 +984,10 @@ static inline void RENAME(yuv2rgb32_2)(SwsContext *c, const uint16_t *buf0,
                                        const uint16_t *abuf1, uint8_t *dest,
                                        int dstW, int yalpha, int uvalpha, int y)
 {
-    x86_reg uv_off = c->uv_off << 1;
-
     if (CONFIG_SWSCALE_ALPHA && c->alpPixBuf) {
 #if ARCH_X86_64
         __asm__ volatile(
-            YSCALEYUV2RGB(%%r8, %5, %8)
+            YSCALEYUV2RGB(%%r8, %5)
             YSCALEYUV2RGB_YA(%%r8, %5, %6, %7)
             ""psraw                  $3, %%mm1       \n\t"" /* abuf0[eax] - abuf1[eax] >>7*/
             ""psraw                  $3, %%mm7       \n\t"" /* abuf0[eax] - abuf1[eax] >>7*/
@@ -997,7 +995,7 @@ static inline void RENAME(yuv2rgb32_2)(SwsContext *c, const uint16_t *buf0,
             WRITEBGR32(%4, 8280(%5), %%r8, %%mm2, %%mm4, %%mm5, %%mm1, %%mm0, %%mm7, %%mm3, %%mm6)
             :: ""c"" (buf0), ""d"" (buf1), ""S"" (ubuf0), ""D"" (ubuf1), ""r"" (dest),
                ""a"" (&c->redDither),
-               ""r"" (abuf0), ""r"" (abuf1), ""m""(uv_off)
+               ""r"" (abuf0), ""r"" (abuf1)
             : ""%r8""
         );
 #else
@@ -1007,7 +1005,7 @@ static inline void RENAME(yuv2rgb32_2)(SwsContext *c, const uint16_t *buf0,
             ""mov %%""REG_b"", ""ESP_OFFSET""(%5)        \n\t""
             ""mov        %4, %%""REG_b""               \n\t""
             ""push %%""REG_BP""                        \n\t""
-            YSCALEYUV2RGB(%%REGBP, %5, %6)
+            YSCALEYUV2RGB(%%REGBP, %5)
             ""push                   %0              \n\t""
             ""push                   %1              \n\t""
             ""mov          ""U_TEMP""(%5), %0          \n\t""
@@ -1022,7 +1020,7 @@ static inline void RENAME(yuv2rgb32_2)(SwsContext *c, const uint16_t *buf0,
             ""pop %%""REG_BP""                         \n\t""
             ""mov ""ESP_OFFSET""(%5), %%""REG_b""        \n\t""
             :: ""c"" (buf0), ""d"" (buf1), ""S"" (ubuf0), ""D"" (ubuf1), ""m"" (dest),
-               ""a"" (&c->redDither), ""m""(uv_off)
+               ""a"" (&c->redDither)
         );
 #endif
     } else {
@@ -1030,13 +1028,13 @@ static inline void RENAME(yuv2rgb32_2)(SwsContext *c, const uint16_t *buf0,
             ""mov %%""REG_b"", ""ESP_OFFSET""(%5)        \n\t""
             ""mov        %4, %%""REG_b""               \n\t""
             ""push %%""REG_BP""                        \n\t""
-            YSCALEYUV2RGB(%%REGBP, %5, %6)
+            YSCALEYUV2RGB(%%REGBP, %5)
             ""pcmpeqd %%mm7, %%mm7                   \n\t""
             WRITEBGR32(%%REGb, 8280(%5), %%REGBP, %%mm2, %%mm4, %%mm5, %%mm7, %%mm0, %%mm1, %%mm3, %%mm6)
             ""pop %%""REG_BP""                         \n\t""
             ""mov ""ESP_OFFSET""(%5), %%""REG_b""        \n\t""
             :: ""c"" (buf0), ""d"" (buf1), ""S"" (ubuf0), ""D"" (ubuf1), ""m"" (dest),
-               ""a"" (&c->redDither), ""m""(uv_off)
+               ""a"" (&c->redDither)
         );
     }
 }
@@ -1048,20 +1046,18 @@ static inline void RENAME(yuv2bgr24_2)(SwsContext *c, const uint16_t *buf0,
                                        const uint16_t *abuf1, uint8_t *dest,
                                        int dstW, int yalpha, int uvalpha, int y)
 {
-    x86_reg uv_off = c->uv_off << 1;
-
     //Note 8280 == DSTW_OFFSET but the preprocessor can't handle that there :(
     __asm__ volatile(
         ""mov %%""REG_b"", ""ESP_OFFSET""(%5)        \n\t""
         ""mov        %4, %%""REG_b""               \n\t""
         ""push %%""REG_BP""                        \n\t""
-        YSCALEYUV2RGB(%%REGBP, %5, %6)
+        YSCALEYUV2RGB(%%REGBP, %5)
         ""pxor    %%mm7, %%mm7                   \n\t""
         WRITEBGR24(%%REGb, 8280(%5), %%REGBP)
         ""pop %%""REG_BP""                         \n\t""
         ""mov ""ESP_OFFSET""(%5), %%""REG_b""        \n\t""
         :: ""c"" (buf0), ""d"" (buf1), ""S"" (ubuf0), ""D"" (ubuf1), ""m"" (dest),
-           ""a"" (&c->redDither), ""m""(uv_off)
+           ""a"" (&c->redDither)
     );
 }
 
@@ -1072,14 +1068,12 @@ static inline void RENAME(yuv2rgb555_2)(SwsContext *c, const uint16_t *buf0,
                                         const uint16_t *abuf1, uint8_t *dest,
                                         int dstW, int yalpha, int uvalpha, int y)
 {
-    x86_reg uv_off = c->uv_off << 1;
-
     //Note 8280 == DSTW_OFFSET but the preprocessor can't handle that there :(
     __asm__ volatile(
         ""mov %%""REG_b"", ""ESP_OFFSET""(%5)        \n\t""
         ""mov        %4, %%""REG_b""               \n\t""
         ""push %%""REG_BP""                        \n\t""
-        YSCALEYUV2RGB(%%REGBP, %5, %6)
+        YSCALEYUV2RGB(%%REGBP, %5)
         ""pxor    %%mm7, %%mm7                   \n\t""
         /* mm2=B, %%mm4=G, %%mm5=R, %%mm7=0 */
 #ifdef DITHER1XBPP
@@ -1091,7 +1085,7 @@ static inline void RENAME(yuv2rgb555_2)(SwsContext *c, const uint16_t *buf0,
         ""pop %%""REG_BP""                         \n\t""
         ""mov ""ESP_OFFSET""(%5), %%""REG_b""        \n\t""
         :: ""c"" (buf0), ""d"" (buf1), ""S"" (ubuf0), ""D"" (ubuf1), ""m"" (dest),
-           ""a"" (&c->redDither), ""m""(uv_off)
+           ""a"" (&c->redDither)
     );
 }
 
@@ -1102,14 +1096,12 @@ static inline void RENAME(yuv2rgb565_2)(SwsContext *c, const uint16_t *buf0,
                                         const uint16_t *abuf1, uint8_t *dest,
                                         int dstW, int yalpha, int uvalpha, int y)
 {
-    x86_reg uv_off = c->uv_off << 1;
-
     //Note 8280 == DSTW_OFFSET but the preprocessor can't handle that there :(
     __asm__ volatile(
         ""mov %%""REG_b"", ""ESP_OFFSET""(%5)        \n\t""
         ""mov        %4, %%""REG_b""               \n\t""
         ""push %%""REG_BP""                        \n\t""
-        YSCALEYUV2RGB(%%REGBP, %5, %6)
+        YSCALEYUV2RGB(%%REGBP, %5)
         ""pxor    %%mm7, %%mm7                   \n\t""
         /* mm2=B, %%mm4=G, %%mm5=R, %%mm7=0 */
 #ifdef DITHER1XBPP
@@ -1121,11 +1113,11 @@ static inline void RENAME(yuv2rgb565_2)(SwsContext *c, const uint16_t *buf0,
         ""pop %%""REG_BP""                         \n\t""
         ""mov ""ESP_OFFSET""(%5), %%""REG_b""        \n\t""
         :: ""c"" (buf0), ""d"" (buf1), ""S"" (ubuf0), ""D"" (ubuf1), ""m"" (dest),
-           ""a"" (&c->redDither), ""m""(uv_off)
+           ""a"" (&c->redDither)
     );
 }
 
-#define REAL_YSCALEYUV2PACKED(index, c, uv_off) \
+#define REAL_YSCALEYUV2PACKED(index, c) \
     ""movq ""CHR_MMX_FILTER_OFFSET""+8(""#c""), %%mm0              \n\t""\
     ""movq ""LUM_MMX_FILTER_OFFSET""+8(""#c""), %%mm1              \n\t""\
     ""psraw                $3, %%mm0                           \n\t""\
@@ -1137,10 +1129,10 @@ static inline void RENAME(yuv2rgb565_2)(SwsContext *c, const uint16_t *buf0,
     ""1:                                 \n\t""\
     ""movq     (%2, ""#index""), %%mm2     \n\t"" /* uvbuf0[eax]*/\
     ""movq     (%3, ""#index""), %%mm3     \n\t"" /* uvbuf1[eax]*/\
-    ""add           ""#uv_off"", ""#index""  \n\t"" \
+    ""add           ""UV_OFFx2""(""#c""), ""#index""  \n\t"" \
     ""movq     (%2, ""#index""), %%mm5     \n\t"" /* uvbuf0[eax+2048]*/\
     ""movq     (%3, ""#index""), %%mm4     \n\t"" /* uvbuf1[eax+2048]*/\
-    ""sub           ""#uv_off"", ""#index""  \n\t"" \
+    ""sub           ""UV_OFFx2""(""#c""), ""#index""  \n\t"" \
     ""psubw             %%mm3, %%mm2     \n\t"" /* uvbuf0[eax] - uvbuf1[eax]*/\
     ""psubw             %%mm4, %%mm5     \n\t"" /* uvbuf0[eax+2048] - uvbuf1[eax+2048]*/\
     ""movq ""CHR_MMX_FILTER_OFFSET""+8(""#c""), %%mm0    \n\t""\
@@ -1163,7 +1155,7 @@ static inline void RENAME(yuv2rgb565_2)(SwsContext *c, const uint16_t *buf0,
     ""paddw             %%mm0, %%mm1     \n\t"" /* buf0[eax]yalpha1 + buf1[eax](1-yalpha1) >>16*/\
     ""paddw             %%mm6, %%mm7     \n\t"" /* buf0[eax]yalpha1 + buf1[eax](1-yalpha1) >>16*/\
 
-#define YSCALEYUV2PACKED(index, c, uv_off)  REAL_YSCALEYUV2PACKED(index, c, uv_off)
+#define YSCALEYUV2PACKED(index, c)  REAL_YSCALEYUV2PACKED(index, c)
 
 static inline void RENAME(yuv2yuyv422_2)(SwsContext *c, const uint16_t *buf0,
                                          const uint16_t *buf1, const uint16_t *ubuf0,
@@ -1172,30 +1164,28 @@ static inline void RENAME(yuv2yuyv422_2)(SwsContext *c, const uint16_t *buf0,
                                          const uint16_t *abuf1, uint8_t *dest,
                                          int dstW, int yalpha, int uvalpha, int y)
 {
-    x86_reg uv_off = c->uv_off << 1;
-
     //Note 8280 == DSTW_OFFSET but the preprocessor can't handle that there :(
     __asm__ volatile(
         ""mov %%""REG_b"", ""ESP_OFFSET""(%5)        \n\t""
         ""mov %4, %%""REG_b""                        \n\t""
         ""push %%""REG_BP""                        \n\t""
-        YSCALEYUV2PACKED(%%REGBP, %5, %6)
+        YSCALEYUV2PACKED(%%REGBP, %5)
         WRITEYUY2(%%REGb, 8280(%5), %%REGBP)
         ""pop %%""REG_BP""                         \n\t""
         ""mov ""ESP_OFFSET""(%5), %%""REG_b""        \n\t""
         :: ""c"" (buf0), ""d"" (buf1), ""S"" (ubuf0), ""D"" (ubuf1), ""m"" (dest),
-           ""a"" (&c->redDither), ""m""(uv_off)
+           ""a"" (&c->redDither)
     );
 }
 
-#define REAL_YSCALEYUV2RGB1(index, c, uv_off) \
+#define REAL_YSCALEYUV2RGB1(index, c) \
     ""xor            ""#index"", ""#index""  \n\t""\
     "".p2align              4            \n\t""\
     ""1:                                 \n\t""\
     ""movq     (%2, ""#index""), %%mm3     \n\t"" /* uvbuf0[eax]*/\
-    ""add           ""#uv_off"", ""#index""  \n\t"" \
+    ""add           ""UV_OFFx2""(""#c""), ""#index""  \n\t"" \
     ""movq     (%2, ""#index""), %%mm4     \n\t"" /* uvbuf0[eax+2048]*/\
-    ""sub           ""#uv_off"", ""#index""  \n\t"" \
+    ""sub           ""UV_OFFx2""(""#c""), ""#index""  \n\t"" \
     ""psraw                $4, %%mm3     \n\t"" /* uvbuf0[eax] - uvbuf1[eax] >>4*/\
     ""psraw                $4, %%mm4     \n\t"" /* uvbuf0[eax+2048] - uvbuf1[eax+2048] >>4*/\
     ""psubw  ""U_OFFSET""(""#c""), %%mm3     \n\t"" /* (U-128)8*/\
@@ -1237,19 +1227,19 @@ static inline void RENAME(yuv2yuyv422_2)(SwsContext *c, const uint16_t *buf0,
     ""packuswb          %%mm6, %%mm5     \n\t""\
     ""packuswb          %%mm3, %%mm4     \n\t""\
 
-#define YSCALEYUV2RGB1(index, c, uv_off)  REAL_YSCALEYUV2RGB1(index, c, uv_off)
+#define YSCALEYUV2RGB1(index, c)  REAL_YSCALEYUV2RGB1(index, c)
 
 // do vertical chrominance interpolation
-#define REAL_YSCALEYUV2RGB1b(index, c, uv_off) \
+#define REAL_YSCALEYUV2RGB1b(index, c) \
     ""xor            ""#index"", ""#index""  \n\t""\
     "".p2align              4            \n\t""\
     ""1:                                 \n\t""\
     ""movq     (%2, ""#index""), %%mm2     \n\t"" /* uvbuf0[eax]*/\
     ""movq     (%3, ""#index""), %%mm3     \n\t"" /* uvbuf1[eax]*/\
-    ""add           ""#uv_off"", ""#index""  \n\t"" \
+    ""add           ""UV_OFFx2""(""#c""), ""#index""  \n\t"" \
     ""movq     (%2, ""#index""), %%mm5     \n\t"" /* uvbuf0[eax+2048]*/\
     ""movq     (%3, ""#index""), %%mm4     \n\t"" /* uvbuf1[eax+2048]*/\
-    ""sub           ""#uv_off"", ""#index""  \n\t"" \
+    ""sub           ""UV_OFFx2""(""#c""), ""#index""  \n\t"" \
     ""paddw             %%mm2, %%mm3     \n\t"" /* uvbuf0[eax] + uvbuf1[eax]*/\
     ""paddw             %%mm5, %%mm4     \n\t"" /* uvbuf0[eax+2048] + uvbuf1[eax+2048]*/\
     ""psrlw                $5, %%mm3     \n\t"" /*FIXME might overflow*/\
@@ -1293,7 +1283,7 @@ static inline void RENAME(yuv2yuyv422_2)(SwsContext *c, const uint16_t *buf0,
     ""packuswb          %%mm6, %%mm5     \n\t""\
     ""packuswb          %%mm3, %%mm4     \n\t""\
 
-#define YSCALEYUV2RGB1b(index, c, uv_off)  REAL_YSCALEYUV2RGB1b(index, c, uv_off)
+#define YSCALEYUV2RGB1b(index, c)  REAL_YSCALEYUV2RGB1b(index, c)
 
 #define REAL_YSCALEYUV2RGB1_ALPHA(index) \
     ""movq  (%1, ""#index"", 2), %%mm7     \n\t"" /* abuf0[index  ]     */\
@@ -1313,7 +1303,6 @@ static inline void RENAME(yuv2rgb32_1)(SwsContext *c, const uint16_t *buf0,
                                        int dstW, int uvalpha, enum PixelFormat dstFormat,
                                        int flags, int y)
 {
-    x86_reg uv_off = c->uv_off << 1;
     const uint16_t *buf1= buf0; //FIXME needed for RGB1/BGR1
 
     if (uvalpha < 2048) { // note this is not correct (shifts chrominance by 0.5 pixels) but it is a bit faster
@@ -1322,26 +1311,26 @@ static inline void RENAME(yuv2rgb32_1)(SwsContext *c, const uint16_t *buf0,
                 ""mov %%""REG_b"", ""ESP_OFFSET""(%5)        \n\t""
                 ""mov        %4, %%""REG_b""               \n\t""
                 ""push %%""REG_BP""                        \n\t""
-                YSCALEYUV2RGB1(%%REGBP, %5, %6)
+                YSCALEYUV2RGB1(%%REGBP, %5)
                 YSCALEYUV2RGB1_ALPHA(%%REGBP)
                 WRITEBGR32(%%REGb, 8280(%5), %%REGBP, %%mm2, %%mm4, %%mm5, %%mm7, %%mm0, %%mm1, %%mm3, %%mm6)
                 ""pop %%""REG_BP""                         \n\t""
                 ""mov ""ESP_OFFSET""(%5), %%""REG_b""        \n\t""
                 :: ""c"" (buf0), ""d"" (abuf0), ""S"" (ubuf0), ""D"" (ubuf1), ""m"" (dest),
-                   ""a"" (&c->redDither), ""m""(uv_off)
+                   ""a"" (&c->redDither)
             );
         } else {
             __asm__ volatile(
                 ""mov %%""REG_b"", ""ESP_OFFSET""(%5)        \n\t""
                 ""mov        %4, %%""REG_b""               \n\t""
                 ""push %%""REG_BP""                        \n\t""
-                YSCALEYUV2RGB1(%%REGBP, %5, %6)
+                YSCALEYUV2RGB1(%%REGBP, %5)
                 ""pcmpeqd %%mm7, %%mm7                   \n\t""
                 WRITEBGR32(%%REGb, 8280(%5), %%REGBP, %%mm2, %%mm4, %%mm5, %%mm7, %%mm0, %%mm1, %%mm3, %%mm6)
                 ""pop %%""REG_BP""                         \n\t""
                 ""mov ""ESP_OFFSET""(%5), %%""REG_b""        \n\t""
                 :: ""c"" (buf0), ""d"" (buf1), ""S"" (ubuf0), ""D"" (ubuf1), ""m"" (dest),
-                   ""a"" (&c->redDither), ""m""(uv_off)
+                   ""a"" (&c->redDither)
             );
         }
     } else {
@@ -1350,26 +1339,26 @@ static inline void RENAME(yuv2rgb32_1)(SwsContext *c, const uint16_t *buf0,
                 ""mov %%""REG_b"", ""ESP_OFFSET""(%5)        \n\t""
                 ""mov        %4, %%""REG_b""               \n\t""
                 ""push %%""REG_BP""                        \n\t""
-                YSCALEYUV2RGB1b(%%REGBP, %5, %6)
+                YSCALEYUV2RGB1b(%%REGBP, %5)
                 YSCALEYUV2RGB1_ALPHA(%%REGBP)
                 WRITEBGR32(%%REGb, 8280(%5), %%REGBP, %%mm2, %%mm4, %%mm5, %%mm7, %%mm0, %%mm1, %%mm3, %%mm6)
                 ""pop %%""REG_BP""                         \n\t""
                 ""mov ""ESP_OFFSET""(%5), %%""REG_b""        \n\t""
                 :: ""c"" (buf0), ""d"" (abuf0), ""S"" (ubuf0), ""D"" (ubuf1), ""m"" (dest),
-                   ""a"" (&c->redDither), ""m""(uv_off)
+                   ""a"" (&c->redDither)
             );
         } else {
             __asm__ volatile(
                 ""mov %%""REG_b"", ""ESP_OFFSET""(%5)        \n\t""
                 ""mov        %4, %%""REG_b""               \n\t""
                 ""push %%""REG_BP""                        \n\t""
-                YSCALEYUV2RGB1b(%%REGBP, %5, %6)
+                YSCALEYUV2RGB1b(%%REGBP, %5)
                 ""pcmpeqd %%mm7, %%mm7                   \n\t""
                 WRITEBGR32(%%REGb, 8280(%5), %%REGBP, %%mm2, %%mm4, %%mm5, %%mm7, %%mm0, %%mm1, %%mm3, %%mm6)
                 ""pop %%""REG_BP""                         \n\t""
                 ""mov ""ESP_OFFSET""(%5), %%""REG_b""        \n\t""
                 :: ""c"" (buf0), ""d"" (buf1), ""S"" (ubuf0), ""D"" (ubuf1), ""m"" (dest),
-                   ""a"" (&c->redDither), ""m""(uv_off)
+                   ""a"" (&c->redDither)
             );
         }
     }
@@ -1382,7 +1371,6 @@ static inline void RENAME(yuv2bgr24_1)(SwsContext *c, const uint16_t *buf0,
                                        int dstW, int uvalpha, enum PixelFormat dstFormat,
                                        int flags, int y)
 {
-    x86_reg uv_off = c->uv_off << 1;
     const uint16_t *buf1= buf0; //FIXME needed for RGB1/BGR1
 
     if (uvalpha < 2048) { // note this is not correct (shifts chrominance by 0.5 pixels) but it is a bit faster
@@ -1390,26 +1378,26 @@ static inline void RENAME(yuv2bgr24_1)(SwsContext *c, const uint16_t *buf0,
             ""mov %%""REG_b"", ""ESP_OFFSET""(%5)        \n\t""
             ""mov        %4, %%""REG_b""               \n\t""
             ""push %%""REG_BP""                        \n\t""
-            YSCALEYUV2RGB1(%%REGBP, %5, %6)
+            YSCALEYUV2RGB1(%%REGBP, %5)
             ""pxor    %%mm7, %%mm7                   \n\t""
             WRITEBGR24(%%REGb, 8280(%5), %%REGBP)
             ""pop %%""REG_BP""                         \n\t""
             ""mov ""ESP_OFFSET""(%5), %%""REG_b""        \n\t""
             :: ""c"" (buf0), ""d"" (buf1), ""S"" (ubuf0), ""D"" (ubuf1), ""m"" (dest),
-               ""a"" (&c->redDither), ""m""(uv_off)
+               ""a"" (&c->redDither)
         );
     } else {
         __asm__ volatile(
             ""mov %%""REG_b"", ""ESP_OFFSET""(%5)        \n\t""
             ""mov        %4, %%""REG_b""               \n\t""
             ""push %%""REG_BP""                        \n\t""
-            YSCALEYUV2RGB1b(%%REGBP, %5, %6)
+            YSCALEYUV2RGB1b(%%REGBP, %5)
             ""pxor    %%mm7, %%mm7                   \n\t""
             WRITEBGR24(%%REGb, 8280(%5), %%REGBP)
             ""pop %%""REG_BP""                         \n\t""
             ""mov ""ESP_OFFSET""(%5), %%""REG_b""        \n\t""
             :: ""c"" (buf0), ""d"" (buf1), ""S"" (ubuf0), ""D"" (ubuf1), ""m"" (dest),
-               ""a"" (&c->redDither), ""m""(uv_off)
+               ""a"" (&c->redDither)
         );
     }
 }
@@ -1421,7 +1409,6 @@ static inline void RENAME(yuv2rgb555_1)(SwsContext *c, const uint16_t *buf0,
                                         int dstW, int uvalpha, enum PixelFormat dstFormat,
                                         int flags, int y)
 {
-    x86_reg uv_off = c->uv_off << 1;
     const uint16_t *buf1= buf0; //FIXME needed for RGB1/BGR1
 
     if (uvalpha < 2048) { // note this is not correct (shifts chrominance by 0.5 pixels) but it is a bit faster
@@ -1429,7 +1416,7 @@ static inline void RENAME(yuv2rgb555_1)(SwsContext *c, const uint16_t *buf0,
             ""mov %%""REG_b"", ""ESP_OFFSET""(%5)        \n\t""
             ""mov        %4, %%""REG_b""               \n\t""
             ""push %%""REG_BP""                        \n\t""
-            YSCALEYUV2RGB1(%%REGBP, %5, %6)
+            YSCALEYUV2RGB1(%%REGBP, %5)
             ""pxor    %%mm7, %%mm7                   \n\t""
             /* mm2=B, %%mm4=G, %%mm5=R, %%mm7=0 */
 #ifdef DITHER1XBPP
@@ -1441,14 +1428,14 @@ static inline void RENAME(yuv2rgb555_1)(SwsContext *c, const uint16_t *buf0,
             ""pop %%""REG_BP""                         \n\t""
             ""mov ""ESP_OFFSET""(%5), %%""REG_b""        \n\t""
             :: ""c"" (buf0), ""d"" (buf1), ""S"" (ubuf0), ""D"" (ubuf1), ""m"" (dest),
-               ""a"" (&c->redDither), ""m""(uv_off)
+               ""a"" (&c->redDither)
         );
     } else {
         __asm__ volatile(
             ""mov %%""REG_b"", ""ESP_OFFSET""(%5)        \n\t""
             ""mov        %4, %%""REG_b""               \n\t""
             ""push %%""REG_BP""                        \n\t""
-            YSCALEYUV2RGB1b(%%REGBP, %5, %6)
+            YSCALEYUV2RGB1b(%%REGBP, %5)
             ""pxor    %%mm7, %%mm7                   \n\t""
             /* mm2=B, %%mm4=G, %%mm5=R, %%mm7=0 */
 #ifdef DITHER1XBPP
@@ -1460,7 +1447,7 @@ static inline void RENAME(yuv2rgb555_1)(SwsContext *c, const uint16_t *buf0,
             ""pop %%""REG_BP""                         \n\t""
             ""mov ""ESP_OFFSET""(%5), %%""REG_b""        \n\t""
             :: ""c"" (buf0), ""d"" (buf1), ""S"" (ubuf0), ""D"" (ubuf1), ""m"" (dest),
-               ""a"" (&c->redDither), ""m""(uv_off)
+               ""a"" (&c->redDither)
         );
     }
 }
@@ -1472,7 +1459,6 @@ static inline void RENAME(yuv2rgb565_1)(SwsContext *c, const uint16_t *buf0,
                                         int dstW, int uvalpha, enum PixelFormat dstFormat,
                                         int flags, int y)
 {
-    x86_reg uv_off = c->uv_off << 1;
     const uint16_t *buf1= buf0; //FIXME needed for RGB1/BGR1
 
     if (uvalpha < 2048) { // note this is not correct (shifts chrominance by 0.5 pixels) but it is a bit faster
@@ -1480,7 +1466,7 @@ static inline void RENAME(yuv2rgb565_1)(SwsContext *c, const uint16_t *buf0,
             ""mov %%""REG_b"", ""ESP_OFFSET""(%5)        \n\t""
             ""mov        %4, %%""REG_b""               \n\t""
             ""push %%""REG_BP""                        \n\t""
-            YSCALEYUV2RGB1(%%REGBP, %5, %6)
+            YSCALEYUV2RGB1(%%REGBP, %5)
             ""pxor    %%mm7, %%mm7                   \n\t""
             /* mm2=B, %%mm4=G, %%mm5=R, %%mm7=0 */
 #ifdef DITHER1XBPP
@@ -1492,14 +1478,14 @@ static inline void RENAME(yuv2rgb565_1)(SwsContext *c, const uint16_t *buf0,
             ""pop %%""REG_BP""                         \n\t""
             ""mov ""ESP_OFFSET""(%5), %%""REG_b""        \n\t""
             :: ""c"" (buf0), ""d"" (buf1), ""S"" (ubuf0), ""D"" (ubuf1), ""m"" (dest),
-               ""a"" (&c->redDither), ""m""(uv_off)
+               ""a"" (&c->redDither)
         );
     } else {
         __asm__ volatile(
             ""mov %%""REG_b"", ""ESP_OFFSET""(%5)        \n\t""
             ""mov        %4, %%""REG_b""               \n\t""
             ""push %%""REG_BP""                        \n\t""
-            YSCALEYUV2RGB1b(%%REGBP, %5, %6)
+            YSCALEYUV2RGB1b(%%REGBP, %5)
             ""pxor    %%mm7, %%mm7                   \n\t""
             /* mm2=B, %%mm4=G, %%mm5=R, %%mm7=0 */
 #ifdef DITHER1XBPP
@@ -1511,19 +1497,19 @@ static inline void RENAME(yuv2rgb565_1)(SwsContext *c, const uint16_t *buf0,
             ""pop %%""REG_BP""                         \n\t""
             ""mov ""ESP_OFFSET""(%5), %%""REG_b""        \n\t""
             :: ""c"" (buf0), ""d"" (buf1), ""S"" (ubuf0), ""D"" (ubuf1), ""m"" (dest),
-               ""a"" (&c->redDither), ""m""(uv_off)
+               ""a"" (&c->redDither)
         );
     }
 }
 
-#define REAL_YSCALEYUV2PACKED1(index, c, uv_off) \
+#define REAL_YSCALEYUV2PACKED1(index, c) \
     ""xor            ""#index"", ""#index""  \n\t""\
     "".p2align              4            \n\t""\
     ""1:                                 \n\t""\
     ""movq     (%2, ""#index""), %%mm3     \n\t"" /* uvbuf0[eax]*/\
-    ""add           ""#uv_off"", ""#index""  \n\t"" \
+    ""add           ""UV_OFFx2""(""#c""), ""#index""  \n\t"" \
     ""movq     (%2, ""#index""), %%mm4     \n\t"" /* uvbuf0[eax+2048]*/\
-    ""sub           ""#uv_off"", ""#index""  \n\t"" \
+    ""sub           ""UV_OFFx2""(""#c""), ""#index""  \n\t"" \
     ""psraw                $7, %%mm3     \n\t"" \
     ""psraw                $7, %%mm4     \n\t"" \
     ""movq  (%0, ""#index"", 2), %%mm1     \n\t"" /*buf0[eax]*/\
@@ -1531,18 +1517,18 @@ static inline void RENAME(yuv2rgb565_1)(SwsContext *c, const uint16_t *buf0,
     ""psraw                $7, %%mm1     \n\t"" \
     ""psraw                $7, %%mm7     \n\t"" \
 
-#define YSCALEYUV2PACKED1(index, c, uv_off)  REAL_YSCALEYUV2PACKED1(index, c, uv_off)
+#define YSCALEYUV2PACKED1(index, c)  REAL_YSCALEYUV2PACKED1(index, c)
 
-#define REAL_YSCALEYUV2PACKED1b(index, c, uv_off) \
+#define REAL_YSCALEYUV2PACKED1b(index, c) \
     ""xor ""#index"", ""#index""             \n\t""\
     "".p2align              4            \n\t""\
     ""1:                                 \n\t""\
     ""movq     (%2, ""#index""), %%mm2     \n\t"" /* uvbuf0[eax]*/\
     ""movq     (%3, ""#index""), %%mm3     \n\t"" /* uvbuf1[eax]*/\
-    ""add           ""#uv_off"", ""#index""  \n\t"" \
+    ""add           ""UV_OFFx2""(""#c""), ""#index""  \n\t"" \
     ""movq     (%2, ""#index""), %%mm5     \n\t"" /* uvbuf0[eax+2048]*/\
     ""movq     (%3, ""#index""), %%mm4     \n\t"" /* uvbuf1[eax+2048]*/\
-    ""sub           ""#uv_off"", ""#index""  \n\t"" \
+    ""sub           ""UV_OFFx2""(""#c""), ""#index""  \n\t"" \
     ""paddw             %%mm2, %%mm3     \n\t"" /* uvbuf0[eax] + uvbuf1[eax]*/\
     ""paddw             %%mm5, %%mm4     \n\t"" /* uvbuf0[eax+2048] + uvbuf1[eax+2048]*/\
     ""psrlw                $8, %%mm3     \n\t"" \
@@ -1551,7 +1537,7 @@ static inline void RENAME(yuv2rgb565_1)(SwsContext *c, const uint16_t *buf0,
     ""movq 8(%0, ""#index"", 2), %%mm7     \n\t"" /*buf0[eax]*/\
     ""psraw                $7, %%mm1     \n\t"" \
     ""psraw                $7, %%mm7     \n\t""
-#define YSCALEYUV2PACKED1b(index, c, uv_off)  REAL_YSCALEYUV2PACKED1b(index, c, uv_off)
+#define YSCALEYUV2PACKED1b(index, c)  REAL_YSCALEYUV2PACKED1b(index, c)
 
 static inline void RENAME(yuv2yuyv422_1)(SwsContext *c, const uint16_t *buf0,
                                          const uint16_t *ubuf0, const uint16_t *ubuf1,
@@ -1560,7 +1546,6 @@ static inline void RENAME(yuv2yuyv422_1)(SwsContext *c, const uint16_t *buf0,
                                          int dstW, int uvalpha, enum PixelFormat dstFormat,
                                          int flags, int y)
 {
-    x86_reg uv_off = c->uv_off << 1;
     const uint16_t *buf1= buf0; //FIXME needed for RGB1/BGR1
 
     if (uvalpha < 2048) { // note this is not correct (shifts chrominance by 0.5 pixels) but it is a bit faster
@@ -1568,24 +1553,24 @@ static inline void RENAME(yuv2yuyv422_1)(SwsContext *c, const uint16_t *buf0,
             ""mov %%""REG_b"", ""ESP_OFFSET""(%5)        \n\t""
             ""mov        %4, %%""REG_b""               \n\t""
             ""push %%""REG_BP""                        \n\t""
-            YSCALEYUV2PACKED1(%%REGBP, %5, %6)
+            YSCALEYUV2PACKED1(%%REGBP, %5)
             WRITEYUY2(%%REGb, 8280(%5), %%REGBP)
             ""pop %%""REG_BP""                         \n\t""
             ""mov ""ESP_OFFSET""(%5), %%""REG_b""        \n\t""
             :: ""c"" (buf0), ""d"" (buf1), ""S"" (ubuf0), ""D"" (ubuf1), ""m"" (dest),
-               ""a"" (&c->redDither), ""m""(uv_off)
+               ""a"" (&c->redDither)
         );
     } else {
         __asm__ volatile(
             ""mov %%""REG_b"", ""ESP_OFFSET""(%5)        \n\t""
             ""mov        %4, %%""REG_b""               \n\t""
             ""push %%""REG_BP""                        \n\t""
-            YSCALEYUV2PACKED1b(%%REGBP, %5, %6)
+            YSCALEYUV2PACKED1b(%%REGBP, %5)
             WRITEYUY2(%%REGb, 8280(%5), %%REGBP)
             ""pop %%""REG_BP""                         \n\t""
             ""mov ""ESP_OFFSET""(%5), %%""REG_b""        \n\t""
             :: ""c"" (buf0), ""d"" (buf1), ""S"" (ubuf0), ""D"" (ubuf1), ""m"" (dest),
-               ""a"" (&c->redDither), ""m""(uv_off)
+               ""a"" (&c->redDither)
         );
     }
 }
",0,swscale: fix crash in bilinear scaling.
00a6b92bdd0618f74a7389b443a7862eb6750c1b,"@@ -1374,6 +1374,14 @@ static int mpegts_read_close(AVFormatContext *s)
     int i;
     for(i=0;i<NB_PID_MAX;i++)
         if (ts->pids[i]) mpegts_close_filter(ts, ts->pids[i]);
+
+    for(i = 0; i < ts->nb_services; i++){
+        av_free(ts->services[i]->provider_name);
+        av_free(ts->services[i]->name);
+        av_free(ts->services[i]);
+    }
+    av_freep(&ts->services);
+
     return 0;
 }
 
",0,fix memory leak on mpegts close
00aad121d8a6f365641345a8321bdaac1ff80649,"@@ -68,6 +68,12 @@ static int decode_frame(AVCodecContext *avctx,
     V = a->pic.data[2];
 
     stride = avctx->width - 4;
+
+    if (buf_size < avctx->width * avctx->height) {
+        av_log(avctx, AV_LOG_ERROR, ""Packet is too small\n"");
+        return AVERROR_INVALIDDATA;
+    }
+
     for (i = 0; i < avctx->height; i++) {
         /* lines are stored in reversed order */
         buf += stride;
",0,xl: Fix overreads
00b3ca3c7a779e3b062d6ef0c5067c60c8f8a357,"@@ -258,7 +258,8 @@ static int parse_inputs(const char **buf, AVFilterInOut **curr_inputs,
             av_free(name);
         } else {
             /* Not in the list, so add it as an input */
-            match = av_mallocz(sizeof(AVFilterInOut));
+            if (!(match = av_mallocz(sizeof(AVFilterInOut))))
+                return AVERROR(ENOMEM);
             match->name    = name;
             match->pad_idx = pad;
         }
",0,"Add missing memory check in parse_inputs(), and fix possible (yet very unlikely) crash."
00b8702581f312aa46f797a8b3153d9b2892d967,"@@ -705,13 +705,19 @@ static void get_pci_host_devaddr(Object *obj, Visitor *v, const char *name,
     DeviceState *dev = DEVICE(obj);
     Property *prop = opaque;
     PCIHostDeviceAddress *addr = qdev_get_prop_ptr(dev, prop);
-    char buffer[] = ""xxxx:xx:xx.x"";
+    char buffer[] = ""ffff:ff:ff.f"";
     char *p = buffer;
     int rc = 0;
 
-    rc = snprintf(buffer, sizeof(buffer), ""%04x:%02x:%02x.%d"",
-                  addr->domain, addr->bus, addr->slot, addr->function);
-    assert(rc == sizeof(buffer) - 1);
+    /*
+     * Catch ""invalid"" device reference from vfio-pci and allow the
+     * default buffer representing the non-existant device to be used.
+     */
+    if (~addr->domain || ~addr->bus || ~addr->slot || ~addr->function) {
+        rc = snprintf(buffer, sizeof(buffer), ""%04x:%02x:%02x.%0d"",
+                      addr->domain, addr->bus, addr->slot, addr->function);
+        assert(rc == sizeof(buffer) - 1);
+    }
 
     visit_type_str(v, name, &p, errp);
 }
",0,qdev: Fix assert in PCI address property when used by vfio-pci
00c322014904c2d5be92cc292b162d31f18a7058,"@@ -50,14 +50,22 @@ static int query_formats(AVFilterContext *ctx)
     AVFilterFormats *in  = ff_make_format_list(in_fmts);
     AVFilterFormats *out = ff_make_format_list(out_fmts);
     if (!in || !out) {
-        av_freep(&in);
-        av_freep(&out);
-        return AVERROR(ENOMEM);
+        ret = AVERROR(ENOMEM);
+        goto fail;
     }
+
     if ((ret = ff_formats_ref(in , &ctx->inputs[0]->out_formats)) < 0 ||
         (ret = ff_formats_ref(out, &ctx->outputs[0]->in_formats)) < 0)
-        return ret;
+        goto fail;
     return 0;
+fail:
+    if (in)
+        av_freep(&in->formats);
+    av_freep(&in);
+    if (out)
+        av_freep(&out->formats);
+    av_freep(&out);
+    return ret;
 }
 
 static int config_output(AVFilterLink *outlink)
",0,lavfi/show_palette: fix memory leak
00cbe9e4053fd562b6f21e76aca6636ff926b637,"@@ -523,7 +523,10 @@ static int vmdaudio_decode_frame(AVCodecContext *avctx,
 
     silent_chunks = 0;
     if (block_type == BLOCK_TYPE_INITIAL) {
-        uint32_t flags = AV_RB32(buf);
+        uint32_t flags;
+        if (buf_size < 4)
+            return -1;
+        flags = AV_RB32(buf);
         silent_chunks  = av_popcount(flags);
         buf      += 4;
         buf_size -= 4;
",0,Fix potential overread in vmd audio decoder.
00d2f3707a63881a0cec8d00cbd467f9b2d8af41,"@@ -154,6 +154,8 @@ void qmp_guest_set_time(bool has_time, int64_t time_ns, Error **errp)
 
     /* If user has passed a time, validate and set it. */
     if (has_time) {
+        GDate date = { 0, };
+
         /* year-2038 will overflow in case time_t is 32bit */
         if (time_ns / 1000000000 != (time_t)(time_ns / 1000000000)) {
             error_setg(errp, ""Time %"" PRId64 "" is too large"", time_ns);
@@ -162,6 +164,11 @@ void qmp_guest_set_time(bool has_time, int64_t time_ns, Error **errp)
 
         tv.tv_sec = time_ns / 1000000000;
         tv.tv_usec = (time_ns % 1000000000) / 1000;
+        g_date_set_time_t(&date, tv.tv_sec);
+        if (date.year < 1970 || date.year >= 2070) {
+            error_setg_errno(errp, errno, ""Invalid time"");
+            return;
+        }
 
         ret = settimeofday(&tv, NULL);
         if (ret < 0) {
",0,qga: fail early for invalid time
00d965474b22b54e4275232bc71ee0c699c5cd21,"@@ -1388,10 +1388,15 @@ static int aes_gcm_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)
                 EVP_CIPHER_CTX_buf_noconst(c)[arg - 2] << 8
                 | EVP_CIPHER_CTX_buf_noconst(c)[arg - 1];
             /* Correct length for explicit IV */
+            if (len < EVP_GCM_TLS_EXPLICIT_IV_LEN)
+                return 0;
             len -= EVP_GCM_TLS_EXPLICIT_IV_LEN;
             /* If decrypting correct for tag too */
-            if (!EVP_CIPHER_CTX_encrypting(c))
+            if (!EVP_CIPHER_CTX_encrypting(c)) {
+                if (len < EVP_GCM_TLS_TAG_LEN)
+                    return 0;
                 len -= EVP_GCM_TLS_TAG_LEN;
+            }
             EVP_CIPHER_CTX_buf_noconst(c)[arg - 2] = len >> 8;
             EVP_CIPHER_CTX_buf_noconst(c)[arg - 1] = len & 0xff;
         }
@@ -1946,10 +1951,15 @@ static int aes_ccm_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)
                 EVP_CIPHER_CTX_buf_noconst(c)[arg - 2] << 8
                 | EVP_CIPHER_CTX_buf_noconst(c)[arg - 1];
             /* Correct length for explicit IV */
+            if (len < EVP_CCM_TLS_EXPLICIT_IV_LEN)
+                return 0;
             len -= EVP_CCM_TLS_EXPLICIT_IV_LEN;
             /* If decrypting correct for tag too */
-            if (!EVP_CIPHER_CTX_encrypting(c))
+            if (!EVP_CIPHER_CTX_encrypting(c)) {
+                if (len < cctx->M)
+                    return 0;
                 len -= cctx->M;
+            }
             EVP_CIPHER_CTX_buf_noconst(c)[arg - 2] = len >> 8;
             EVP_CIPHER_CTX_buf_noconst(c)[arg - 1] = len & 0xff;
         }

@@ -398,6 +398,8 @@ static int chacha20_poly1305_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg,
             len = aad[EVP_AEAD_TLS1_AAD_LEN - 2] << 8 |
                   aad[EVP_AEAD_TLS1_AAD_LEN - 1];
             if (!ctx->encrypt) {
+                if (len < POLY1305_BLOCK_SIZE)
+                    return 0;
                 len -= POLY1305_BLOCK_SIZE;     /* discount attached tag */
                 memcpy(temp, aad, EVP_AEAD_TLS1_AAD_LEN - 2);
                 aad = temp;
@@ -407,8 +409,7 @@ static int chacha20_poly1305_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg,
             actx->tls_payload_length = len;
 
             /*
-             * merge record sequence number as per
-             * draft-ietf-tls-chacha20-poly1305-03
+             * merge record sequence number as per RFC7905
              */
             actx->key.counter[1] = actx->nonce[0];
             actx->key.counter[2] = actx->nonce[1] ^ CHACHA_U8TOU32(aad);
",0,crypto/evp: harden AEAD ciphers.
00dbff4c3e048b4abd01bf805725aabff0fa5ee1,"@@ -3348,7 +3348,7 @@ static int decode_slice_header(H264Context *h, H264Context *h0)
     first_mb_in_slice = get_ue_golomb(&h->gb);
 
     if (first_mb_in_slice == 0) { // FIXME better field boundary detection
-        if (h0->current_slice && FIELD_PICTURE(h)) {
+        if (h0->current_slice && h->cur_pic_ptr && FIELD_PICTURE(h)) {
             field_end(h, 1);
         }
 
",0,h264: do not call field_end if we do not have a current picture
00e1bf8a587e26029f8fb20a35c65b99fe14196b,"@@ -125,8 +125,10 @@ static int flic_read_header(AVFormatContext *s)
     }
 
     /* send over the whole 128-byte FLIC header */
-    st->codec->extradata_size = FLIC_HEADER_SIZE;
     st->codec->extradata = av_malloc(FLIC_HEADER_SIZE);
+    if (!st->codec->extradata)
+        return AVERROR(ENOMEM);
+    st->codec->extradata_size = FLIC_HEADER_SIZE;
     memcpy(st->codec->extradata, header, FLIC_HEADER_SIZE);
 
     /* peek at the preamble to detect TFTD videos - they seem to always start with an audio chunk */
@@ -176,8 +178,10 @@ static int flic_read_header(AVFormatContext *s)
 
         /* send over abbreviated FLIC header chunk */
         av_free(st->codec->extradata);
-        st->codec->extradata_size = 12;
         st->codec->extradata = av_malloc(12);
+        if (!st->codec->extradata)
+            return AVERROR(ENOMEM);
+        st->codec->extradata_size = 12;
         memcpy(st->codec->extradata, header, 12);
 
     } else if (magic_number == FLIC_FILE_MAGIC_1) {
",0,avformat/flic: check for memory allocation failures
00f4d64ee76e873be881a82d893a591487aa7950,"@@ -28,38 +28,6 @@ typedef struct KVMClockState {
     bool clock_valid;
 } KVMClockState;
 
-static void kvmclock_pre_save(void *opaque)
-{
-    KVMClockState *s = opaque;
-    struct kvm_clock_data data;
-    int ret;
-
-    if (s->clock_valid) {
-        return;
-    }
-    ret = kvm_vm_ioctl(kvm_state, KVM_GET_CLOCK, &data);
-    if (ret < 0) {
-        fprintf(stderr, ""KVM_GET_CLOCK failed: %s\n"", strerror(ret));
-        data.clock = 0;
-    }
-    s->clock = data.clock;
-    /*
-     * If the VM is stopped, declare the clock state valid to avoid re-reading
-     * it on next vmsave (which would return a different value). Will be reset
-     * when the VM is continued.
-     */
-    s->clock_valid = !runstate_is_running();
-}
-
-static int kvmclock_post_load(void *opaque, int version_id)
-{
-    KVMClockState *s = opaque;
-    struct kvm_clock_data data;
-
-    data.clock = s->clock;
-    data.flags = 0;
-    return kvm_vm_ioctl(kvm_state, KVM_SET_CLOCK, &data);
-}
 
 static void kvmclock_vm_state_change(void *opaque, int running,
                                      RunState state)
@@ -70,8 +38,18 @@ static void kvmclock_vm_state_change(void *opaque, int running,
     int ret;
 
     if (running) {
+        struct kvm_clock_data data;
+
         s->clock_valid = false;
 
+        data.clock = s->clock;
+        data.flags = 0;
+        ret = kvm_vm_ioctl(kvm_state, KVM_SET_CLOCK, &data);
+        if (ret < 0) {
+            fprintf(stderr, ""KVM_SET_CLOCK failed: %s\n"", strerror(ret));
+            abort();
+        }
+
         if (!cap_clock_ctrl) {
             return;
         }
@@ -84,6 +62,26 @@ static void kvmclock_vm_state_change(void *opaque, int running,
                 return;
             }
         }
+    } else {
+        struct kvm_clock_data data;
+        int ret;
+
+        if (s->clock_valid) {
+            return;
+        }
+        ret = kvm_vm_ioctl(kvm_state, KVM_GET_CLOCK, &data);
+        if (ret < 0) {
+            fprintf(stderr, ""KVM_GET_CLOCK failed: %s\n"", strerror(ret));
+            abort();
+        }
+        s->clock = data.clock;
+
+        /*
+         * If the VM is stopped, declare the clock state valid to
+         * avoid re-reading it on next vmsave (which would return
+         * a different value). Will be reset when the VM is continued.
+         */
+        s->clock_valid = true;
     }
 }
 
@@ -100,8 +98,6 @@ static const VMStateDescription kvmclock_vmsd = {
     .version_id = 1,
     .minimum_version_id = 1,
     .minimum_version_id_old = 1,
-    .pre_save = kvmclock_pre_save,
-    .post_load = kvmclock_post_load,
     .fields = (VMStateField[]) {
         VMSTATE_UINT64(clock, KVMClockState),
         VMSTATE_END_OF_LIST()
",0,kvmclock: clock should count only if vm is running
00f695aec78100076c4085388ad13eafe6eaa7c1,"@@ -118,6 +118,7 @@ void DesktopNativeWidgetHelperAura::PreInitialize(
   root_window_->SetEventFilter(root_window_event_filter_);
 
   input_method_filter_.reset(new aura::shared::InputMethodEventFilter());
+  input_method_filter_->SetInputMethodPropertyInRootWindow(root_window_.get());
   root_window_event_filter_->AddFilter(input_method_filter_.get());
 
   aura::DesktopActivationClient* activation_client =
",0,Aura desktop: Fix startup by setting the input method on the root window.
010ec6293409f10b88631c36145944b9c3277ce1,"@@ -219,7 +219,8 @@ typedef enum {
 
 typedef struct {
     PCIDevice dev;
-    uint8_t mult[8];            /* multicast mask array */
+    /* Hash register (multicast mask array, multiple individual addresses). */
+    uint8_t mult[8];
     int mmio_index;
     NICState *nic;
     NICConf conf;
@@ -599,7 +600,7 @@ static void nic_reset(void *opaque)
 {
     EEPRO100State *s = opaque;
     TRACE(OTHER, logout(""%p\n"", s));
-    /* TODO: Clearing of multicast table for selective reset, too? */
+    /* TODO: Clearing of hash register for selective reset, too? */
     memset(&s->mult[0], 0, sizeof(s->mult));
     nic_selective_reset(s);
 }
@@ -851,7 +852,14 @@ static void action_command(EEPRO100State *s)
         case CmdConfigure:
             cpu_physical_memory_read(s->cb_address + 8, &s->configuration[0],
                                      sizeof(s->configuration));
-            TRACE(OTHER, logout(""configuration: %s\n"", nic_dump(&s->configuration[0], 16)));
+            TRACE(OTHER, logout(""configuration: %s\n"",
+                                nic_dump(&s->configuration[0], 16)));
+            TRACE(OTHER, logout(""configuration: %s\n"",
+                                nic_dump(&s->configuration[16],
+                                ARRAY_SIZE(s->configuration) - 16)));
+            if (s->configuration[20] & BIT(6)) {
+                TRACE(OTHER, logout(""Multiple IA bit\n""));
+            }
             break;
         case CmdMulticastList:
             set_multicast_list(s);
@@ -1647,12 +1655,6 @@ static ssize_t nic_receive(VLANClientState *nc, const uint8_t * buf, size_t size
     static const uint8_t broadcast_macaddr[6] =
         { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
 
-    /* TODO: check multiple IA bit. */
-    if (s->configuration[20] & BIT(6)) {
-        missing(""Multiple IA bit"");
-        return -1;
-    }
-
     if (s->configuration[8] & 0x80) {
         /* CSMA is disabled. */
         logout(""%p received while CSMA is disabled\n"", s);
@@ -1702,6 +1704,16 @@ static ssize_t nic_receive(VLANClientState *nc, const uint8_t * buf, size_t size
         /* Promiscuous: receive all. */
         TRACE(RXTX, logout(""%p received frame in promiscuous mode, len=%zu\n"", s, size));
         rfd_status |= 0x0004;
+    } else if (s->configuration[20] & BIT(6)) {
+        /* Multiple IA bit set. */
+        unsigned mcast_idx = compute_mcast_idx(buf);
+        assert(mcast_idx < 64);
+        if (s->mult[mcast_idx >> 3] & (1 << (mcast_idx & 7))) {
+            TRACE(RXTX, logout(""%p accepted, multiple IA bit set\n"", s));
+        } else {
+            TRACE(RXTX, logout(""%p frame ignored, multiple IA bit set\n"", s));
+            return -1;
+        }
     } else {
         TRACE(RXTX, logout(""%p received frame, ignored, len=%zu,%s\n"", s, size,
               nic_dump(buf, size)));
",0,eepro100: Add support for multiple individual addresses (multiple IA)
0114c571d4c8cc1036850ced924683709390681a,"@@ -1354,7 +1354,9 @@ void ff_MPV_frame_end(MpegEncContext *s)
               s->unrestricted_mv &&
               s->current_picture.f.reference &&
               !s->intra_only &&
-              !(s->flags & CODEC_FLAG_EMU_EDGE)) {
+              !(s->flags & CODEC_FLAG_EMU_EDGE) &&
+              !s->avctx->lowres
+            ) {
         int hshift = av_pix_fmt_descriptors[s->avctx->pix_fmt].log2_chroma_w;
         int vshift = av_pix_fmt_descriptors[s->avctx->pix_fmt].log2_chroma_h;
         s->dsp.draw_edges(s->current_picture.f.data[0], s->current_picture.f.linesize[0],
",0,mpegvideo: dont call draw edges on lowres
0123c486367ab77c3c5ed349616a862eb474a03f,"@@ -617,7 +617,7 @@ static void do_ext_interrupt(CPUS390XState *env)
 
 static void do_io_interrupt(CPUS390XState *env)
 {
-    uint64_t mask, addr;
+    uint64_t mask = 0, addr = 0;
     LowCore *lowcore;
     IOIntQueue *q;
     uint8_t isc;
",0,s390x: silence warning from GCC on uninitialized values
014058abeaa9da2c107a6348178431ea8c9b0bab,"@@ -179,6 +179,9 @@ static int filter_samples(AVFilterLink *inlink, AVFilterBufferRef *insamplesref)
     AVFilterBufferRef *outsamplesref = ff_get_audio_buffer(outlink, AV_PERM_WRITE, n_out);
     int ret;
 
+    if(!outsamplesref)
+        return AVERROR(ENOMEM);
+
     avfilter_copy_buffer_ref_props(outsamplesref, insamplesref);
     outsamplesref->format                = outlink->format;
     outsamplesref->audio->channel_layout = outlink->channel_layout;
",0,af_aresample: check ff_get_audio_buffer() failure
0142f88bff3dd5cb819c9900da1c1e0a4aae9c44,"@@ -126,6 +126,8 @@ static void ide_test_start(const char *cmdline_fmt, ...)
 
 static void ide_test_quit(void)
 {
+    pc_alloc_uninit(guest_malloc);
+    guest_malloc = NULL;
     qtest_end();
 }
 
",0,qtest/ide: Uninitialize PC allocator
0143fc5e9f6f5aad4764801015bc8d4b4a278200,"@@ -1279,6 +1279,7 @@ static int udf_encode_fh(struct inode *inode, __u32 *fh, int *lenp,
 	*lenp = 3;
 	fid->udf.block = location.logicalBlockNum;
 	fid->udf.partref = location.partitionReferenceNum;
+	fid->udf.parent_partref = 0;
 	fid->udf.generation = inode->i_generation;
 
 	if (parent) {
",0,udf: avoid info leak on export
014628a705bdaf31c09915c29e61f4088956564d,"@@ -130,7 +130,7 @@ void fork_end(int child)
            Discard information about the parent threads.  */
         CPU_FOREACH_SAFE(cpu, next_cpu) {
             if (cpu != thread_cpu) {
-                QTAILQ_REMOVE(&cpus, thread_cpu, node);
+                QTAILQ_REMOVE(&cpus, cpu, node);
             }
         }
         pending_cpus = 0;
",0,"linux-user: In fork_end(), remove correct CPUs from CPU list"
014b01706cc64dc9c2ad94a96f62e07c058d0b5d,"@@ -39,8 +39,6 @@
 #include ""sysdeps/mutex.h""
 #include ""transport.h""
 
-static void local_socket_close(asocket* s);
-
 static std::recursive_mutex& local_socket_list_lock = *new std::recursive_mutex();
 static unsigned local_socket_next_id = 1;
 
@@ -118,7 +116,7 @@ void close_all_sockets(atransport* t) {
 restart:
     for (s = local_socket_list.next; s != &local_socket_list; s = s->next) {
         if (s->transport == t || (s->peer && s->peer->transport == t)) {
-            local_socket_close(s);
+            s->close(s);
             goto restart;
         }
     }
",0,adb: use asocket's close function when closing.
014b178f84fd6c5766e6a626a83f15a0dc635c90,"@@ -226,8 +226,10 @@ static int unpack_bitstream(G723_1_Context *p, const uint8_t *buf,
 /**
  * Bitexact implementation of sqrt(val/2).
  */
-static int16_t square_root(int val)
+static int16_t square_root(unsigned val)
 {
+    av_assert2(!(val & 0x80000000));
+
     return (ff_sqrt(val << 1) >> 1) & (~1);
 }
 
",0,g723_1: fix overflow in square_root()
016d2e1dfa21b64a524d3629fdd317d4c25bc3b8,"@@ -2889,10 +2889,9 @@ static inline void setup_sigcontext(CPUMIPSState *regs,
     }
 }
 
-static inline int
+static inline void
 restore_sigcontext(CPUMIPSState *regs, struct target_sigcontext *sc)
 {
-    int err = 0;
     int i;
 
     __get_user(regs->CP0_EPC, &sc->sc_pc);
@@ -2919,8 +2918,6 @@ restore_sigcontext(CPUMIPSState *regs, struct target_sigcontext *sc)
     for (i = 0; i < 32; ++i) {
         __get_user(regs->active_fpu.fpr[i].d, &sc->sc_fpregs[i]);
     }
-
-    return err;
 }
 
 /*
@@ -3031,8 +3028,7 @@ long do_sigreturn(CPUMIPSState *regs)
     target_to_host_sigset_internal(&blocked, &target_set);
     do_sigprocmask(SIG_SETMASK, &blocked, NULL);
 
-    if (restore_sigcontext(regs, &frame->sf_sc))
-   	goto badframe;
+    restore_sigcontext(regs, &frame->sf_sc);
 
 #if 0
     /*
@@ -3135,8 +3131,7 @@ long do_rt_sigreturn(CPUMIPSState *env)
     target_to_host_sigset(&blocked, &frame->rs_uc.tuc_sigmask);
     do_sigprocmask(SIG_SETMASK, &blocked, NULL);
 
-    if (restore_sigcontext(env, &frame->rs_uc.tuc_mcontext))
-        goto badframe;
+    restore_sigcontext(env, &frame->rs_uc.tuc_mcontext);
 
     if (do_sigaltstack(frame_addr +
 		       offsetof(struct target_rt_sigframe, rs_uc.tuc_stack),
@@ -3249,10 +3244,9 @@ static void setup_sigcontext(struct target_sigcontext *sc,
     __put_user(mask, &sc->oldmask);
 }
 
-static int restore_sigcontext(CPUSH4State *regs, struct target_sigcontext *sc,
+static void restore_sigcontext(CPUSH4State *regs, struct target_sigcontext *sc,
                               target_ulong *r0_p)
 {
-    unsigned int err = 0;
     int i;
 
 #define COPY(x)         __get_user(regs->x, &sc->sc_##x)
@@ -3277,7 +3271,6 @@ static int restore_sigcontext(CPUSH4State *regs, struct target_sigcontext *sc,
 
     regs->tra = -1;         /* disable syscall checks */
     __get_user(*r0_p, &sc->sc_gregs[0]);
-    return err;
 }
 
 static void setup_frame(int sig, struct target_sigaction *ka,
@@ -3422,8 +3415,7 @@ long do_sigreturn(CPUSH4State *regs)
     target_to_host_sigset_internal(&blocked, &target_set);
     do_sigprocmask(SIG_SETMASK, &blocked, NULL);
 
-    if (restore_sigcontext(regs, &frame->sc, &r0))
-        goto badframe;
+    restore_sigcontext(regs, &frame->sc, &r0);
 
     unlock_user_struct(frame, frame_addr, 0);
     return r0;
@@ -3451,8 +3443,7 @@ long do_rt_sigreturn(CPUSH4State *regs)
     target_to_host_sigset(&blocked, &frame->uc.tuc_sigmask);
     do_sigprocmask(SIG_SETMASK, &blocked, NULL);
 
-    if (restore_sigcontext(regs, &frame->uc.tuc_mcontext, &r0))
-        goto badframe;
+    restore_sigcontext(regs, &frame->uc.tuc_mcontext, &r0);
 
     if (do_sigaltstack(frame_addr +
 		       offsetof(struct target_rt_sigframe, uc.tuc_stack),
@@ -5086,10 +5077,9 @@ static void setup_sigcontext(struct target_sigcontext *sc, CPUM68KState *env,
     __put_user(env->pc, &sc->sc_pc);
 }
 
-static int
+static void
 restore_sigcontext(CPUM68KState *env, struct target_sigcontext *sc, int *pd0)
 {
-    int err = 0;
     int temp;
 
     __get_user(env->aregs[7], &sc->sc_usp);
@@ -5101,8 +5091,6 @@ restore_sigcontext(CPUM68KState *env, struct target_sigcontext *sc, int *pd0)
     env->sr = (env->sr & 0xff00) | (temp & 0xff);
 
     *pd0 = tswapl(sc->sc_d0);
-
-    return err;
 }
 
 /*
@@ -5342,8 +5330,7 @@ long do_sigreturn(CPUM68KState *env)
 
     /* restore registers */
 
-    if (restore_sigcontext(env, &frame->sc, &d0))
-        goto badframe;
+    restore_sigcontext(env, &frame->sc, &d0);
 
     unlock_user_struct(frame, frame_addr, 0);
     return d0;
@@ -5461,11 +5448,11 @@ static void setup_sigcontext(struct target_sigcontext *sc, CPUAlphaState *env,
     __put_user(0, &sc->sc_traparg_a2); /* FIXME */
 }
 
-static int restore_sigcontext(CPUAlphaState *env,
+static void restore_sigcontext(CPUAlphaState *env,
                               struct target_sigcontext *sc)
 {
     uint64_t fpcr;
-    int i, err = 0;
+    int i;
 
     __get_user(env->pc, &sc->sc_pc);
 
@@ -5478,8 +5465,6 @@ static int restore_sigcontext(CPUAlphaState *env,
 
     __get_user(fpcr, &sc->sc_fpcr);
     cpu_alpha_store_fpcr(env, fpcr);
-
-    return err;
 }
 
 static inline abi_ulong get_sigframe(struct target_sigaction *sa,
@@ -5613,9 +5598,7 @@ long do_sigreturn(CPUAlphaState *env)
     target_to_host_sigset_internal(&set, &target_set);
     do_sigprocmask(SIG_SETMASK, &set, NULL);
 
-    if (restore_sigcontext(env, sc)) {
-        goto badframe;
-    }
+    restore_sigcontext(env, sc);
     unlock_user_struct(sc, sc_addr, 0);
     return env->ir[IR_V0];
 
@@ -5636,9 +5619,7 @@ long do_rt_sigreturn(CPUAlphaState *env)
     target_to_host_sigset(&set, &frame->uc.tuc_sigmask);
     do_sigprocmask(SIG_SETMASK, &set, NULL);
 
-    if (restore_sigcontext(env, &frame->uc.tuc_mcontext)) {
-        goto badframe;
-    }
+    restore_sigcontext(env, &frame->uc.tuc_mcontext);
     if (do_sigaltstack(frame_addr + offsetof(struct target_rt_sigframe,
                                              uc.tuc_stack),
                        0, env->ir[IR_SP]) == -EFAULT) {
",0,signal/all: remove return value from restore_sigcontext
016f5cf6ff465411733878a17c8f8febb7668321,"@@ -50,6 +50,8 @@ static BlockDriverAIOCB *bdrv_aio_writev_em(BlockDriverState *bs,
         BlockDriverCompletionFunc *cb, void *opaque);
 static BlockDriverAIOCB *bdrv_aio_flush_em(BlockDriverState *bs,
         BlockDriverCompletionFunc *cb, void *opaque);
+static BlockDriverAIOCB *bdrv_aio_noop_em(BlockDriverState *bs,
+        BlockDriverCompletionFunc *cb, void *opaque);
 static int bdrv_read_em(BlockDriverState *bs, int64_t sector_num,
                         uint8_t *buf, int nb_sectors);
 static int bdrv_write_em(BlockDriverState *bs, int64_t sector_num,
@@ -1312,6 +1314,10 @@ const char *bdrv_get_device_name(BlockDriverState *bs)
 
 void bdrv_flush(BlockDriverState *bs)
 {
+    if (bs->open_flags & BDRV_O_NO_FLUSH) {
+        return;
+    }
+
     if (bs->drv && bs->drv->bdrv_flush)
         bs->drv->bdrv_flush(bs);
 }
@@ -2099,6 +2105,10 @@ BlockDriverAIOCB *bdrv_aio_flush(BlockDriverState *bs,
 {
     BlockDriver *drv = bs->drv;
 
+    if (bs->open_flags & BDRV_O_NO_FLUSH) {
+        return bdrv_aio_noop_em(bs, cb, opaque);
+    }
+
     if (!drv)
         return NULL;
     return drv->bdrv_aio_flush(bs, cb, opaque);
@@ -2214,6 +2224,25 @@ static BlockDriverAIOCB *bdrv_aio_flush_em(BlockDriverState *bs,
     return &acb->common;
 }
 
+static BlockDriverAIOCB *bdrv_aio_noop_em(BlockDriverState *bs,
+        BlockDriverCompletionFunc *cb, void *opaque)
+{
+    BlockDriverAIOCBSync *acb;
+
+    acb = qemu_aio_get(&bdrv_em_aio_pool, bs, cb, opaque);
+    acb->is_write = 1; /* don't bounce in the completion handler */
+    acb->qiov = NULL;
+    acb->bounce = NULL;
+    acb->ret = 0;
+
+    if (!acb->bh) {
+        acb->bh = qemu_bh_new(bdrv_aio_bh_cb, acb);
+    }
+
+    qemu_bh_schedule(acb->bh);
+    return &acb->common;
+}
+
 /**************************************************************/
 /* sync block device emulation */
 

@@ -913,6 +913,9 @@ DriveInfo *drive_init(QemuOpts *opts, void *opaque,
             bdrv_flags |= BDRV_O_NOCACHE;
         } else if (!strcmp(buf, ""writeback"")) {
             bdrv_flags |= BDRV_O_CACHE_WB;
+        } else if (!strcmp(buf, ""unsafe"")) {
+            bdrv_flags |= BDRV_O_CACHE_WB;
+            bdrv_flags |= BDRV_O_NO_FLUSH;
         } else if (!strcmp(buf, ""writethrough"")) {
             /* this is the default */
         } else {
",0,Add cache=unsafe parameter to -drive
0185604c2d82c560dab2f2933a18f797e74ab5a8,"@@ -3572,9 +3572,11 @@ static int kvm_vm_ioctl_get_pit(struct kvm *kvm, struct kvm_pit_state *ps)
 
 static int kvm_vm_ioctl_set_pit(struct kvm *kvm, struct kvm_pit_state *ps)
 {
+	int i;
 	mutex_lock(&kvm->arch.vpit->pit_state.lock);
 	memcpy(&kvm->arch.vpit->pit_state, ps, sizeof(struct kvm_pit_state));
-	kvm_pit_load_count(kvm, 0, ps->channels[0].count, 0);
+	for (i = 0; i < 3; i++)
+		kvm_pit_load_count(kvm, i, ps->channels[i].count, 0);
 	mutex_unlock(&kvm->arch.vpit->pit_state.lock);
 	return 0;
 }
@@ -3593,6 +3595,7 @@ static int kvm_vm_ioctl_get_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps)
 static int kvm_vm_ioctl_set_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps)
 {
 	int start = 0;
+	int i;
 	u32 prev_legacy, cur_legacy;
 	mutex_lock(&kvm->arch.vpit->pit_state.lock);
 	prev_legacy = kvm->arch.vpit->pit_state.flags & KVM_PIT_FLAGS_HPET_LEGACY;
@@ -3602,7 +3605,8 @@ static int kvm_vm_ioctl_set_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps)
 	memcpy(&kvm->arch.vpit->pit_state.channels, &ps->channels,
 	       sizeof(kvm->arch.vpit->pit_state.channels));
 	kvm->arch.vpit->pit_state.flags = ps->flags;
-	kvm_pit_load_count(kvm, 0, kvm->arch.vpit->pit_state.channels[0].count, start);
+	for (i = 0; i < 3; i++)
+		kvm_pit_load_count(kvm, i, kvm->arch.vpit->pit_state.channels[i].count, start);
 	mutex_unlock(&kvm->arch.vpit->pit_state.lock);
 	return 0;
 }
",0,KVM: x86: Reload pit counters for all channels when restoring state
0188fadb7fe460d8c4c743372b1f7b25773e183e,"@@ -971,7 +971,7 @@ static void setup_rt_frame(int sig, struct target_sigaction *ka,
 {
         abi_ulong frame_addr, addr;
 	struct rt_sigframe *frame;
-	int i, err = 0;
+	int i;
 
 	frame_addr = get_sigframe(ka, env, sizeof(*frame));
 
@@ -996,10 +996,9 @@ static void setup_rt_frame(int sig, struct target_sigaction *ka,
     setup_sigcontext(&frame->uc.tuc_mcontext, &frame->fpstate, env,
             set->sig[0], frame_addr + offsetof(struct rt_sigframe, fpstate));
 
-        for(i = 0; i < TARGET_NSIG_WORDS; i++) {
-            if (__put_user(set->sig[i], &frame->uc.tuc_sigmask.sig[i]))
-                goto give_sigsegv;
-        }
+    for(i = 0; i < TARGET_NSIG_WORDS; i++) {
+        __put_user(set->sig[i], &frame->uc.tuc_sigmask.sig[i]);
+    }
 
 	/* Set up to return from userspace.  If provided, use a stub
 	   already in userspace.  */
@@ -1016,9 +1015,6 @@ static void setup_rt_frame(int sig, struct target_sigaction *ka,
         __put_user(val16, (uint16_t *)(frame->retcode+5));
 	}
 
-	if (err)
-		goto give_sigsegv;
-
 	/* Set up registers for signal handler */
 	env->regs[R_ESP] = frame_addr;
 	env->eip = ka->_sa_handler;
@@ -1034,7 +1030,6 @@ static void setup_rt_frame(int sig, struct target_sigaction *ka,
 	return;
 
 give_sigsegv:
-	unlock_user_struct(frame, frame_addr, 1);
 	if (sig == TARGET_SIGSEGV)
 		ka->_sa_handler = TARGET_SIG_DFL;
 	force_sig(TARGET_SIGSEGV /* , current */);
@@ -1597,7 +1592,7 @@ get_sigframe(struct target_sigaction *ka, CPUARMState *regs, int framesize)
 	return (sp - framesize) & ~7;
 }
 
-static int
+static void
 setup_return(CPUARMState *env, struct target_sigaction *ka,
 	     abi_ulong *rc, abi_ulong frame_addr, int usig, abi_ulong rc_addr)
 {
@@ -1621,8 +1616,7 @@ setup_return(CPUARMState *env, struct target_sigaction *ka,
 		if (ka->sa_flags & TARGET_SA_SIGINFO)
 			idx += 2;
 
-		if (__put_user(retcodes[idx], rc))
-			return 1;
+        __put_user(retcodes[idx], rc);
 
 		retcode = rc_addr + thumb;
 	}
@@ -1632,8 +1626,6 @@ setup_return(CPUARMState *env, struct target_sigaction *ka,
 	env->regs[14] = retcode;
 	env->regs[15] = handler & (thumb ? ~1 : ~3);
 	cpsr_write(env, cpsr, 0xffffffff);
-
-	return 0;
 }
 
 static abi_ulong *setup_sigframe_v2_vfp(abi_ulong *regspace, CPUARMState *env)
@@ -1720,15 +1712,13 @@ static void setup_frame_v1(int usig, struct target_sigaction *ka,
 
 	setup_sigcontext(&frame->sc, regs, set->sig[0]);
 
-        for(i = 1; i < TARGET_NSIG_WORDS; i++) {
-            if (__put_user(set->sig[i], &frame->extramask[i - 1]))
-                goto end;
-	}
+    for(i = 1; i < TARGET_NSIG_WORDS; i++) {
+        __put_user(set->sig[i], &frame->extramask[i - 1]);
+    }
 
         setup_return(regs, ka, &frame->retcode, frame_addr, usig,
                      frame_addr + offsetof(struct sigframe_v1, retcode));
 
-end:
 	unlock_user_struct(frame, frame_addr, 1);
 }
 
@@ -1790,8 +1780,7 @@ static void setup_rt_frame_v1(int usig, struct target_sigaction *ka,
 
 	setup_sigcontext(&frame->uc.tuc_mcontext, env, set->sig[0]);
         for(i = 0; i < TARGET_NSIG_WORDS; i++) {
-            if (__put_user(set->sig[i], &frame->uc.tuc_sigmask.sig[i]))
-                goto end;
+            __put_user(set->sig[i], &frame->uc.tuc_sigmask.sig[i]);
         }
 
         setup_return(env, ka, &frame->retcode, frame_addr, usig,
@@ -1800,7 +1789,6 @@ static void setup_rt_frame_v1(int usig, struct target_sigaction *ka,
         env->regs[1] = info_addr;
         env->regs[2] = uc_addr;
 
-end:
 	unlock_user_struct(frame, frame_addr, 1);
 }
 
@@ -2932,8 +2920,7 @@ static void setup_frame(int sig, struct target_sigaction * ka,
     setup_sigcontext(regs, &frame->sf_sc);
 
     for(i = 0; i < TARGET_NSIG_WORDS; i++) {
-	if(__put_user(set->sig[i], &frame->sf_mask.sig[i]))
-	    goto give_sigsegv;
+        __put_user(set->sig[i], &frame->sf_mask.sig[i]);
     }
 
     /*
@@ -2960,7 +2947,6 @@ static void setup_frame(int sig, struct target_sigaction * ka,
     return;
 
 give_sigsegv:
-    unlock_user_struct(frame, frame_addr, 1);
     force_sig(TARGET_SIGSEGV/*, current*/);
 }
 
@@ -3540,7 +3526,6 @@ static void setup_frame(int sig, struct target_sigaction *ka,
 {
     struct target_signal_frame *frame;
     abi_ulong frame_addr;
-    int err = 0;
     int i;
 
     frame_addr = get_sigframe(ka, env, sizeof *frame);
@@ -3549,12 +3534,9 @@ static void setup_frame(int sig, struct target_sigaction *ka,
 
     /* Save the mask.  */
     __put_user(set->sig[0], &frame->uc.tuc_mcontext.oldmask);
-    if (err)
-        goto badframe;
 
     for(i = 1; i < TARGET_NSIG_WORDS; i++) {
-        if (__put_user(set->sig[i], &frame->extramask[i - 1]))
-            goto badframe;
+        __put_user(set->sig[i], &frame->extramask[i - 1]);
     }
 
     setup_sigcontext(&frame->uc.tuc_mcontext, env);
@@ -3579,9 +3561,6 @@ static void setup_frame(int sig, struct target_sigaction *ka,
         env->regs[15] = ((unsigned long)frame->tramp) - 8;
     }
 
-    if (err)
-        goto badframe;
-
     /* Set up registers for signal handler */
     env->regs[1] = frame_addr;
     /* Signal handler args: */
@@ -3596,7 +3575,6 @@ static void setup_frame(int sig, struct target_sigaction *ka,
     unlock_user_struct(frame, frame_addr, 1);
     return;
   badframe:
-    unlock_user_struct(frame, frame_addr, 1);
     force_sig(TARGET_SIGSEGV);
 }
 
@@ -3727,7 +3705,6 @@ static void setup_frame(int sig, struct target_sigaction *ka,
 {
 	struct target_signal_frame *frame;
 	abi_ulong frame_addr;
-	int err = 0;
 	int i;
 
 	frame_addr = get_sigframe(env, sizeof *frame);
@@ -3748,13 +3725,10 @@ static void setup_frame(int sig, struct target_sigaction *ka,
 
 	/* Save the mask.  */
     __put_user(set->sig[0], &frame->sc.oldmask);
-	if (err)
-		goto badframe;
 
-	for(i = 1; i < TARGET_NSIG_WORDS; i++) {
-		if (__put_user(set->sig[i], &frame->extramask[i - 1]))
-			goto badframe;
-	}
+    for(i = 1; i < TARGET_NSIG_WORDS; i++) {
+        __put_user(set->sig[i], &frame->extramask[i - 1]);
+    }
 
 	setup_sigcontext(&frame->sc, env);
 
@@ -3768,7 +3742,6 @@ static void setup_frame(int sig, struct target_sigaction *ka,
 	unlock_user_struct(frame, frame_addr, 1);
 	return;
   badframe:
-	unlock_user_struct(frame, frame_addr, 1);
 	force_sig(TARGET_SIGSEGV);
 }
 
@@ -4157,9 +4130,7 @@ static void setup_frame(int sig, struct target_sigaction *ka,
     }
 
     qemu_log(""%s: 1\n"", __FUNCTION__);
-    if (__put_user(set->sig[0], &frame->sc.oldmask[0])) {
-              goto give_sigsegv;
-    }
+    __put_user(set->sig[0], &frame->sc.oldmask[0]);
 
     save_sigregs(env, &frame->sregs);
 
@@ -4174,15 +4145,12 @@ static void setup_frame(int sig, struct target_sigaction *ka,
     } else {
             env->regs[14] = (unsigned long)
                     frame->retcode | PSW_ADDR_AMODE;
-            if (__put_user(S390_SYSCALL_OPCODE | TARGET_NR_sigreturn,
-                           (uint16_t *)(frame->retcode)))
-                    goto give_sigsegv;
+            __put_user(S390_SYSCALL_OPCODE | TARGET_NR_sigreturn,
+                       (uint16_t *)(frame->retcode));
     }
 
     /* Set up backchain. */
-    if (__put_user(env->regs[15], (abi_ulong *) frame)) {
-            goto give_sigsegv;
-    }
+    __put_user(env->regs[15], (abi_ulong *) frame);
 
     /* Set up registers for signal handler */
     env->regs[15] = frame_addr;
@@ -4197,15 +4165,12 @@ static void setup_frame(int sig, struct target_sigaction *ka,
     env->regs[5] = 0; // FIXME: no clue... current->thread.prot_addr;
 
     /* Place signal number on stack to allow backtrace from handler.  */
-    if (__put_user(env->regs[2], (int *) &frame->signo)) {
-            goto give_sigsegv;
-    }
+    __put_user(env->regs[2], (int *) &frame->signo);
     unlock_user_struct(frame, frame_addr, 1);
     return;
 
 give_sigsegv:
     qemu_log(""%s: give_sigsegv\n"", __FUNCTION__);
-    unlock_user_struct(frame, frame_addr, 1);
     force_sig(TARGET_SIGSEGV);
 }
 
@@ -4246,16 +4211,12 @@ static void setup_rt_frame(int sig, struct target_sigaction *ka,
         env->regs[14] = (unsigned long) ka->sa_restorer | PSW_ADDR_AMODE;
     } else {
         env->regs[14] = (unsigned long) frame->retcode | PSW_ADDR_AMODE;
-        if (__put_user(S390_SYSCALL_OPCODE | TARGET_NR_rt_sigreturn,
-                       (uint16_t *)(frame->retcode))) {
-            goto give_sigsegv;
-        }
+        __put_user(S390_SYSCALL_OPCODE | TARGET_NR_rt_sigreturn,
+                   (uint16_t *)(frame->retcode));
     }
 
     /* Set up backchain. */
-    if (__put_user(env->regs[15], (abi_ulong *) frame)) {
-        goto give_sigsegv;
-    }
+    __put_user(env->regs[15], (abi_ulong *) frame);
 
     /* Set up registers for signal handler */
     env->regs[15] = frame_addr;
@@ -4268,7 +4229,6 @@ static void setup_rt_frame(int sig, struct target_sigaction *ka,
 
 give_sigsegv:
     qemu_log(""%s: give_sigsegv\n"", __FUNCTION__);
-    unlock_user_struct(frame, frame_addr, 1);
     force_sig(TARGET_SIGSEGV);
 }
 
@@ -5066,7 +5026,6 @@ static void setup_frame(int sig, struct target_sigaction *ka,
     abi_ulong frame_addr;
     abi_ulong retcode_addr;
     abi_ulong sc_addr;
-    int err = 0;
     int i;
 
     frame_addr = get_sigframe(ka, env, sizeof *frame);
@@ -5081,8 +5040,7 @@ static void setup_frame(int sig, struct target_sigaction *ka,
     setup_sigcontext(&frame->sc, env, set->sig[0]);
 
     for(i = 1; i < TARGET_NSIG_WORDS; i++) {
-        if (__put_user(set->sig[i], &frame->extramask[i - 1]))
-            goto give_sigsegv;
+        __put_user(set->sig[i], &frame->extramask[i - 1]);
     }
 
     /* Set up to return from userspace.  */
@@ -5095,9 +5053,6 @@ static void setup_frame(int sig, struct target_sigaction *ka,
     __put_user(0x70004e40 + (TARGET_NR_sigreturn << 16),
                       (long *)(frame->retcode));
 
-    if (err)
-        goto give_sigsegv;
-
     /* Set up to return from userspace */
 
     env->aregs[7] = frame_addr;
@@ -5107,7 +5062,6 @@ static void setup_frame(int sig, struct target_sigaction *ka,
     return;
 
 give_sigsegv:
-    unlock_user_struct(frame, frame_addr, 1);
     force_sig(TARGET_SIGSEGV);
 }
 
@@ -5220,8 +5174,7 @@ static void setup_rt_frame(int sig, struct target_sigaction *ka,
             goto give_sigsegv;
 
     for(i = 0; i < TARGET_NSIG_WORDS; i++) {
-        if (__put_user(set->sig[i], &frame->uc.tuc_sigmask.sig[i]))
-            goto give_sigsegv;
+        __put_user(set->sig[i], &frame->uc.tuc_sigmask.sig[i]);
     }
 
     /* Set up to return from userspace.  */
",0,signal/all/setup_frame remove __put_user checks
01923bab98506b1e98b4cbf08419364ce6ffea6d,"@@ -381,7 +381,7 @@ FF_ENABLE_DEPRECATION_WARNINGS
 int av_packet_split_side_data(AVPacket *pkt){
     if (!pkt->side_data_elems && pkt->size >12 && AV_RB64(pkt->data + pkt->size - 8) == FF_MERGE_MARKER){
         int i;
-        unsigned int size, orig_pktsize = pkt->size;
+        unsigned int size;
         uint8_t *p;
 
         p = pkt->data + pkt->size - 8 - 5;
@@ -414,13 +414,6 @@ int av_packet_split_side_data(AVPacket *pkt){
             p-= size+5;
         }
         pkt->size -= 8;
-        /* FFMIN() prevents overflow in case the packet wasn't allocated with
-         * proper padding.
-         * If the side data is smaller than the buffer padding size, the
-         * remaining bytes should have already been filled with zeros by the
-         * original packet allocation anyway. */
-        memset(pkt->data + pkt->size, 0,
-               FFMIN(orig_pktsize - pkt->size, FF_INPUT_BUFFER_PADDING_SIZE));
         pkt->side_data_elems = i+1;
         return 1;
     }

@@ -2422,6 +2422,16 @@ int avcodec_decode_subtitle2(AVCodecContext *avctx, AVSubtitle *sub,
         int did_split = av_packet_split_side_data(&tmp);
         //apply_param_change(avctx, &tmp);
 
+        if (did_split) {
+            /* FFMIN() prevents overflow in case the packet wasn't allocated with
+             * proper padding.
+             * If the side data is smaller than the buffer padding size, the
+             * remaining bytes should have already been filled with zeros by the
+             * original packet allocation anyway. */
+            memset(tmp.data + tmp.size, 0,
+                   FFMIN(avpkt->size - tmp.size, FF_INPUT_BUFFER_PADDING_SIZE));
+        }
+
         pkt_recoded = tmp;
         ret = recode_subtitle(avctx, &pkt_recoded, &tmp);
         if (ret < 0) {
",0,avcodec: move end zeroing code from av_packet_split_side_data() to avcodec_decode_subtitle2()
019c2ab8623daee210df8b1085a33b1e83c9ee11,"@@ -226,12 +226,10 @@ static void test_cipher(const void *opaque)
     const QCryptoCipherTestData *data = opaque;
 
     QCryptoCipher *cipher;
-    Error *err = NULL;
     uint8_t *key, *iv, *ciphertext, *plaintext, *outtext;
     size_t nkey, niv, nciphertext, nplaintext;
     char *outtexthex;
 
-    g_test_message(""foo"");
     nkey = unhex_string(data->key, &key);
     niv = unhex_string(data->iv, &iv);
     nciphertext = unhex_string(data->ciphertext, &ciphertext);
@@ -244,28 +242,42 @@ static void test_cipher(const void *opaque)
     cipher = qcrypto_cipher_new(
         data->alg, data->mode,
         key, nkey,
-        &err);
+        &error_abort);
     g_assert(cipher != NULL);
-    g_assert(err == NULL);
 
 
     if (iv) {
         g_assert(qcrypto_cipher_setiv(cipher,
                                       iv, niv,
-                                      &err) == 0);
-        g_assert(err == NULL);
+                                      &error_abort) == 0);
     }
     g_assert(qcrypto_cipher_encrypt(cipher,
                                     plaintext,
                                     outtext,
                                     nplaintext,
-                                    &err) == 0);
-    g_assert(err == NULL);
+                                    &error_abort) == 0);
 
     outtexthex = hex_string(outtext, nciphertext);
 
     g_assert_cmpstr(outtexthex, ==, data->ciphertext);
 
+    g_free(outtexthex);
+
+    if (iv) {
+        g_assert(qcrypto_cipher_setiv(cipher,
+                                      iv, niv,
+                                      &error_abort) == 0);
+    }
+    g_assert(qcrypto_cipher_decrypt(cipher,
+                                    ciphertext,
+                                    outtext,
+                                    nplaintext,
+                                    &error_abort) == 0);
+
+    outtexthex = hex_string(outtext, nplaintext);
+
+    g_assert_cmpstr(outtexthex, ==, data->plaintext);
+
     g_free(outtext);
     g_free(outtexthex);
     g_free(key);
",0,crypto: extend unit tests to cover decryption too
019dd2365729d44d66a5b629102e1ecb919f4f67,"@@ -109,7 +109,7 @@ void av_get_channel_layout_string(char *buf, int buf_size,
         int i, ch;
         av_strlcat(buf, "" ("", buf_size);
         for (i = 0, ch = 0; i < 64; i++) {
-            if ((channel_layout & (1L << i))) {
+            if ((channel_layout & (UINT64_C(1) << i))) {
                 const char *name = get_channel_name(i);
                 if (name) {
                     if (ch > 0)
",0,Fix av_get_channel_layout_string() for positions >31
01a0283c92b124f185ce4e814a1c5b600f1135e0,"@@ -293,12 +293,14 @@ int ff_h264_decode_ref_pic_list_reordering(H264Context *h){
     }
     for(list=0; list<h->list_count; list++){
         for(index= 0; index < h->ref_count[list]; index++){
-            if (!h->ref_list[list][index].f.data[0]) {
+            if (   !h->ref_list[list][index].f.data[0]
+                || (!FIELD_PICTURE && (h->ref_list[list][index].reference&3) != 3)) {
                 int i;
                 av_log(h->avctx, AV_LOG_ERROR, ""Missing reference picture, default is %d\n"", h->default_ref_list[list][0].poc);
                 for (i=0; i<FF_ARRAY_ELEMS(h->last_pocs); i++)
                     h->last_pocs[i] = INT_MIN;
-                if (h->default_ref_list[list][0].f.data[0])
+                if (h->default_ref_list[list][0].f.data[0]
+                    && !(!FIELD_PICTURE && (h->default_ref_list[list][index].reference&3) != 3))
                     COPY_PICTURE(&h->ref_list[list][index], &h->default_ref_list[list][0]);
                 else
                     return -1;
",0,h264: disallow single unpaired fields as references of frames
01a33b835f7a9e135eb8c7b7dd98c8b89f15dea1,"@@ -57,7 +57,7 @@ static void picmemset_8bpp(PicContext *s, AVFrame *frame, int value, int run,
     }
 }
 
-static void picmemset(PicContext *s, AVFrame *frame, int value, int run,
+static void picmemset(PicContext *s, AVFrame *frame, unsigned value, int run,
                       int *x, int *y, int *plane, int bits_per_plane)
 {
     uint8_t *d;
",0,avcodec/pictordec: Fix runtime error: left shift of 64 by 25 places cannot be represented in type 'int'
01a720125f5e2f0a23d2682b39dead2fcc820066,"@@ -109,7 +109,8 @@ void helper_movcal(CPUSH4State *env, uint32_t address, uint32_t value)
 {
     if (cpu_sh4_is_cached (env, address))
     {
-	memory_content *r = malloc (sizeof(memory_content));
+        memory_content *r = g_new(memory_content, 1);
+
 	r->address = address;
 	r->value = value;
 	r->next = NULL;
@@ -126,7 +127,7 @@ void helper_discard_movcal_backup(CPUSH4State *env)
     while(current)
     {
 	memory_content *next = current->next;
-	free (current);
+        g_free(current);
 	env->movcal_backup = current = next;
 	if (current == NULL)
 	    env->movcal_backup_tail = &(env->movcal_backup);
@@ -149,7 +150,7 @@ void helper_ocbi(CPUSH4State *env, uint32_t address)
 		env->movcal_backup_tail = current;
 	    }
 
-	    free (*current);
+            g_free(*current);
 	    *current = next;
 	    break;
 	}
",0,target-sh4: Use glib allocator in movcal helper
01bd1ed2db53fa90a0512d65ad6c08170061dfdf,"@@ -112,6 +112,8 @@ static char *info_table[][2]={
 	{""Cover""		, ""PNG""},
 };
 
+void ff_parse_specific_params(AVCodecContext *stream, int *au_rate, int *au_ssize, int *au_scale);
+
 static void update(NUTContext *nut, int stream_index, int64_t frame_start, int frame_type, int frame_code, int key_frame, int size, int64_t pts){
     StreamContext *stream= &nut->stream[stream_index];
     
@@ -576,14 +578,20 @@ static int nut_write_header(AVFormatContext *s)
     /* stream headers */
     for (i = 0; i < s->nb_streams; i++)
     {
-	int nom, denom, gcd;
+	int nom, denom, ssize;
 
 	codec = &s->streams[i]->codec;
 	
 	put_be64(bc, STREAM_STARTCODE);
 	put_packetheader(nut, bc, 120 + codec->extradata_size, 1);
 	put_v(bc, i /*s->streams[i]->index*/);
-	put_v(bc, (codec->codec_type == CODEC_TYPE_AUDIO) ? 32 : 0);
+        switch(codec->codec_type){
+        case CODEC_TYPE_VIDEO: put_v(bc, 0); break;
+        case CODEC_TYPE_AUDIO: put_v(bc, 1); break;
+//        case CODEC_TYPE_TEXT : put_v(bc, 2); break;
+        case CODEC_TYPE_DATA : put_v(bc, 3); break;
+        default: return -1;
+        }
 	if (codec->codec_tag)
 	    put_vb(bc, codec->codec_tag);
 	else if (codec->codec_type == CODEC_TYPE_VIDEO)
@@ -596,23 +604,9 @@ static int nut_write_header(AVFormatContext *s)
 	}
         else
             put_vb(bc, 0);
+        
+        ff_parse_specific_params(codec, &nom, &ssize, &denom);
 
-	if (codec->codec_type == CODEC_TYPE_VIDEO)
-	{
-	    nom = codec->time_base.den;
-	    denom = codec->time_base.num;
-	}
-	else
-	{
-	    nom = codec->sample_rate;
-            if(codec->frame_size>0)
-                denom= codec->frame_size;
-            else
-                denom= 1; //unlucky
-	}
-        gcd= ff_gcd(nom, denom);
-        nom   /= gcd;
-        denom /= gcd;
         nut->stream[i].rate_num= nom;
         nut->stream[i].rate_den= denom;
         av_set_pts_info(s->streams[i], 60, denom, nom);
@@ -965,12 +959,19 @@ static int decode_stream_header(NUTContext *nut){
             if (st->codec.codec_id == CODEC_ID_NONE)
                 av_log(s, AV_LOG_ERROR, ""Unknown codec?!\n"");
             break;
-        case 32:
+        case 1:
+        case 32: //compatibility
             st->codec.codec_type = CODEC_TYPE_AUDIO;
             st->codec.codec_id = codec_get_wav_id(tmp);
             if (st->codec.codec_id == CODEC_ID_NONE)
                 av_log(s, AV_LOG_ERROR, ""Unknown codec?!\n"");
             break;
+        case 2:
+//            st->codec.codec_type = CODEC_TYPE_TEXT;
+//            break;
+        case 3:
+            st->codec.codec_type = CODEC_TYPE_DATA;
+            break;
         default:
             av_log(s, AV_LOG_ERROR, ""Unknown stream class (%d)\n"", class);
             return -1;
@@ -994,7 +995,7 @@ static int decode_stream_header(NUTContext *nut){
 //	    url_fskip(bc, get_v(bc));
     }
     
-    if (class == 0) /* VIDEO */
+    if (st->codec.codec_type == CODEC_TYPE_VIDEO) /* VIDEO */
     {
         st->codec.width = get_v(bc);
         st->codec.height = get_v(bc);
@@ -1002,7 +1003,7 @@ static int decode_stream_header(NUTContext *nut){
         st->codec.sample_aspect_ratio.den= get_v(bc);
         get_v(bc); /* csp type */
     }
-    if (class == 32) /* AUDIO */
+    if (st->codec.codec_type == CODEC_TYPE_AUDIO) /* AUDIO */
     {
         st->codec.sample_rate = get_v(bc);
         get_v(bc); // samplerate_den
@@ -1100,7 +1101,7 @@ static int nut_read_header(AVFormatContext *s, AVFormatParameters *ap)
     pos=0;
     for(inited_stream_count=0; inited_stream_count < nut->stream_count;){
         pos= find_startcode(bc, STREAM_STARTCODE, pos)+1;
-        if (pos<0){
+        if (pos<0+1){
             av_log(s, AV_LOG_ERROR, ""not all stream headers found\n"");
             return -1;
         }
",0,fix stream class
01c61f8ab110a77ae64b5ca67c244c728c506f03,"@@ -196,7 +196,6 @@ int read_image_tga( gdIOCtx *ctx, oTga *tga )
 	int buffer_caret = 0;
 	int bitmap_caret = 0;
 	int i = 0;
-	int j = 0;
 	uint8_t encoded_pixels;
 
 	if(overflow2(tga->width, tga->height)) {
@@ -280,43 +279,34 @@ int read_image_tga( gdIOCtx *ctx, oTga *tga )
 		while( bitmap_caret < image_block_size ) {
 			
 			if ((decompression_buffer[buffer_caret] & TGA_RLE_FLAG) == TGA_RLE_FLAG) {
-				encoded_pixels = ( ( decompression_buffer[ buffer_caret ] & 127 ) + 1 );
+				encoded_pixels = ( ( decompression_buffer[ buffer_caret ] & !TGA_RLE_FLAG ) + 1 );
 				buffer_caret++;
 
-				if (encoded_pixels != 0) {
-				
-					if (!((buffer_caret + (encoded_pixels * pixel_block_size)) < image_block_size)) {
-						gdFree( decompression_buffer );
-						gdFree( conversion_buffer );
-						return -1;
-					}
-
-					for (i = 0; i < encoded_pixels; i++) {
-						for (j = 0; j < pixel_block_size; j++, bitmap_caret++) {
-							tga->bitmap[ bitmap_caret ] = decompression_buffer[ buffer_caret + j ];
-						}
-					}
+				if ((bitmap_caret + (encoded_pixels * pixel_block_size)) >= image_block_size) {
+					gdFree( decompression_buffer );
+					gdFree( conversion_buffer );
+					return -1;
+				}
+
+				for (i = 0; i < encoded_pixels; i++) {
+					memcpy(tga->bitmap + bitmap_caret, decompression_buffer + buffer_caret, pixel_block_size);
+					bitmap_caret += pixel_block_size;
 				}
 				buffer_caret += pixel_block_size;
+
 			} else {
 				encoded_pixels = decompression_buffer[ buffer_caret ] + 1;
 				buffer_caret++;
 
-				if (encoded_pixels != 0) {
-				
-					if (!((buffer_caret + (encoded_pixels * pixel_block_size)) < image_block_size)) {
-						gdFree( decompression_buffer );
-						gdFree( conversion_buffer );
-						return -1;
-					}
-
-					for (i = 0; i < encoded_pixels; i++) {
-						for( j = 0; j < pixel_block_size; j++, bitmap_caret++ ) {
-							tga->bitmap[ bitmap_caret ] = decompression_buffer[ buffer_caret + j ];
-						}
-						buffer_caret += pixel_block_size;
-					}
+				if ((bitmap_caret + (encoded_pixels * pixel_block_size)) >= image_block_size) {
+					gdFree( decompression_buffer );
+					gdFree( conversion_buffer );
+					return -1;
 				}
+
+				memcpy(tga->bitmap + bitmap_caret, decompression_buffer + buffer_caret, encoded_pixels * pixel_block_size);
+				bitmap_caret += (encoded_pixels * pixel_block_size);
+				buffer_caret += (encoded_pixels * pixel_block_size);
 			}
 		}
 		gdFree( decompression_buffer );
",0,Proper fix for #248
01ca88bb6c5bdd44e071f8effebe12f1d7da9853,"@@ -669,14 +669,13 @@ UWORD32 ihevcd_cabac_decode_bypass_bins_egk(cab_ctxt_t *ps_cabac,
     numones = k;
     bin = 1;
     u4_sym = 0;
-    while(bin)
+    while(bin && (numones <= 16))
     {
         IHEVCD_CABAC_DECODE_BYPASS_BIN(bin, ps_cabac, ps_bitstrm);
         u4_sym += bin << numones++;
     }
 
     numones -= 1;
-    numones = CLIP3(numones, 0, 16);
 
     if(numones)
     {

@@ -82,6 +82,9 @@
 /* Bit stream offset threshold */
 #define BITSTRM_OFF_THRS 8
 
+#define MIN_CU_QP_DELTA_ABS(x) (-26 + ((x) * 6) / 2)
+#define MAX_CU_QP_DELTA_ABS(x) (25 + ((x) * 6) / 2)
+
 /**
  * Table used to decode part_mode if AMP is enabled and current CU is not min CU
  */
@@ -302,7 +305,6 @@ WORD32 ihevcd_parse_transform_tree(codec_t *ps_codec,
                     }
                     AEV_TRACE(""cu_qp_delta_abs"", cu_qp_delta_abs, ps_cabac->u4_range);
 
-
                     ps_codec->s_parse.i4_is_cu_qp_delta_coded = 1;
 
 
@@ -315,6 +317,13 @@ WORD32 ihevcd_parse_transform_tree(codec_t *ps_codec,
                             cu_qp_delta_abs = -cu_qp_delta_abs;
 
                     }
+
+                    if (cu_qp_delta_abs < MIN_CU_QP_DELTA_ABS(ps_sps->i1_bit_depth_luma_minus8)
+                                    || cu_qp_delta_abs > MAX_CU_QP_DELTA_ABS(ps_sps->i1_bit_depth_luma_minus8))
+                    {
+                        return IHEVCD_INVALID_PARAMETER;
+                    }
+
                     ps_codec->s_parse.s_cu.i4_cu_qp_delta = cu_qp_delta_abs;
 
                 }
",0,Fix in handling wrong cu_qp_delta
01d196a67dc55eb01cf3e06d6338c5d096a29b1c,"@@ -80,7 +80,7 @@ static void picmemset(PicContext *s, AVFrame *frame, int value, int run,
                    value <<= bits_per_plane;
                    mask  <<= bits_per_plane;
                    if (*plane >= s->nb_planes)
-                       break;
+                       return;
                 }
             }
         }
@@ -236,7 +236,7 @@ static int decode_frame(AVCodecContext *avctx,
             }
         }
 
-        if (x < avctx->width) {
+        if (plane < s->nb_planes && x < avctx->width) {
             int run = (y + 1) * avctx->width - x;
             if (bits_per_plane == 8)
                 picmemset_8bpp(s, frame, val, run, &x, &y);
",0,avcodec/pictordec: Do not read more than nb_planes
01dbbd0a9af53237cf7aac210370892208bfb957,"@@ -180,13 +180,13 @@ int MPV_common_init(MpegEncContext *s)
         s->coded_block = av_mallocz(y_size);
         if (!s->coded_block)
             goto fail;
+    }
 
         /* which mb is a intra block */
-        s->mbintra_table = av_mallocz(y_size/4);
+        s->mbintra_table = av_mallocz(s->mb_width * s->mb_height);
         if (!s->mbintra_table)
             goto fail;
-        memset(s->mbintra_table, 1, y_size/4);
-    }
+        memset(s->mbintra_table, 1, s->mb_width * s->mb_height);
     /* default structure is frame */
     s->picture_structure = PICT_FRAME;
 
@@ -209,7 +209,7 @@ int MPV_common_init(MpegEncContext *s)
     if (s->coded_block)
         free(s->coded_block);
     if (s->mbintra_table)
-        free(s->mbintra_table);
+        { free(s->mbintra_table);s->mbintra_table=NULL; }
     if (s->mbskip_table)
         free(s->mbskip_table);
     for(i=0;i<3;i++) {
@@ -234,7 +234,7 @@ void MPV_common_end(MpegEncContext *s)
         free(s->dc_val[0]);
         free(s->ac_val[0]);
         free(s->coded_block);
-        free(s->mbintra_table);
+        { free(s->mbintra_table);s->mbintra_table=NULL; }
     }
     if (s->mbskip_table)
         free(s->mbskip_table);
",0,This fixes segfaults because of uninitialized s->mbintra_table variable - patch by Vladimir Dergachev <volodya@mindspring.com>
01dd7e025c246d9001f1a30f4a5d8fa2936d1a5e,"@@ -444,14 +444,17 @@ int ff_img_read_packet(AVFormatContext *s1, AVPacket *pkt)
     }
 
     res = av_new_packet(pkt, size[0] + size[1] + size[2]);
-    if (res < 0)
-        return res;
+    if (res < 0) {
+        goto fail;
+    }
     pkt->stream_index = 0;
     pkt->flags       |= AV_PKT_FLAG_KEY;
     if (s->ts_from_file) {
         struct stat img_stat;
-        if (stat(filename, &img_stat))
-            return AVERROR(EIO);
+        if (stat(filename, &img_stat)) {
+            res = AVERROR(EIO);
+            goto fail;
+        }
         pkt->pts = (int64_t)img_stat.st_mtime;
 #if HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC
         if (s->ts_from_file == 2)
@@ -485,18 +488,29 @@ int ff_img_read_packet(AVFormatContext *s1, AVPacket *pkt)
     if (ret[0] <= 0 || ret[1] < 0 || ret[2] < 0) {
         av_free_packet(pkt);
         if (ret[0] < 0) {
-            return ret[0];
+            res = ret[0];
         } else if (ret[1] < 0) {
-            return ret[1];
-        } else if (ret[2] < 0)
-            return ret[2];
-        return AVERROR_EOF;
+            res = ret[1];
+        } else if (ret[2] < 0) {
+            res = ret[2];
+        } else {
+            res = AVERROR_EOF;
+        }
+        goto fail;
     } else {
         s->img_count++;
         s->img_number++;
         s->pts++;
         return 0;
     }
+
+fail:
+    if (!s->is_pipe) {
+        for (i = 0; i < 3; i++) {
+            avio_closep(&f[i]);
+        }
+    }
+    return res;
 }
 
 static int img_read_close(struct AVFormatContext* s1)
",0,lavf/img2dec: Fix memory leak
01e4ee2fda0a5e57a8d0c8cb829022eb84fdff12,"@@ -597,11 +597,12 @@ static PassRefPtr<CSSValue> getPositionOffsetValue(RenderStyle* style, CSSProper
         return cssValuePool().createValue(l);
     }
 
-    if (style->position() == RelativePosition)
+    if (style->position() == RelativePosition) {
         // FIXME: It's not enough to simply return ""auto"" values for one offset if the other side is defined.
         // In other words if left is auto and right is not auto, then left's computed value is negative right().
         // So we should get the opposite length unit and see if it is auto.
         return cssValuePool().createValue(l);
+    }
 
     return cssValuePool().createIdentifierValue(CSSValueAuto);
 }

@@ -2076,7 +2076,7 @@ static bool doesNotInheritTextDecoration(RenderStyle* style, Element* e)
 {
     return style->display() == TABLE || style->display() == INLINE_TABLE || style->display() == RUN_IN
         || style->display() == INLINE_BLOCK || style->display() == INLINE_BOX || isAtShadowBoundary(e)
-        || style->isFloating() || style->isPositioned();
+        || style->isFloating() || style->isOutOfFlowPositioned();
 }
 
 void StyleResolver::adjustRenderStyle(RenderStyle* style, RenderStyle* parentStyle, Element *e)

@@ -218,7 +218,7 @@ bool Text::rendererIsNeeded(const NodeRenderingContext& context)
             return false;
         
         RenderObject* first = parent->firstChild();
-        while (first && first->isFloatingOrPositioned())
+        while (first && first->isFloatingOrOutOfFlowPositioned())
             first = first->nextSibling();
         RenderObject* next = context.nextRenderer();
         if (!first || next == first)

@@ -105,7 +105,7 @@ static bool isDeletableElement(const Node* node)
     if (node->hasTagName(ulTag) || node->hasTagName(olTag) || node->hasTagName(iframeTag))
         return true;
 
-    if (renderer->isPositioned())
+    if (renderer->isOutOfFlowPositioned())
         return true;
 
     if (renderer->isRenderBlock() && !renderer->isTableCell()) {

@@ -775,7 +775,7 @@ static bool shouldEmitNewlinesBeforeAndAfterNode(Node* node)
             return true;
     }
     
-    return !r->isInline() && r->isRenderBlock() && !r->isFloatingOrPositioned() && !r->isBody();
+    return !r->isInline() && r->isRenderBlock() && !r->isFloatingOrOutOfFlowPositioned() && !r->isBody();
 }
 
 static bool shouldEmitNewlineAfterNode(Node* node)

@@ -186,10 +186,10 @@ static bool shouldScaleColumns(RenderTable* table)
     bool scale = true;
     while (table) {
         Length tw = table->style()->width();
-        if ((tw.isAuto() || tw.isPercent()) && !table->isPositioned()) {
+        if ((tw.isAuto() || tw.isPercent()) && !table->isOutOfFlowPositioned()) {
             RenderBlock* cb = table->containingBlock();
             while (cb && !cb->isRenderView() && !cb->isTableCell() &&
-                cb->style()->width().isAuto() && !cb->isPositioned())
+                cb->style()->width().isAuto() && !cb->isOutOfFlowPositioned())
                 cb = cb->containingBlock();
 
             table = 0;

@@ -119,7 +119,7 @@ void InlineFlowBox::addToLine(InlineBox* child)
             setHasTextDescendantsOnAncestors(this);
     }
 
-    if (descendantsHaveSameLineHeightAndBaseline() && !child->renderer()->isPositioned()) {
+    if (descendantsHaveSameLineHeightAndBaseline() && !child->renderer()->isOutOfFlowPositioned()) {
         RenderStyle* parentStyle = renderer()->style(isFirstLineStyle());
         RenderStyle* childStyle = child->renderer()->style(isFirstLineStyle());
         bool shouldClearDescendantsHaveSameLineHeightAndBaseline = false;
@@ -156,7 +156,7 @@ void InlineFlowBox::addToLine(InlineBox* child)
             clearDescendantsHaveSameLineHeightAndBaseline();
     }
 
-    if (!child->renderer()->isPositioned()) {
+    if (!child->renderer()->isOutOfFlowPositioned()) {
         if (child->isText()) {
             RenderStyle* childStyle = child->renderer()->style(isFirstLineStyle());
             if (childStyle->letterSpacing() < 0 || childStyle->textShadow() || childStyle->textEmphasisMark() != TextEmphasisMarkNone || childStyle->textStrokeWidth())
@@ -391,7 +391,7 @@ float InlineFlowBox::placeBoxesInInlineDirection(float logicalLeft, bool& needsW
             if (knownToHaveNoOverflow())
                 maxLogicalRight = max(logicalLeft, maxLogicalRight);
         } else {
-            if (curr->renderer()->isPositioned()) {
+            if (curr->renderer()->isOutOfFlowPositioned()) {
                 if (curr->renderer()->parent()->style()->isLeftToRightDirection())
                     curr->setLogicalLeft(logicalLeft);
                 else
@@ -445,7 +445,7 @@ bool InlineFlowBox::requiresIdeographicBaseline(const GlyphOverflowAndFallbackFo
         return true;
 
     for (InlineBox* curr = firstChild(); curr; curr = curr->nextOnLine()) {
-        if (curr->renderer()->isPositioned())
+        if (curr->renderer()->isOutOfFlowPositioned())
             continue; // Positioned placeholders don't affect calculations.
         
         if (curr->isInlineFlowBox()) {
@@ -478,7 +478,7 @@ void InlineFlowBox::adjustMaxAscentAndDescent(LayoutUnit& maxAscent, LayoutUnit&
     for (InlineBox* curr = firstChild(); curr; curr = curr->nextOnLine()) {
         // The computed lineheight needs to be extended for the
         // positioned elements
-        if (curr->renderer()->isPositioned())
+        if (curr->renderer()->isOutOfFlowPositioned())
             continue; // Positioned placeholders don't affect calculations.
         if (curr->verticalAlign() == TOP || curr->verticalAlign() == BOTTOM) {
             LayoutUnit lineHeight = curr->lineHeight();
@@ -545,7 +545,7 @@ void InlineFlowBox::computeLogicalBoxHeights(RootInlineBox* rootBox, LayoutUnit&
         return;
 
     for (InlineBox* curr = firstChild(); curr; curr = curr->nextOnLine()) {
-        if (curr->renderer()->isPositioned())
+        if (curr->renderer()->isOutOfFlowPositioned())
             continue; // Positioned placeholders don't affect calculations.
         
         InlineFlowBox* inlineFlowBox = curr->isInlineFlowBox() ? toInlineFlowBox(curr) : 0;
@@ -616,7 +616,7 @@ void InlineFlowBox::placeBoxesInBlockDirection(LayoutUnit top, LayoutUnit maxHei
     }
 
     for (InlineBox* curr = firstChild(); curr; curr = curr->nextOnLine()) {
-        if (curr->renderer()->isPositioned())
+        if (curr->renderer()->isOutOfFlowPositioned())
             continue; // Positioned placeholders don't affect calculations.
 
         if (descendantsHaveSameLineHeightAndBaseline()) {
@@ -736,7 +736,7 @@ void InlineFlowBox::flipLinesInBlockDirection(LayoutUnit lineTop, LayoutUnit lin
     setLogicalTop(lineBottom - (logicalTop() - lineTop) - logicalHeight());
     
     for (InlineBox* curr = firstChild(); curr; curr = curr->nextOnLine()) {
-        if (curr->renderer()->isPositioned())
+        if (curr->renderer()->isOutOfFlowPositioned())
             continue; // Positioned placeholders aren't affected here.
         
         if (curr->isInlineFlowBox())
@@ -912,7 +912,7 @@ void InlineFlowBox::computeOverflow(LayoutUnit lineTop, LayoutUnit lineBottom, G
     addBorderOutsetVisualOverflow(logicalVisualOverflow);
 
     for (InlineBox* curr = firstChild(); curr; curr = curr->nextOnLine()) {
-        if (curr->renderer()->isPositioned())
+        if (curr->renderer()->isOutOfFlowPositioned())
             continue; // Positioned placeholders don't affect calculations.
         
         if (curr->renderer()->isText()) {
@@ -1429,7 +1429,7 @@ LayoutUnit InlineFlowBox::computeOverAnnotationAdjustment(LayoutUnit allowedPosi
 {
     LayoutUnit result = 0;
     for (InlineBox* curr = firstChild(); curr; curr = curr->nextOnLine()) {
-        if (curr->renderer()->isPositioned())
+        if (curr->renderer()->isOutOfFlowPositioned())
             continue; // Positioned placeholders don't affect calculations.
         
         if (curr->isInlineFlowBox())
@@ -1477,7 +1477,7 @@ LayoutUnit InlineFlowBox::computeUnderAnnotationAdjustment(LayoutUnit allowedPos
 {
     LayoutUnit result = 0;
     for (InlineBox* curr = firstChild(); curr; curr = curr->nextOnLine()) {
-        if (curr->renderer()->isPositioned())
+        if (curr->renderer()->isOutOfFlowPositioned())
             continue; // Positioned placeholders don't affect calculations.
 
         if (curr->isInlineFlowBox())

@@ -166,7 +166,7 @@ static inline void notifyObserverWillExitObject(Observer* observer, RenderObject
 static inline bool isIteratorTarget(RenderObject* object)
 {
     ASSERT(object); // The iterator will of course return 0, but its not an expected argument to this function.
-    return object->isText() || object->isFloating() || object->isPositioned() || object->isReplaced();
+    return object->isText() || object->isFloating() || object->isOutOfFlowPositioned() || object->isReplaced();
 }
 
 // This enum is only used for bidiNextShared()

@@ -45,7 +45,7 @@ LayoutState::LayoutState(LayoutState* prev, RenderBox* renderer, const LayoutSiz
 {
     ASSERT(m_next);
 
-    bool fixed = renderer->isPositioned() && renderer->style()->position() == FixedPosition;
+    bool fixed = renderer->isOutOfFlowPositioned() && renderer->style()->position() == FixedPosition;
     if (fixed) {
         // FIXME: This doesn't work correctly with transforms.
         FloatPoint fixedOffset = renderer->view()->localToAbsolute(FloatPoint(), true);
@@ -53,7 +53,7 @@ LayoutState::LayoutState(LayoutState* prev, RenderBox* renderer, const LayoutSiz
     } else
         m_paintOffset = prev->m_paintOffset + offset;
 
-    if (renderer->isPositioned() && !fixed) {
+    if (renderer->isOutOfFlowPositioned() && !fixed) {
         if (RenderObject* container = renderer->container()) {
             if (container->isRelPositioned() && container->isRenderInline())
                 m_paintOffset += toRenderInline(container)->relativePositionedInlineOffset(renderer);

@@ -162,7 +162,7 @@ RenderBlock::MarginInfo::MarginInfo(RenderBlock* block, LayoutUnit beforeBorderP
     // if we had any border/padding (obviously), if we're the root or HTML elements, or if
     // we're positioned, floating, a table cell.
     RenderStyle* blockStyle = block->style();
-    m_canCollapseWithChildren = !block->isRenderView() && !block->isRoot() && !block->isPositioned()
+    m_canCollapseWithChildren = !block->isRenderView() && !block->isRoot() && !block->isOutOfFlowPositioned()
         && !block->isFloating() && !block->isTableCell() && !block->hasOverflowClip() && !block->isInlineBlockOrInlineTable()
         && !block->isWritingModeRoot() && blockStyle->hasAutoColumnCount() && blockStyle->hasAutoColumnWidth()
         && !blockStyle->columnSpan();
@@ -278,7 +278,7 @@ void RenderBlock::willBeDestroyed()
 void RenderBlock::styleWillChange(StyleDifference diff, const RenderStyle* newStyle)
 {
     RenderStyle* oldStyle = style();
-    s_canPropagateFloatIntoSibling = oldStyle ? !isFloatingOrPositioned() && !avoidsFloats() : false;
+    s_canPropagateFloatIntoSibling = oldStyle ? !isFloatingOrOutOfFlowPositioned() && !avoidsFloats() : false;
 
     setReplaced(newStyle->isDisplayInlineType());
     
@@ -303,7 +303,7 @@ void RenderBlock::styleWillChange(StyleDifference diff, const RenderStyle* newSt
                 toRenderBlock(cb)->removePositionedObjects(this);
         }
 
-        if (containsFloats() && !isFloating() && !isPositioned() && (newStyle->position() == AbsolutePosition || newStyle->position() == FixedPosition))
+        if (containsFloats() && !isFloating() && !isOutOfFlowPositioned() && (newStyle->position() == AbsolutePosition || newStyle->position() == FixedPosition))
             markAllDescendantsWithFloatsForLayout();
     }
 
@@ -337,7 +337,7 @@ void RenderBlock::styleDidChange(StyleDifference diff, const RenderStyle* oldSty
     // blocks, then we need to find the top most parent containing that overhanging float and
     // then mark its descendants with floats for layout and clear all floats from its next
     // sibling blocks that exist in our floating objects list. See bug 56299 and 62875.
-    bool canPropagateFloatIntoSibling = !isFloatingOrPositioned() && !avoidsFloats();
+    bool canPropagateFloatIntoSibling = !isFloatingOrOutOfFlowPositioned() && !avoidsFloats();
     if (diff == StyleDifferenceLayout && s_canPropagateFloatIntoSibling && !canPropagateFloatIntoSibling && hasOverhangingFloats()) {
         RenderBlock* parentBlock = this;
         const FloatingObjectSet& floatingObjectSet = m_floatingObjects->set();
@@ -412,7 +412,7 @@ void RenderBlock::addChildToContinuation(RenderObject* newChild, RenderObject* b
             beforeChildParent = flow;
     }
 
-    if (newChild->isFloatingOrPositioned()) {
+    if (newChild->isFloatingOrOutOfFlowPositioned()) {
         beforeChildParent->addChildIgnoringContinuation(newChild, beforeChild);
         return;
     }
@@ -459,7 +459,7 @@ void RenderBlock::addChildToAnonymousColumnBlocks(RenderObject* newChild, Render
         beforeChildParent = toRenderBlock(lastChild());
 
     // If the new child is floating or positioned it can just go in that block.
-    if (newChild->isFloatingOrPositioned()) {
+    if (newChild->isFloatingOrOutOfFlowPositioned()) {
         beforeChildParent->addChildIgnoringAnonymousColumnBlocks(newChild, beforeChild);
         return;
     }
@@ -508,7 +508,7 @@ RenderBlock* RenderBlock::containingColumnsBlock(bool allowAnonymousColumnBlock)
 {
     RenderBlock* firstChildIgnoringAnonymousWrappers = 0;
     for (RenderObject* curr = this; curr; curr = curr->parent()) {
-        if (!curr->isRenderBlock() || curr->isFloatingOrPositioned() || curr->isTableCell() || curr->isRoot() || curr->isRenderView() || curr->hasOverflowClip()
+        if (!curr->isRenderBlock() || curr->isFloatingOrOutOfFlowPositioned() || curr->isTableCell() || curr->isRoot() || curr->isRenderView() || curr->hasOverflowClip()
             || curr->isInlineBlockOrInlineTable())
             return 0;
 
@@ -758,7 +758,7 @@ RenderBlock* RenderBlock::columnsBlockForSpanningElement(RenderObject* newChild)
     // This function currently supports (1) and (2).
     RenderBlock* columnsBlockAncestor = 0;
     if (!newChild->isText() && newChild->style()->columnSpan() && !newChild->isBeforeOrAfterContent()
-        && !newChild->isFloatingOrPositioned() && !newChild->isInline() && !isAnonymousColumnSpanBlock()) {
+        && !newChild->isFloatingOrOutOfFlowPositioned() && !newChild->isInline() && !isAnonymousColumnSpanBlock()) {
         columnsBlockAncestor = containingColumnsBlock(false);
         if (columnsBlockAncestor) {
             // Make sure that none of the parent ancestors have a continuation.
@@ -885,7 +885,7 @@ void RenderBlock::addChildIgnoringAnonymousColumnBlocks(RenderObject* newChild,
     // A block has to either have all of its children inline, or all of its children as blocks.
     // So, if our children are currently inline and a block child has to be inserted, we move all our
     // inline children into anonymous block boxes.
-    if (childrenInline() && !newChild->isInline() && !newChild->isFloatingOrPositioned()) {
+    if (childrenInline() && !newChild->isInline() && !newChild->isFloatingOrOutOfFlowPositioned()) {
         // This is a block with inline content. Wrap the inline content in anonymous blocks.
         makeChildrenNonInline(beforeChild);
         madeBoxesNonInline = true;
@@ -895,7 +895,7 @@ void RenderBlock::addChildIgnoringAnonymousColumnBlocks(RenderObject* newChild,
             ASSERT(beforeChild->isAnonymousBlock());
             ASSERT(beforeChild->parent() == this);
         }
-    } else if (!childrenInline() && (newChild->isFloatingOrPositioned() || newChild->isInline())) {
+    } else if (!childrenInline() && (newChild->isFloatingOrOutOfFlowPositioned() || newChild->isInline())) {
         // If we're inserting an inline child but all of our children are blocks, then we have to make sure
         // it is put into an anomyous block box. We try to use an existing anonymous box if possible, otherwise
         // a new one is created and inserted into our list of children in the appropriate position.
@@ -961,7 +961,7 @@ static void getInlineRun(RenderObject* start, RenderObject* boundary,
     RenderObject * curr = start;
     bool sawInline;
     do {
-        while (curr && !(curr->isInline() || curr->isFloatingOrPositioned()))
+        while (curr && !(curr->isInline() || curr->isFloatingOrOutOfFlowPositioned()))
             curr = curr->nextSibling();
         
         inlineRunStart = inlineRunEnd = curr;
@@ -972,7 +972,7 @@ static void getInlineRun(RenderObject* start, RenderObject* boundary,
         sawInline = curr->isInline();
         
         curr = curr->nextSibling();
-        while (curr && (curr->isInline() || curr->isFloatingOrPositioned()) && (curr != boundary)) {
+        while (curr && (curr->isInline() || curr->isFloatingOrOutOfFlowPositioned()) && (curr != boundary)) {
             inlineRunEnd = curr;
             if (curr->isInline())
                 sawInline = true;
@@ -1283,7 +1283,7 @@ bool RenderBlock::isSelfCollapsingBlock() const
         // Whether or not we collapse is dependent on whether all our normal flow children
         // are also self-collapsing.
         for (RenderBox* child = firstChildBox(); child; child = child->nextSiblingBox()) {
-            if (child->isFloatingOrPositioned())
+            if (child->isFloatingOrOutOfFlowPositioned())
                 continue;
             if (!child->isSelfCollapsingBlock())
                 return false;
@@ -1507,7 +1507,7 @@ void RenderBlock::layoutBlock(bool relayoutChildren, LayoutUnit pageLogicalHeigh
         if (oldHeight > newHeight && maxFloatLogicalBottom > newHeight && !childrenInline()) {
             // One of our children's floats may have become an overhanging float for us. We need to look for it.
             for (RenderObject* child = firstChild(); child; child = child->nextSibling()) {
-                if (child->isBlockFlow() && !child->isFloatingOrPositioned()) {
+                if (child->isBlockFlow() && !child->isFloatingOrOutOfFlowPositioned()) {
                     RenderBlock* block = toRenderBlock(child);
                     if (block->lowestFloatLogicalBottom() + block->logicalTop() > newHeight)
                         addOverhangingFloats(block, false);
@@ -1638,7 +1638,7 @@ void RenderBlock::computeOverflow(LayoutUnit oldClientAfterEdge, bool recomputeF
 void RenderBlock::addOverflowFromBlockChildren()
 {
     for (RenderBox* child = firstChildBox(); child; child = child->nextSiblingBox()) {
-        if (!child->isFloatingOrPositioned())
+        if (!child->isFloatingOrOutOfFlowPositioned())
             addOverflowFromChild(child);
     }
 }
@@ -1690,7 +1690,7 @@ void RenderBlock::addVisualOverflowFromTheme()
 
 bool RenderBlock::expandsToEncloseOverhangingFloats() const
 {
-    return isInlineBlockOrInlineTable() || isFloatingOrPositioned() || hasOverflowClip() || (parent() && parent()->isDeprecatedFlexibleBox())
+    return isInlineBlockOrInlineTable() || isFloatingOrOutOfFlowPositioned() || hasOverflowClip() || (parent() && parent()->isDeprecatedFlexibleBox())
            || hasColumns() || isTableCell() || isTableCaption() || isFieldset() || isWritingModeRoot() || isRoot();
 }
 
@@ -1756,7 +1756,7 @@ bool RenderBlock::handleSpecialChild(RenderBox* child, const MarginInfo& marginI
 
 bool RenderBlock::handlePositionedChild(RenderBox* child, const MarginInfo& marginInfo)
 {
-    if (child->isPositioned()) {
+    if (child->isOutOfFlowPositioned()) {
         child->containingBlock()->insertPositionedObject(child);
         adjustPositionedBlock(child, marginInfo);
         return true;
@@ -1869,7 +1869,7 @@ void RenderBlock::moveRunInUnderSiblingBlockIfNeeded(RenderObject* runIn)
     if (curr->isRunIn() || (curr->firstChild() && curr->firstChild()->isRunIn()))
         return;
 
-    if (curr->isAnonymous() || curr->isFloatingOrPositioned())
+    if (curr->isAnonymous() || curr->isFloatingOrOutOfFlowPositioned())
         return;
 
     RenderBoxModelObject* oldRunIn = toRenderBoxModelObject(runIn);
@@ -2031,7 +2031,7 @@ LayoutUnit RenderBlock::collapseMargins(RenderBox* child, MarginInfo& marginInfo
     // overhang from the previous sibling are added to our parent. If the child's previous sibling itself is a float the child will avoid
     // or clear it anyway, so don't worry about any floating children it may contain.
     RenderObject* prev = child->previousSibling();
-    if (prev && prev->isBlockFlow() && !prev->isFloatingOrPositioned()) {
+    if (prev && prev->isBlockFlow() && !prev->isFloatingOrOutOfFlowPositioned()) {
         RenderBlock* block = toRenderBlock(prev);
         if (block->containsFloats() && block->lowestFloatLogicalBottom() > logicalTop) 
             addOverhangingFloats(block, false);
@@ -2056,7 +2056,7 @@ LayoutUnit RenderBlock::clearFloatsIfNeeded(RenderBox* child, MarginInfo& margin
         // self-collapsing block's bottom margin.
         bool atBottomOfBlock = true;
         for (RenderBox* curr = child->nextSiblingBox(); curr && atBottomOfBlock; curr = curr->nextSiblingBox()) {
-            if (!curr->isFloatingOrPositioned())
+            if (!curr->isFloatingOrOutOfFlowPositioned())
                 atBottomOfBlock = false;
         }
         
@@ -2451,7 +2451,7 @@ void RenderBlock::simplifiedNormalFlowLayout()
         ListHashSet<RootInlineBox*> lineBoxes;
         for (InlineWalker walker(this); !walker.atEnd(); walker.advance()) {
             RenderObject* o = walker.current();
-            if (!o->isPositioned() && (o->isReplaced() || o->isFloating())) {
+            if (!o->isOutOfFlowPositioned() && (o->isReplaced() || o->isFloating())) {
                 o->layoutIfNeeded();
                 if (toRenderBox(o)->inlineBoxWrapper()) {
                     RootInlineBox* box = toRenderBox(o)->inlineBoxWrapper()->root();
@@ -2469,7 +2469,7 @@ void RenderBlock::simplifiedNormalFlowLayout()
         }
     } else {
         for (RenderBox* box = firstChildBox(); box; box = box->nextSiblingBox()) {
-            if (!box->isPositioned())
+            if (!box->isOutOfFlowPositioned())
                 box->layoutIfNeeded();
         }
     }
@@ -3133,9 +3133,9 @@ bool RenderBlock::isSelectionRoot() const
     if (isTable())
         return false;
         
-    if (isBody() || isRoot() || hasOverflowClip() || isRelPositioned() ||
-        isFloatingOrPositioned() || isTableCell() || isInlineBlockOrInlineTable() || hasTransform() ||
-        hasReflection() || hasMask() || isWritingModeRoot())
+    if (isBody() || isRoot() || hasOverflowClip() || isRelPositioned()
+        || isFloatingOrOutOfFlowPositioned() || isTableCell() || isInlineBlockOrInlineTable() || hasTransform()
+        || hasReflection() || hasMask() || isWritingModeRoot())
         return true;
     
     if (view() && view()->selectionStart()) {
@@ -3352,7 +3352,7 @@ GapRects RenderBlock::blockSelectionGaps(RenderBlock* rootBlock, const LayoutPoi
         if (childState == SelectionBoth || childState == SelectionEnd)
             sawSelectionEnd = true;
 
-        if (curr->isFloatingOrPositioned())
+        if (curr->isFloatingOrOutOfFlowPositioned())
             continue; // We must be a normal flow object in order to even be considered.
 
         if (curr->isRelPositioned() && curr->hasLayer()) {
@@ -4179,7 +4179,7 @@ void RenderBlock::clearFloats()
     }
 
     // Inline blocks are covered by the isReplaced() check in the avoidFloats method.
-    if (avoidsFloats() || isRoot() || isRenderView() || isFloatingOrPositioned() || isTableCell()) {
+    if (avoidsFloats() || isRoot() || isRenderView() || isFloatingOrOutOfFlowPositioned() || isTableCell()) {
         if (m_floatingObjects) {
             deleteAllValues(m_floatingObjects->set());
             m_floatingObjects->clear();
@@ -4217,7 +4217,7 @@ void RenderBlock::clearFloats()
     RenderBlock* parentBlock = toRenderBlock(parent());
     bool parentHasFloats = false;
     RenderObject* prev = previousSibling();
-    while (prev && (prev->isFloatingOrPositioned() || !prev->isBox() || !prev->isRenderBlock() || toRenderBlock(prev)->avoidsFloats())) {
+    while (prev && (prev->isFloatingOrOutOfFlowPositioned() || !prev->isBox() || !prev->isRenderBlock() || toRenderBlock(prev)->avoidsFloats())) {
         if (prev->isFloating())
             parentHasFloats = true;
         prev = prev->previousSibling();
@@ -4451,7 +4451,7 @@ void RenderBlock::markAllDescendantsWithFloatsForLayout(RenderBox* floatToRemove
     // Iterate over our children and mark them as needed.
     if (!childrenInline()) {
         for (RenderObject* child = firstChild(); child; child = child->nextSibling()) {
-            if ((!floatToRemove && child->isFloatingOrPositioned()) || !child->isRenderBlock())
+            if ((!floatToRemove && child->isFloatingOrOutOfFlowPositioned()) || !child->isRenderBlock())
                 continue;
             RenderBlock* childBlock = toRenderBlock(child);
             if ((floatToRemove ? childBlock->containsFloat(floatToRemove) : childBlock->containsFloats()) || childBlock->shrinkToAvoidFloats())
@@ -4469,7 +4469,7 @@ void RenderBlock::markSiblingsWithFloatsForLayout(RenderBox* floatToRemove)
     FloatingObjectSetIterator end = floatingObjectSet.end();
 
     for (RenderObject* next = nextSibling(); next; next = next->nextSibling()) {
-        if (!next->isRenderBlock() || next->isFloatingOrPositioned() || toRenderBlock(next)->avoidsFloats())
+        if (!next->isRenderBlock() || next->isFloatingOrOutOfFlowPositioned() || toRenderBlock(next)->avoidsFloats())
             continue;
 
         RenderBlock* nextBlock = toRenderBlock(next);
@@ -4884,7 +4884,7 @@ VisiblePosition RenderBlock::positionForPointWithInlineChildren(const LayoutPoin
 
 static inline bool isChildHitTestCandidate(RenderBox* box)
 {
-    return box->height() && box->style()->visibility() == VISIBLE && !box->isFloatingOrPositioned();
+    return box->height() && box->style()->visibility() == VISIBLE && !box->isFloatingOrOutOfFlowPositioned();
 }
 
 VisiblePosition RenderBlock::positionForPoint(const LayoutPoint& point)
@@ -5417,7 +5417,7 @@ RenderObject* InlineMinMaxIterator::next()
     while (current || current == parent) {
         if (!oldEndOfInline &&
             (current == parent ||
-             (!current->isFloating() && !current->isReplaced() && !current->isPositioned())))
+             (!current->isFloating() && !current->isReplaced() && !current->isOutOfFlowPositioned())))
             result = current->firstChild();
         if (!result) {
             // We hit the end of our inline. (It was empty, e.g., <span></span>.)
@@ -5442,7 +5442,7 @@ RenderObject* InlineMinMaxIterator::next()
         if (!result)
             break;
 
-        if (!result->isPositioned() && (result->isText() || result->isFloating() || result->isReplaced() || result->isRenderInline()))
+        if (!result->isOutOfFlowPositioned() && (result->isText() || result->isFloating() || result->isReplaced() || result->isRenderInline()))
              break;
         
         current = result;
@@ -5768,7 +5768,7 @@ void RenderBlock::computeBlockPreferredLogicalWidths()
     LayoutUnit floatLeftWidth = 0, floatRightWidth = 0;
     while (child) {
         // Positioned children don't affect the min/max width
-        if (child->isPositioned()) {
+        if (child->isOutOfFlowPositioned()) {
             child = child->nextSibling();
             continue;
         }
@@ -5942,7 +5942,7 @@ LayoutUnit RenderBlock::firstLineBoxBaseline() const
     }
     else {
         for (RenderBox* curr = firstChildBox(); curr; curr = curr->nextSiblingBox()) {
-            if (!curr->isFloatingOrPositioned()) {
+            if (!curr->isFloatingOrOutOfFlowPositioned()) {
                 LayoutUnit result = curr->firstLineBoxBaseline();
                 if (result != -1)
                     return curr->logicalTop() + result; // Translate to our coordinate space.
@@ -5973,7 +5973,7 @@ LayoutUnit RenderBlock::lastLineBoxBaseline() const
     } else {
         bool haveNormalFlowChild = false;
         for (RenderBox* curr = lastChildBox(); curr; curr = curr->previousSiblingBox()) {
-            if (!curr->isFloatingOrPositioned()) {
+            if (!curr->isFloatingOrOutOfFlowPositioned()) {
                 haveNormalFlowChild = true;
                 LayoutUnit result = curr->lastLineBoxBaseline();
                 if (result != -1)
@@ -6208,7 +6208,7 @@ void RenderBlock::updateFirstLetter()
             break;
         if (currChild->isListMarker())
             currChild = currChild->nextSibling();
-        else if (currChild->isFloatingOrPositioned()) {
+        else if (currChild->isFloatingOrOutOfFlowPositioned()) {
             if (currChild->style()->styleType() == FIRST_LETTER) {
                 currChild = currChild->firstChild();
                 break;
@@ -6248,9 +6248,9 @@ void RenderBlock::updateFirstLetter()
 // (crawling into blocks).
 static bool shouldCheckLines(RenderObject* obj)
 {
-    return !obj->isFloatingOrPositioned() && !obj->isRunIn() &&
-            obj->isBlockFlow() && obj->style()->height().isAuto() &&
-            (!obj->isDeprecatedFlexibleBox() || obj->style()->boxOrient() == VERTICAL);
+    return !obj->isFloatingOrOutOfFlowPositioned() && !obj->isRunIn()
+            && obj->isBlockFlow() && obj->style()->height().isAuto()
+            && (!obj->isDeprecatedFlexibleBox() || obj->style()->boxOrient() == VERTICAL);
 }
 
 static RootInlineBox* getLineAtIndex(RenderBlock* block, int i, int& count)
@@ -6291,8 +6291,7 @@ static int getHeightForLineCount(RenderBlock* block, int l, bool includeBottom,
                     int result = getHeightForLineCount(toRenderBlock(obj), l, false, count);
                     if (result != -1)
                         return result + obj->y() + (includeBottom ? (block->borderBottom() + block->paddingBottom()) : ZERO_LAYOUT_UNIT);
-                }
-                else if (!obj->isFloatingOrPositioned() && !obj->isRunIn())
+                } else if (!obj->isFloatingOrOutOfFlowPositioned() && !obj->isRunIn())
                     normalFlowChildWithoutLines = obj;
             }
             if (normalFlowChildWithoutLines && l == 0)
@@ -6345,7 +6344,7 @@ void RenderBlock::adjustForBorderFit(LayoutUnit x, LayoutUnit& left, LayoutUnit&
         }
         else {
             for (RenderBox* obj = firstChildBox(); obj; obj = obj->nextSiblingBox()) {
-                if (!obj->isFloatingOrPositioned()) {
+                if (!obj->isFloatingOrOutOfFlowPositioned()) {
                     if (obj->isBlockFlow() && !obj->hasOverflowClip())
                         toRenderBlock(obj)->adjustForBorderFit(x + obj->x(), left, right);
                     else if (obj->style()->visibility() == VISIBLE) {
@@ -6669,7 +6668,7 @@ static bool inNormalFlow(RenderBox* child)
     while (curr && curr != renderView) {
         if (curr->hasColumns() || curr->isRenderFlowThread())
             return true;
-        if (curr->isFloatingOrPositioned())
+        if (curr->isFloatingOrOutOfFlowPositioned())
             return false;
         curr = curr->containingBlock();
     }
@@ -6848,7 +6847,7 @@ void RenderBlock::adjustLinePositionForPagination(RootInlineBox* lineBox, Layout
         }
         LayoutUnit totalLogicalHeight = lineHeight + max(ZERO_LAYOUT_UNIT, logicalOffset);
         LayoutUnit pageLogicalHeightAtNewOffset = hasUniformPageLogicalHeight ? pageLogicalHeight : pageLogicalHeightForOffset(logicalOffset + remainingLogicalHeight);
-        if (lineBox == firstRootBox() && totalLogicalHeight < pageLogicalHeightAtNewOffset && !isPositioned() && !isTableCell())
+        if (lineBox == firstRootBox() && totalLogicalHeight < pageLogicalHeightAtNewOffset && !isOutOfFlowPositioned() && !isTableCell())
             setPaginationStrut(remainingLogicalHeight + max(ZERO_LAYOUT_UNIT, logicalOffset));
         else {
             delta += remainingLogicalHeight;
@@ -6905,7 +6904,7 @@ LayoutUnit RenderBlock::adjustBlockChildForPagination(LayoutUnit logicalTopAfter
     if (paginationStrut) {
         // We are willing to propagate out to our parent block as long as we were at the top of the block prior
         // to collapsing our margins, and as long as we didn't clear or move as a result of other pagination.
-        if (atBeforeSideOfBlock && oldTop == result && !isPositioned() && !isTableCell()) {
+        if (atBeforeSideOfBlock && oldTop == result && !isOutOfFlowPositioned() && !isTableCell()) {
             // FIXME: Should really check if we're exceeding the page height before propagating the strut, but we don't
             // have all the information to do so (the strut only has the remaining amount to push). Gecko gets this wrong too
             // and pushes to the next page anyway, so not too concerned about it.
@@ -7103,7 +7102,7 @@ const char* RenderBlock::renderName() const
     
     if (isFloating())
         return ""RenderBlock (floating)"";
-    if (isPositioned())
+    if (isOutOfFlowPositioned())
         return ""RenderBlock (positioned)"";
     if (isAnonymousColumnsBlock())
         return ""RenderBlock (anonymous multi-column)"";

@@ -247,7 +247,7 @@ public:
 
     static bool shouldSkipCreatingRunsForObject(RenderObject* obj)
     {
-        return obj->isFloating() || (obj->isPositioned() && !obj->style()->isOriginalDisplayInlineType() && !obj->container()->isRenderInline());
+        return obj->isFloating() || (obj->isOutOfFlowPositioned() && !obj->style()->isOriginalDisplayInlineType() && !obj->container()->isRenderInline());
     }
     
     static void appendRunsForObject(BidiRunList<BidiRun>&, int start, int end, RenderObject*, InlineBidiResolver&);

@@ -617,7 +617,7 @@ void RenderBlock::setMarginsForRubyRun(BidiRun* run, RenderRubyRun* renderer, Re
     int endOverhang;
     RenderObject* nextObject = 0;
     for (BidiRun* runWithNextObject = run->next(); runWithNextObject; runWithNextObject = runWithNextObject->next()) {
-        if (!runWithNextObject->m_object->isPositioned() && !runWithNextObject->m_box->isLineBreak()) {
+        if (!runWithNextObject->m_object->isOutOfFlowPositioned() && !runWithNextObject->m_box->isLineBreak()) {
             nextObject = runWithNextObject->m_object;
             break;
         }
@@ -762,7 +762,7 @@ void RenderBlock::computeInlineDirectionPositionsForLine(RootInlineBox* lineBox,
     RenderObject* previousObject = 0;
 
     for (BidiRun* r = firstRun; r; r = r->next()) {
-        if (!r->m_box || r->m_object->isPositioned() || r->m_box->isLineBreak())
+        if (!r->m_box || r->m_object->isOutOfFlowPositioned() || r->m_box->isLineBreak())
             continue; // Positioned objects are only participating to figure out their
                       // correct static x position.  They have no effect on the width.
                       // Similarly, line break boxes have no effect on the width.
@@ -826,7 +826,7 @@ void RenderBlock::computeBlockDirectionPositionsForLine(RootInlineBox* lineBox,
 
         // Align positioned boxes with the top of the line box.  This is
         // a reasonable approximation of an appropriate y position.
-        if (r->m_object->isPositioned())
+        if (r->m_object->isOutOfFlowPositioned())
             r->m_box->setLogicalTop(logicalHeight());
 
         // Position is used to properly position both replaced elements and
@@ -1478,7 +1478,7 @@ void RenderBlock::layoutInlineChildren(bool relayoutChildren, LayoutUnit& repain
             if (!hasInlineChild && o->isInline())
                 hasInlineChild = true;
 
-            if (o->isReplaced() || o->isFloating() || o->isPositioned()) {
+            if (o->isReplaced() || o->isFloating() || o->isOutOfFlowPositioned()) {
                 RenderBox* box = toRenderBox(o);
 
                 if (relayoutChildren || box->hasRelativeDimensions())
@@ -1488,7 +1488,7 @@ void RenderBlock::layoutInlineChildren(bool relayoutChildren, LayoutUnit& repain
                 if (relayoutChildren && box->needsPreferredWidthsRecalculation())
                     o->setPreferredLogicalWidthsDirty(true, MarkOnlyThis);
 
-                if (o->isPositioned())
+                if (o->isOutOfFlowPositioned())
                     o->containingBlock()->insertPositionedObject(box);
                 else if (o->isFloating())
                     layoutState.floats().append(FloatWithRect(box));
@@ -1849,7 +1849,7 @@ static bool alwaysRequiresLineBox(RenderInline* flow)
 
 static bool requiresLineBox(const InlineIterator& it, const LineInfo& lineInfo = LineInfo(), WhitespacePosition whitespacePosition = LeadingWhitespace)
 {
-    if (it.m_obj->isFloatingOrPositioned())
+    if (it.m_obj->isFloatingOrOutOfFlowPositioned())
         return false;
 
     if (it.m_obj->isRenderInline() && !alwaysRequiresLineBox(toRenderInline(it.m_obj)) && !requiresLineBoxForContent(toRenderInline(it.m_obj), lineInfo))
@@ -1885,7 +1885,7 @@ void RenderBlock::LineBreaker::skipTrailingWhitespace(InlineIterator& iterator,
 {
     while (!iterator.atEnd() && !requiresLineBox(iterator, lineInfo, TrailingWhitespace)) {
         RenderObject* object = iterator.m_obj;
-        if (object->isPositioned())
+        if (object->isOutOfFlowPositioned())
             setStaticPositions(m_block, toRenderBox(object));
         else if (object->isFloating())
             m_block->insertFloatingObject(toRenderBox(object));
@@ -1898,7 +1898,7 @@ void RenderBlock::LineBreaker::skipLeadingWhitespace(InlineBidiResolver& resolve
 {
     while (!resolver.position().atEnd() && !requiresLineBox(resolver.position(), lineInfo, LeadingWhitespace)) {
         RenderObject* object = resolver.position().m_obj;
-        if (object->isPositioned()) {
+        if (object->isOutOfFlowPositioned()) {
             setStaticPositions(m_block, toRenderBox(object));
             if (object->style()->isOriginalDisplayInlineType()) {
                 resolver.runs().addRun(createRun(0, 1, object, resolver));
@@ -2192,7 +2192,7 @@ InlineIterator RenderBlock::LineBreaker::nextLineBreak(InlineBidiResolver& resol
             goto end;
         }
 
-        if (current.m_obj->isPositioned()) {
+        if (current.m_obj->isOutOfFlowPositioned()) {
             // If our original display wasn't an inline type, then we can
             // go ahead and determine our static inline position now.
             RenderBox* box = toRenderBox(current.m_obj);
@@ -2599,7 +2599,7 @@ InlineIterator RenderBlock::LineBreaker::nextLineBreak(InlineBidiResolver& resol
                 goto end;
         }
 
-        if (!current.m_obj->isFloatingOrPositioned()) {
+        if (!current.m_obj->isFloatingOrOutOfFlowPositioned()) {
             last = current.m_obj;
             if (last->isReplaced() && autoWrap && (!last->isImage() || allowImagesToBreak) && (!last->isListMarker() || toRenderListMarker(last)->isInside())) {
                 width.commit();

@@ -150,7 +150,7 @@ void RenderBox::willBeDestroyed()
 
 void RenderBox::removeFloatingOrPositionedChildFromBlockLists()
 {
-    ASSERT(isFloatingOrPositioned());
+    ASSERT(isFloatingOrOutOfFlowPositioned());
 
     if (documentBeingDestroyed())
         return;
@@ -175,7 +175,7 @@ void RenderBox::removeFloatingOrPositionedChildFromBlockLists()
         }
     }
 
-    if (isPositioned()) {
+    if (isOutOfFlowPositioned()) {
         for (RenderObject* curr = parent(); curr; curr = curr->parent()) {
             if (curr->isRenderBlock())
                 toRenderBlock(curr)->removePositionedObject(this);
@@ -201,9 +201,9 @@ void RenderBox::styleWillChange(StyleDifference diff, const RenderStyle* newStyl
             markContainingBlocksForLayout();
             if (oldStyle->position() == StaticPosition)
                 repaint();
-            else if (newStyle->isPositioned())
+            else if (newStyle->isOutOfFlowPositioned())
                 parent()->setChildNeedsLayout(true);
-            if (isFloating() && !isPositioned() && newStyle->isPositioned())
+            if (isFloating() && !isOutOfFlowPositioned() && newStyle->isOutOfFlowPositioned())
                 removeFloatingOrPositionedChildFromBlockLists();
         }
     } else if (newStyle && isBody())
@@ -239,7 +239,7 @@ void RenderBox::styleDidChange(StyleDifference diff, const RenderStyle* oldStyle
         // Normally we can do optimized positioning layout for absolute/fixed positioned objects. There is one special case, however, which is
         // when the positioned object's margin-before is changed. In this case the parent has to get a layout in order to run margin collapsing
         // to determine the new static position.
-        if (isPositioned() && newStyle->hasStaticBlockPosition(isHorizontalWritingMode()) && oldStyle->marginBefore() != newStyle->marginBefore()
+        if (isOutOfFlowPositioned() && newStyle->hasStaticBlockPosition(isHorizontalWritingMode()) && oldStyle->marginBefore() != newStyle->marginBefore()
             && parent() && !parent()->normalChildNeedsLayout())
             parent()->setChildNeedsLayout(true);
     }
@@ -305,8 +305,8 @@ void RenderBox::updateBoxModelInfoFromStyle()
     if (isRootObject || isViewObject)
         setHasBoxDecorations(true);
 
-    setPositioned(styleToUse->isPositioned());
-    setFloating(!isPositioned() && styleToUse->isFloating());
+    setPositioned(styleToUse->isOutOfFlowPositioned());
+    setFloating(!isOutOfFlowPositioned() && styleToUse->isFloating());
 
     // We also handle <body> and <html>, whose overflow applies to the viewport.
     if (styleToUse->overflowX() != OVISIBLE && !isRootObject && (isRenderBlock() || isTableRow() || isTableSection())) {
@@ -1388,7 +1388,7 @@ LayoutSize RenderBox::offsetFromContainer(RenderObject* o, const LayoutPoint& po
         offset += relativePositionOffset();
 
     if (!isInline() || isReplaced()) {
-        if (!style()->isPositioned() && o->hasColumns()) {
+        if (!style()->isOutOfFlowPositioned() && o->hasColumns()) {
             RenderBlock* block = toRenderBlock(o);
             LayoutRect columnRect(frameRect());
             block->adjustStartEdgeForWritingModeIncludingColumns(columnRect);
@@ -1431,7 +1431,7 @@ void RenderBox::dirtyLineBoxes(bool fullLayout)
 
 void RenderBox::positionLineBox(InlineBox* box)
 {
-    if (isPositioned()) {
+    if (isOutOfFlowPositioned()) {
         // Cache the x position only if we were an INLINE type originally.
         bool wasInline = style()->isOriginalDisplayInlineType();
         if (wasInline) {
@@ -1546,7 +1546,7 @@ void RenderBox::computeRectForRepaint(RenderBoxModelObject* repaintContainer, La
     if (!o)
         return;
 
-    if (isWritingModeRoot() && !isPositioned())
+    if (isWritingModeRoot() && !isOutOfFlowPositioned())
         flipForWritingMode(rect);
 
     LayoutPoint topLeft = rect.location();
@@ -1637,7 +1637,7 @@ void RenderBox::computeLogicalWidth()
 
 void RenderBox::computeLogicalWidthInRegion(RenderRegion* region, LayoutUnit offsetFromLogicalTopOfFirstPage)
 {
-    if (isPositioned()) {
+    if (isOutOfFlowPositioned()) {
         // FIXME: This calculation is not patched for block-flow yet.
         // https://bugs.webkit.org/show_bug.cgi?id=46500
         computePositionedLogicalWidth(region, offsetFromLogicalTopOfFirstPage);
@@ -1917,10 +1917,10 @@ RenderBoxRegionInfo* RenderBox::renderBoxRegionInfo(RenderRegion* region, Layout
     LayoutUnit logicalWidthInRegion = logicalWidth();
     LayoutUnit logicalLeftInRegion = logicalLeft();
     LayoutUnit widthDelta = logicalWidthInRegion - oldLogicalWidth;
-    LayoutUnit logicalLeftDelta = isPositioned() ? logicalLeftInRegion - oldLogicalLeft : startMarginDelta;
+    LayoutUnit logicalLeftDelta = isOutOfFlowPositioned() ? logicalLeftInRegion - oldLogicalLeft : startMarginDelta;
     LayoutUnit logicalRightInRegion = containingBlockLogicalWidthInRegion - (logicalLeftInRegion + logicalWidthInRegion);
     LayoutUnit oldLogicalRight = containingBlockLogicalWidth - (oldLogicalLeft + oldLogicalWidth);
-    LayoutUnit logicalRightDelta = isPositioned() ? logicalRightInRegion - oldLogicalRight : startMarginDelta;
+    LayoutUnit logicalRightDelta = isOutOfFlowPositioned() ? logicalRightInRegion - oldLogicalRight : startMarginDelta;
 
     // Set our values back.
     mutableBox->setLogicalWidth(oldLogicalWidth);
@@ -1930,7 +1930,7 @@ RenderBoxRegionInfo* RenderBox::renderBoxRegionInfo(RenderRegion* region, Layout
 
     LayoutUnit logicalLeftOffset = 0;
     
-    if (!isPositioned() && avoidsFloats() && cb->containsFloats()) {
+    if (!isOutOfFlowPositioned() && avoidsFloats() && cb->containsFloats()) {
         LayoutUnit startPositionDelta = cb->computeStartPositionDeltaForChildAvoidingFloats(this, marginStartInRegion, region, offsetFromLogicalTopOfFirstPage);
         if (cb->style()->isLeftToRightDirection())
             logicalLeftDelta += startPositionDelta;
@@ -1961,7 +1961,7 @@ void RenderBox::computeLogicalHeight()
         return;
 
     Length h;
-    if (isPositioned())
+    if (isOutOfFlowPositioned())
         computePositionedLogicalHeight();
     else {
         RenderBlock* cb = containingBlock();
@@ -2093,7 +2093,7 @@ LayoutUnit RenderBox::computePercentageLogicalHeight(const Length& height)
     // only at explicit containers.
     bool skippedAutoHeightContainingBlock = false;
     RenderBlock* cb = containingBlock();
-    while (!cb->isRenderView() && !cb->isBody() && !cb->isTableCell() && !cb->isPositioned() && cb->style()->logicalHeight().isAuto()) {
+    while (!cb->isRenderView() && !cb->isBody() && !cb->isTableCell() && !cb->isOutOfFlowPositioned() && cb->style()->logicalHeight().isAuto()) {
         if (!document()->inQuirksMode() && !cb->isAnonymousBlock())
             break;
         skippedAutoHeightContainingBlock = true;
@@ -2107,7 +2107,7 @@ LayoutUnit RenderBox::computePercentageLogicalHeight(const Length& height)
     // explicitly specified that can be used for any percentage computations.
     // FIXME: We can't just check top/bottom here.
     // https://bugs.webkit.org/show_bug.cgi?id=46500
-    bool isPositionedWithSpecifiedHeight = cb->isPositioned() && (!cbstyle->logicalHeight().isAuto() || (!cbstyle->top().isAuto() && !cbstyle->bottom().isAuto()));
+    bool isOutOfFlowPositionedWithSpecifiedHeight = cb->isOutOfFlowPositioned() && (!cbstyle->logicalHeight().isAuto() || (!cbstyle->top().isAuto() && !cbstyle->bottom().isAuto()));
 
     bool includeBorderPadding = isTable();
 
@@ -2137,19 +2137,19 @@ LayoutUnit RenderBox::computePercentageLogicalHeight(const Length& height)
     // height.
     else if (cbstyle->logicalHeight().isFixed())
         result = cb->computeContentBoxLogicalHeight(cbstyle->logicalHeight().value());
-    else if (cbstyle->logicalHeight().isPercent() && !isPositionedWithSpecifiedHeight) {
+    else if (cbstyle->logicalHeight().isPercent() && !isOutOfFlowPositionedWithSpecifiedHeight) {
         // We need to recur and compute the percentage height for our containing block.
         result = cb->computePercentageLogicalHeight(cbstyle->logicalHeight());
         if (result != -1)
             result = cb->computeContentBoxLogicalHeight(result);
-    } else if (cb->isRenderView() || (cb->isBody() && document()->inQuirksMode()) || isPositionedWithSpecifiedHeight) {
+    } else if (cb->isRenderView() || (cb->isBody() && document()->inQuirksMode()) || isOutOfFlowPositionedWithSpecifiedHeight) {
         // Don't allow this to affect the block' height() member variable, since this
         // can get called while the block is still laying out its kids.
         LayoutUnit oldHeight = cb->logicalHeight();
         cb->computeLogicalHeight();
         result = cb->contentLogicalHeight();
         cb->setLogicalHeight(oldHeight);
-    } else if (cb->isRoot() && isPositioned())
+    } else if (cb->isRoot() && isOutOfFlowPositioned())
         // Match the positioned objects behavior, which is that positioned objects will fill their viewport
         // always.  Note we could only hit this case by recurring into computePercentageLogicalHeight on a positioned containing block.
         result = cb->computeContentBoxLogicalHeight(cb->availableLogicalHeight());
@@ -2193,7 +2193,7 @@ LayoutUnit RenderBox::computeReplacedLogicalWidthUsing(Length logicalWidth) cons
             // FIXME: containingBlockLogicalWidthForContent() is wrong if the replaced element's block-flow is perpendicular to the
             // containing block's block-flow.
             // https://bugs.webkit.org/show_bug.cgi?id=46496
-            const LayoutUnit cw = isPositioned() ? containingBlockLogicalWidthForPositioned(toRenderBoxModelObject(container())) : containingBlockLogicalWidthForContent();
+            const LayoutUnit cw = isOutOfFlowPositioned() ? containingBlockLogicalWidthForPositioned(toRenderBoxModelObject(container())) : containingBlockLogicalWidthForContent();
             if (cw > 0)
                 return computeContentBoxLogicalWidth(minimumValueForLength(logicalWidth, cw));
         }
@@ -2223,7 +2223,7 @@ LayoutUnit RenderBox::computeReplacedLogicalHeightUsing(Length logicalHeight) co
         case Percent:
         case Calculated:
         {
-            RenderObject* cb = isPositioned() ? container() : containingBlock();
+            RenderObject* cb = isOutOfFlowPositioned() ? container() : containingBlock();
             while (cb->isAnonymous()) {
                 cb = cb->containingBlock();
                 toRenderBlock(cb)->addPercentHeightDescendant(const_cast<RenderBox*>(this));
@@ -2231,7 +2231,7 @@ LayoutUnit RenderBox::computeReplacedLogicalHeightUsing(Length logicalHeight) co
 
             // FIXME: This calculation is not patched for block-flow yet.
             // https://bugs.webkit.org/show_bug.cgi?id=46500
-            if (cb->isPositioned() && cb->style()->height().isAuto() && !(cb->style()->top().isAuto() || cb->style()->bottom().isAuto())) {
+            if (cb->isOutOfFlowPositioned() && cb->style()->height().isAuto() && !(cb->style()->top().isAuto() || cb->style()->bottom().isAuto())) {
                 ASSERT(cb->isRenderBlock());
                 RenderBlock* block = toRenderBlock(cb);
                 LayoutUnit oldHeight = block->height();
@@ -2245,7 +2245,7 @@ LayoutUnit RenderBox::computeReplacedLogicalHeightUsing(Length logicalHeight) co
             // containing block's block-flow.
             // https://bugs.webkit.org/show_bug.cgi?id=46496
             LayoutUnit availableHeight;
-            if (isPositioned())
+            if (isOutOfFlowPositioned())
                 availableHeight = containingBlockLogicalHeightForPositioned(toRenderBoxModelObject(cb));
             else {
                 availableHeight =  toRenderBox(cb)->availableLogicalHeight();
@@ -2300,7 +2300,7 @@ LayoutUnit RenderBox::availableLogicalHeightUsing(const Length& h) const
         // https://bugs.webkit.org/show_bug.cgi?id=64046
         // For absolutely positioned elements whose containing block is based on a block-level element,
         // the percentage is calculated with respect to the height of the padding box of that element
-        if (isPositioned())
+        if (isOutOfFlowPositioned())
             availableHeight = containingBlockLogicalHeightForPositioned(containingBlock());
         else
             availableHeight = containingBlock()->availableLogicalHeight();
@@ -2309,7 +2309,7 @@ LayoutUnit RenderBox::availableLogicalHeightUsing(const Length& h) const
 
     // FIXME: We can't just check top/bottom here.
     // https://bugs.webkit.org/show_bug.cgi?id=46500
-    if (isRenderBlock() && isPositioned() && style()->height().isAuto() && !(style()->top().isAuto() || style()->bottom().isAuto())) {
+    if (isRenderBlock() && isOutOfFlowPositioned() && style()->height().isAuto() && !(style()->top().isAuto() || style()->bottom().isAuto())) {
         RenderBlock* block = const_cast<RenderBlock*>(toRenderBlock(this));
         LayoutUnit oldHeight = block->logicalHeight();
         block->computeLogicalHeight();
@@ -3679,7 +3679,7 @@ static bool percentageLogicalHeightIsResolvable(const RenderBox* box)
     // block has an auto height. We still skip anonymous containing blocks in both modes, though, and look
     // only at explicit containers.
     const RenderBlock* cb = box->containingBlock();
-    while (!cb->isRenderView() && !cb->isBody() && !cb->isTableCell() && !cb->isPositioned() && cb->style()->logicalHeight().isAuto()) {
+    while (!cb->isRenderView() && !cb->isBody() && !cb->isTableCell() && !cb->isOutOfFlowPositioned() && cb->style()->logicalHeight().isAuto()) {
         if (!box->document()->inQuirksMode() && !cb->isAnonymousBlock())
             break;
         cb = cb->containingBlock();
@@ -3689,7 +3689,7 @@ static bool percentageLogicalHeightIsResolvable(const RenderBox* box)
     // explicitly specified that can be used for any percentage computations.
     // FIXME: We can't just check top/bottom here.
     // https://bugs.webkit.org/show_bug.cgi?id=46500
-    bool isPositionedWithSpecifiedHeight = cb->isPositioned() && (!cb->style()->logicalHeight().isAuto() || (!cb->style()->top().isAuto() && !cb->style()->bottom().isAuto()));
+    bool isOutOfFlowPositionedWithSpecifiedHeight = cb->isOutOfFlowPositioned() && (!cb->style()->logicalHeight().isAuto() || (!cb->style()->top().isAuto() && !cb->style()->bottom().isAuto()));
 
     // Table cells violate what the CSS spec says to do with heights.  Basically we
     // don't care if the cell specified a height or not.  We just always make ourselves
@@ -3701,11 +3701,11 @@ static bool percentageLogicalHeightIsResolvable(const RenderBox* box)
     // height.
     if (cb->style()->logicalHeight().isFixed())
         return true;
-    if (cb->style()->logicalHeight().isPercent() && !isPositionedWithSpecifiedHeight)
+    if (cb->style()->logicalHeight().isPercent() && !isOutOfFlowPositionedWithSpecifiedHeight)
         return percentageLogicalHeightIsResolvable(cb);
-    if (cb->isRenderView() || (cb->isBody() && box->document()->inQuirksMode()) || isPositionedWithSpecifiedHeight)
+    if (cb->isRenderView() || (cb->isBody() && box->document()->inQuirksMode()) || isOutOfFlowPositionedWithSpecifiedHeight)
         return true;
-    if (cb->isRoot() && box->isPositioned()) {
+    if (cb->isRoot() && box->isOutOfFlowPositioned()) {
         // Match the positioned objects behavior, which is that positioned objects will fill their viewport
         // always.  Note we could only hit this case by recurring into computePercentageLogicalHeight on a positioned containing block.
         return true;

@@ -42,7 +42,7 @@ public:
     RenderBox(Node*);
     virtual ~RenderBox();
 
-    virtual bool requiresLayer() const OVERRIDE { return isRoot() || isPositioned() || isRelPositioned() || isTransparent() || hasOverflowClip() || hasTransform() || hasHiddenBackface() || hasMask() || hasReflection() || hasFilter() || style()->specifiesColumns(); }
+    virtual bool requiresLayer() const OVERRIDE { return isRoot() || isOutOfFlowPositioned() || isRelPositioned() || isTransparent() || hasOverflowClip() || hasTransform() || hasHiddenBackface() || hasMask() || hasReflection() || hasFilter() || style()->specifiesColumns(); }
 
     // Use this with caution! No type checking is done!
     RenderBox* firstChildBox() const;
@@ -326,7 +326,7 @@ public:
 
     bool stretchesToViewport() const
     {
-        return document()->inQuirksMode() && style()->logicalHeight().isAuto() && !isFloatingOrPositioned() && (isRoot() || isBody()) && !document()->shouldDisplaySeamlesslyWithParent();
+        return document()->inQuirksMode() && style()->logicalHeight().isAuto() && !isFloatingOrOutOfFlowPositioned() && (isRoot() || isBody()) && !document()->shouldDisplaySeamlesslyWithParent();
     }
 
     virtual IntSize intrinsicSize() const { return IntSize(); }
@@ -427,7 +427,7 @@ public:
 
     bool isWritingModeRoot() const { return !parent() || parent()->style()->writingMode() != style()->writingMode(); }
 
-    bool isDeprecatedFlexItem() const { return !isInline() && !isFloatingOrPositioned() && parent() && parent()->isDeprecatedFlexibleBox(); }
+    bool isDeprecatedFlexItem() const { return !isInline() && !isFloatingOrOutOfFlowPositioned() && parent() && parent()->isDeprecatedFlexibleBox(); }
     
     virtual LayoutUnit lineHeight(bool firstLine, LineDirectionMode, LinePositionMode = PositionOnContainingLine) const;
     virtual LayoutUnit baselinePosition(FontBaseline, bool firstLine, LineDirectionMode, LinePositionMode = PositionOnContainingLine) const;

@@ -531,7 +531,7 @@ LayoutPoint RenderBoxModelObject::adjustedPositionRelativeToOffsetParent(const L
     if (const RenderBoxModelObject* offsetParent = this->offsetParent()) {
         if (offsetParent->isBox() && !offsetParent->isBody())
             referencePoint.move(-toRenderBox(offsetParent)->borderLeft(), -toRenderBox(offsetParent)->borderTop());
-        if (!isPositioned()) {
+        if (!isOutOfFlowPositioned()) {
             if (isRelPositioned())
                 referencePoint.move(relativePositionOffset());
             const RenderObject* curr = parent();
@@ -542,7 +542,7 @@ LayoutPoint RenderBoxModelObject::adjustedPositionRelativeToOffsetParent(const L
                 referencePoint.move(curr->parent()->offsetForColumns(referencePoint));
                 curr = curr->parent();
             }
-            if (offsetParent->isBox() && offsetParent->isBody() && !offsetParent->isRelPositioned() && !offsetParent->isPositioned())
+            if (offsetParent->isBox() && offsetParent->isBody() && !offsetParent->isRelPositioned() && !offsetParent->isOutOfFlowPositioned())
                 referencePoint.moveBy(toRenderBox(offsetParent)->topLeftLocation());
         }
     }
@@ -2740,7 +2740,7 @@ void RenderBoxModelObject::mapAbsoluteToLocalPoint(bool fixed, bool useTransform
 
     LayoutSize containerOffset = offsetFromContainer(o, LayoutPoint());
 
-    if (!style()->isPositioned() && o->hasColumns()) {
+    if (!style()->isOutOfFlowPositioned() && o->hasColumns()) {
         RenderBlock* block = static_cast<RenderBlock*>(o);
         LayoutPoint point(roundedLayoutPoint(transformState.mappedPoint()));
         point -= containerOffset;

@@ -79,7 +79,7 @@ public:
 
     bool hasSelfPaintingLayer() const;
     RenderLayer* layer() const { return m_layer; }
-    virtual bool requiresLayer() const { return isRoot() || isPositioned() || isRelPositioned() || isTransparent() || hasTransform() || hasHiddenBackface() || hasMask() || hasReflection() || hasFilter() || style()->specifiesColumns(); }
+    virtual bool requiresLayer() const { return isRoot() || isOutOfFlowPositioned() || isRelPositioned() || isTransparent() || hasTransform() || hasHiddenBackface() || hasMask() || hasReflection() || hasFilter() || style()->specifiesColumns(); }
 
     // This will work on inlines to return the bounding box of all of the lines' border boxes.
     virtual IntRect borderBoundingBox() const = 0;

@@ -147,7 +147,7 @@ static LayoutUnit marginWidthForChild(RenderBox* child)
 static bool childDoesNotAffectWidthOrFlexing(RenderObject* child)
 {
     // Positioned children and collapsed children don't affect the min/max width.
-    return child->isPositioned() || child->style()->visibility() == COLLAPSE;
+    return child->isOutOfFlowPositioned() || child->style()->visibility() == COLLAPSE;
 }
 
 void RenderDeprecatedFlexibleBox::styleWillChange(StyleDifference diff, const RenderStyle* newStyle)
@@ -285,7 +285,7 @@ void RenderDeprecatedFlexibleBox::layoutBlock(bool relayoutChildren, LayoutUnit)
 
     computeRegionRangeForBlock();
 
-    if (!isFloatingOrPositioned() && height() == 0) {
+    if (!isFloatingOrOutOfFlowPositioned() && height() == 0) {
         // We are a block with no border and padding and a computed height
         // of 0.  The CSS spec states that zero-height blocks collapse their margins
         // together.
@@ -382,7 +382,7 @@ void RenderDeprecatedFlexibleBox::layoutHorizontalBox(bool relayoutChildren)
             if (relayoutChildren || (child->isReplaced() && (child->style()->width().isPercent() || child->style()->height().isPercent())))
                 child->setChildNeedsLayout(true, MarkOnlyThis);
 
-            if (child->isPositioned())
+            if (child->isOutOfFlowPositioned())
                 continue;
 
             // Compute the child's vertical margins.
@@ -430,7 +430,7 @@ void RenderDeprecatedFlexibleBox::layoutHorizontalBox(bool relayoutChildren)
         // Now that our height is actually known, we can place our boxes.
         m_stretchingChildren = (style()->boxAlign() == BSTRETCH);
         for (RenderBox* child = iterator.first(); child; child = iterator.next()) {
-            if (child->isPositioned()) {
+            if (child->isOutOfFlowPositioned()) {
                 child->containingBlock()->insertPositionedObject(child);
                 RenderLayer* childLayer = child->layer();
                 childLayer->setStaticInlinePosition(xPos); // FIXME: Not right for regions.
@@ -440,7 +440,9 @@ void RenderDeprecatedFlexibleBox::layoutHorizontalBox(bool relayoutChildren)
                         child->setChildNeedsLayout(true, MarkOnlyThis);
                 }
                 continue;
-            } else if (child->style()->visibility() == COLLAPSE) {
+            }
+            
+            if (child->style()->visibility() == COLLAPSE) {
                 // visibility: collapsed children do not participate in our positioning.
                 // But we need to lay them down.
                 child->layoutIfNeeded();
@@ -671,7 +673,7 @@ void RenderDeprecatedFlexibleBox::layoutVerticalBox(bool relayoutChildren)
             if (!haveLineClamp && (relayoutChildren || (child->isReplaced() && (child->style()->width().isPercent() || child->style()->height().isPercent()))))
                 child->setChildNeedsLayout(true, MarkOnlyThis);
 
-            if (child->isPositioned()) {
+            if (child->isOutOfFlowPositioned()) {
                 child->containingBlock()->insertPositionedObject(child);
                 RenderLayer* childLayer = child->layer();
                 childLayer->setStaticInlinePosition(borderStart() + paddingStart()); // FIXME: Not right for regions.
@@ -681,7 +683,9 @@ void RenderDeprecatedFlexibleBox::layoutVerticalBox(bool relayoutChildren)
                         child->setChildNeedsLayout(true, MarkOnlyThis);
                 }
                 continue;
-            } else if (child->style()->visibility() == COLLAPSE) {
+            }
+            
+            if (child->style()->visibility() == COLLAPSE) {
                 // visibility: collapsed children do not participate in our positioning.
                 // But we need to lay them down.
                 child->layoutIfNeeded();
@@ -1078,7 +1082,7 @@ const char *RenderDeprecatedFlexibleBox::renderName() const
 {
     if (isFloating())
         return ""RenderDeprecatedFlexibleBox (floating)"";
-    if (isPositioned())
+    if (isOutOfFlowPositioned())
         return ""RenderDeprecatedFlexibleBox (positioned)"";
     if (isAnonymous())
         return ""RenderDeprecatedFlexibleBox (generated)"";

@@ -126,7 +126,7 @@ RenderObject* RenderFieldset::layoutSpecialExcludedChild(bool relayoutChildren)
 RenderBox* RenderFieldset::findLegend() const
 {
     for (RenderObject* legend = firstChild(); legend; legend = legend->nextSibling()) {
-        if (!legend->isFloatingOrPositioned() && legend->node() && (legend->node()->hasTagName(legendTag)))
+        if (!legend->isFloatingOrOutOfFlowPositioned() && legend->node() && (legend->node()->hasTagName(legendTag)))
             return toRenderBox(legend);
     }
     return 0;

@@ -161,7 +161,7 @@ void RenderFlexibleBox::computePreferredLogicalWidths()
         m_minPreferredLogicalWidth = m_maxPreferredLogicalWidth = 0;
 
         for (RenderBox* child = firstChildBox(); child; child = child->nextSiblingBox()) {
-            if (child->isPositioned())
+            if (child->isOutOfFlowPositioned())
                 continue;
 
             LayoutUnit margin = marginLogicalWidthForChild(child, style());
@@ -642,7 +642,7 @@ LayoutUnit RenderFlexibleBox::autoMarginOffsetInMainAxis(const OrderedFlexItemLi
     bool isHorizontal = isHorizontalFlow();
     for (size_t i = 0; i < children.size(); ++i) {
         RenderBox* child = children[i];
-        if (child->isPositioned())
+        if (child->isOutOfFlowPositioned())
             continue;
         if (isHorizontal) {
             if (child->style()->marginLeft().isAuto())
@@ -689,7 +689,7 @@ bool RenderFlexibleBox::hasAutoMarginsInCrossAxis(RenderBox* child)
 LayoutUnit RenderFlexibleBox::availableAlignmentSpaceForChild(LayoutUnit lineCrossAxisExtent, RenderBox* child)
 {
     LayoutUnit childCrossExtent = 0;
-    if (!child->isPositioned())
+    if (!child->isOutOfFlowPositioned())
         childCrossExtent = crossAxisMarginExtentForChild(child) + crossAxisExtentForChild(child);
     return lineCrossAxisExtent - childCrossExtent;
 }
@@ -743,7 +743,7 @@ void RenderFlexibleBox::computeMainAxisPreferredSizes(bool relayoutChildren, Ord
     for (RenderBox* child = firstChildBox(); child; child = child->nextSiblingBox()) {
         orderValues.add(child->style()->order());
 
-        if (child->isPositioned())
+        if (child->isOutOfFlowPositioned())
             continue;
 
         child->clearOverrideSize();
@@ -808,7 +808,7 @@ bool RenderFlexibleBox::computeNextFlexLine(OrderIterator& iterator, OrderedFlex
     LayoutUnit lineBreak = lineBreakLength();
 
     for (RenderBox* child = iterator.currentChild(); child; child = iterator.next()) {
-        if (child->isPositioned()) {
+        if (child->isOutOfFlowPositioned()) {
             orderedChildren.append(child);
             continue;
         }
@@ -854,7 +854,7 @@ bool RenderFlexibleBox::resolveFlexibleLengths(FlexSign flexSign, const OrderedF
     WTF::Vector<Violation> maxViolations;
     for (size_t i = 0; i < children.size(); ++i) {
         RenderBox* child = children[i];
-        if (child->isPositioned()) {
+        if (child->isOutOfFlowPositioned()) {
             childSizes.append(0);
             continue;
         }
@@ -926,7 +926,7 @@ void RenderFlexibleBox::setLogicalOverrideSize(RenderBox* child, LayoutUnit chil
 
 void RenderFlexibleBox::prepareChildForPositionedLayout(RenderBox* child, LayoutUnit mainAxisOffset, LayoutUnit crossAxisOffset, PositionedLayoutMode layoutMode)
 {
-    ASSERT(child->isPositioned());
+    ASSERT(child->isOutOfFlowPositioned());
     child->containingBlock()->insertPositionedObject(child);
     RenderLayer* childLayer = child->layer();
     LayoutUnit inlinePosition = isColumnFlow() ? crossAxisOffset : mainAxisOffset;
@@ -974,7 +974,7 @@ void RenderFlexibleBox::layoutAndPlaceChildren(LayoutUnit& crossAxisOffset, cons
     bool shouldFlipMainAxis = !isColumnFlow() && !isLeftToRightFlow();
     for (size_t i = 0; i < children.size(); ++i) {
         RenderBox* child = children[i];
-        if (child->isPositioned()) {
+        if (child->isOutOfFlowPositioned()) {
             prepareChildForPositionedLayout(child, mainAxisOffset, crossAxisOffset, FlipForRowReverse);
             mainAxisOffset += justifyContentSpaceBetweenChildren(availableFreeSpace, style()->justifyContent(), childSizes.size());
             continue;
@@ -1040,7 +1040,7 @@ void RenderFlexibleBox::layoutColumnReverse(const OrderedFlexItemList& children,
 
     for (size_t i = 0; i < children.size(); ++i) {
         RenderBox* child = children[i];
-        if (child->isPositioned()) {
+        if (child->isOutOfFlowPositioned()) {
             child->layer()->setStaticBlockPosition(mainAxisOffset);
             mainAxisOffset -= justifyContentSpaceBetweenChildren(availableFreeSpace, style()->justifyContent(), childSizes.size());
             continue;
@@ -1108,7 +1108,7 @@ void RenderFlexibleBox::alignFlexLines(OrderIterator& iterator, WTF::Vector<Line
 
 void RenderFlexibleBox::adjustAlignmentForChild(RenderBox* child, LayoutUnit delta)
 {
-    if (child->isPositioned()) {
+    if (child->isOutOfFlowPositioned()) {
         LayoutUnit staticInlinePosition = child->layer()->staticInlinePosition();
         LayoutUnit staticBlockPosition = child->layer()->staticBlockPosition();
         LayoutUnit mainAxis = isColumnFlow() ? staticBlockPosition : staticInlinePosition;
@@ -1227,7 +1227,7 @@ void RenderFlexibleBox::flipForRightToLeftColumn(OrderIterator& iterator)
 
     LayoutUnit crossExtent = crossAxisExtent();
     for (RenderBox* child = iterator.first(); child; child = iterator.next()) {
-        if (child->isPositioned())
+        if (child->isOutOfFlowPositioned())
             continue;
         LayoutPoint location = flowAwareLocationForChild(child);
         location.setY(crossExtent - crossAxisExtentForChild(child) - location.y());

@@ -50,7 +50,7 @@ const char* RenderGrid::renderName() const
 {
     if (isFloating())
         return ""RenderGrid (floating)"";
-    if (isPositioned())
+    if (isOutOfFlowPositioned())
         return ""RenderGrid (positioned)"";
     if (isAnonymous())
         return ""RenderGrid (generated)"";

@@ -535,7 +535,7 @@ void RenderImage::computeIntrinsicRatioInformation(FloatSize& intrinsicSize, dou
 
     // Our intrinsicSize is empty if we're rendering generated images with relative width/height. Figure out the right intrinsic size to use.
     if (intrinsicSize.isEmpty() && (m_imageResource->imageHasRelativeWidth() || m_imageResource->imageHasRelativeHeight())) {
-        RenderObject* containingBlock = isPositioned() ? container() : this->containingBlock();
+        RenderObject* containingBlock = isOutOfFlowPositioned() ? container() : this->containingBlock();
         if (containingBlock->isBox()) {
             RenderBox* box = toRenderBox(containingBlock);
             intrinsicSize.setWidth(box->availableLogicalWidth());

@@ -302,7 +302,7 @@ void RenderInline::addChildIgnoringContinuation(RenderObject* newChild, RenderOb
     if (!beforeChild && isAfterContent(lastChild()))
         beforeChild = lastChild();
 
-    if (!newChild->isInline() && !newChild->isFloatingOrPositioned()) {
+    if (!newChild->isInline() && !newChild->isFloatingOrOutOfFlowPositioned()) {
         // We are placing a block inside an inline. We have to perform a split of this
         // inline into continuations.  This involves creating an anonymous block box to hold
         // |newChild|.  We then make that block box a continuation of this inline.  We take all of
@@ -504,7 +504,7 @@ void RenderInline::addChildToContinuation(RenderObject* newChild, RenderObject*
             beforeChildParent = flow;
     }
 
-    if (newChild->isFloatingOrPositioned())
+    if (newChild->isFloatingOrOutOfFlowPositioned())
         return beforeChildParent->addChildIgnoringContinuation(newChild, beforeChild);
 
     // A continuation always consists of two potential candidates: an inline or an anonymous
@@ -555,7 +555,7 @@ void RenderInline::generateCulledLineBoxRects(GeneratorContext yield, const Rend
     bool isHorizontal = style()->isHorizontalWritingMode();
 
     for (RenderObject* curr = firstChild(); curr; curr = curr->nextSibling()) {
-        if (curr->isFloatingOrPositioned())
+        if (curr->isFloatingOrOutOfFlowPositioned())
             continue;
             
         // We want to get the margin box in the inline direction, and then use our font ascent/descent in the block
@@ -837,7 +837,7 @@ IntRect RenderInline::linesBoundingBox() const
 InlineBox* RenderInline::culledInlineFirstLineBox() const
 {
     for (RenderObject* curr = firstChild(); curr; curr = curr->nextSibling()) {
-        if (curr->isFloatingOrPositioned())
+        if (curr->isFloatingOrOutOfFlowPositioned())
             continue;
             
         // We want to get the margin box in the inline direction, and then use our font ascent/descent in the block
@@ -861,7 +861,7 @@ InlineBox* RenderInline::culledInlineFirstLineBox() const
 InlineBox* RenderInline::culledInlineLastLineBox() const
 {
     for (RenderObject* curr = lastChild(); curr; curr = curr->previousSibling()) {
-        if (curr->isFloatingOrPositioned())
+        if (curr->isFloatingOrOutOfFlowPositioned())
             continue;
             
         // We want to get the margin box in the inline direction, and then use our font ascent/descent in the block
@@ -889,7 +889,7 @@ LayoutRect RenderInline::culledInlineVisualOverflowBoundingBox() const
     LayoutRect result(enclosingLayoutRect(floatResult));
     bool isHorizontal = style()->isHorizontalWritingMode();
     for (RenderObject* curr = firstChild(); curr; curr = curr->nextSibling()) {
-        if (curr->isFloatingOrPositioned())
+        if (curr->isFloatingOrOutOfFlowPositioned())
             continue;
             
         // For overflow we just have to propagate by hand and recompute it all.
@@ -1044,7 +1044,7 @@ void RenderInline::computeRectForRepaint(RenderBoxModelObject* repaintContainer,
 
     LayoutPoint topLeft = rect.location();
 
-    if (o->isBlockFlow() && !style()->isPositioned()) {
+    if (o->isBlockFlow() && !style()->isOutOfFlowPositioned()) {
         RenderBlock* cb = toRenderBlock(o);
         if (cb->hasColumns()) {
             LayoutRect repaintRect(topLeft, rect.size());
@@ -1243,7 +1243,7 @@ void RenderInline::dirtyLineBoxes(bool fullLayout)
     if (!alwaysCreateLineBoxes()) {
         // We have to grovel into our children in order to dirty the appropriate lines.
         for (RenderObject* curr = firstChild(); curr; curr = curr->nextSibling()) {
-            if (curr->isFloatingOrPositioned())
+            if (curr->isFloatingOrOutOfFlowPositioned())
                 continue;
             if (curr->isBox() && !curr->needsLayout()) {
                 RenderBox* currBox = toRenderBox(curr);

@@ -606,7 +606,7 @@ static bool checkContainingBlockChainForPagination(RenderBoxModelObject* rendere
         return false;
         
     // If the previous block is absolutely positioned, then we can't be paginated by the columns block.
-    if (prevBlock->isPositioned())
+    if (prevBlock->isOutOfFlowPositioned())
         return false;
         
     // Otherwise we are paginated by the columns block.
@@ -807,7 +807,7 @@ void RenderLayer::updateLayerPosition()
     // Clear our cached clip rect information.
     clearClipRects();
  
-    if (!renderer()->isPositioned() && renderer()->parent()) {
+    if (!renderer()->isOutOfFlowPositioned() && renderer()->parent()) {
         // We must adjust our position by walking up the render tree looking for the
         // nearest enclosing object with a layer.
         RenderObject* curr = renderer()->parent();
@@ -826,14 +826,14 @@ void RenderLayer::updateLayerPosition()
     }
     
     // Subtract our parent's scroll offset.
-    if (renderer()->isPositioned() && enclosingPositionedAncestor()) {
+    if (renderer()->isOutOfFlowPositioned() && enclosingPositionedAncestor()) {
         RenderLayer* positionedParent = enclosingPositionedAncestor();
 
         // For positioned layers, we subtract out the enclosing positioned layer's scroll offset.
         LayoutSize offset = positionedParent->scrolledContentOffset();
         localPoint -= offset;
         
-        if (renderer()->isPositioned() && positionedParent->renderer()->isRelPositioned() && positionedParent->renderer()->isRenderInline()) {
+        if (renderer()->isOutOfFlowPositioned() && positionedParent->renderer()->isRelPositioned() && positionedParent->renderer()->isRenderInline()) {
             LayoutSize offset = toRenderInline(positionedParent->renderer())->relativePositionedInlineOffset(toRenderBox(renderer()));
             localPoint += offset;
         }
@@ -915,7 +915,7 @@ RenderLayer* RenderLayer::stackingContext() const
 static inline bool isPositionedContainer(RenderLayer* layer)
 {
     RenderBoxModelObject* layerRenderer = layer->renderer();
-    return layer->isRootLayer() || layerRenderer->isPositioned() || layerRenderer->isRelPositioned() || layer->hasTransform();
+    return layer->isRootLayer() || layerRenderer->isOutOfFlowPositioned() || layerRenderer->isRelPositioned() || layer->hasTransform();
 }
 
 static inline bool isFixedPositionedContainer(RenderLayer* layer)
@@ -3905,7 +3905,7 @@ void RenderLayer::calculateClipRects(const RenderLayer* rootLayer, RenderRegion*
             if (renderer()->style()->hasBorderRadius())
                 newOverflowClip.setHasRadius(true);
             clipRects.setOverflowClipRect(intersection(newOverflowClip, clipRects.overflowClipRect()));
-            if (renderer()->isPositioned() || renderer()->isRelPositioned())
+            if (renderer()->isOutOfFlowPositioned() || renderer()->isRelPositioned())
                 clipRects.setPosClipRect(intersection(newOverflowClip, clipRects.posClipRect()));
         }
         if (renderer()->hasClip()) {
@@ -4701,7 +4701,7 @@ bool RenderLayer::shouldBeNormalFlowOnly() const
                 || renderer()->isApplet()
                 || renderer()->isRenderIFrame()
                 || renderer()->style()->specifiesColumns())
-            && !renderer()->isPositioned()
+            && !renderer()->isOutOfFlowPositioned()
             && !renderer()->isRelPositioned()
             && !renderer()->hasTransform()
 #if ENABLE(CSS_FILTERS)

@@ -1813,7 +1813,7 @@ bool RenderLayerCompositor::requiresCompositingForPosition(RenderObject* rendere
     // position:fixed elements that create their own stacking context (e.g. have an explicit z-index,
     // opacity, transform) can get their own composited layer. A stacking context is required otherwise
     // z-index and clipping will be broken.
-    if (!(renderer->isPositioned() && renderer->style()->position() == FixedPosition && layer->isStackingContext()))
+    if (!(renderer->isOutOfFlowPositioned() && renderer->style()->position() == FixedPosition && layer->isStackingContext()))
         return false;
 
     if (Settings* settings = m_renderView->document()->settings())

@@ -334,7 +334,7 @@ void RenderLineBoxList::dirtyLinesFromChangedChild(RenderObject* container, Rend
     RootInlineBox* box = 0;
     RenderObject* curr = 0;
     for (curr = child->previousSibling(); curr; curr = curr->previousSibling()) {
-        if (curr->isFloatingOrPositioned())
+        if (curr->isFloatingOrOutOfFlowPositioned())
             continue;
 
         if (curr->isReplaced()) {

@@ -189,7 +189,7 @@ static RenderObject* getParentOfFirstLineBox(RenderBlock* curr, RenderObject* ma
         if (currChild->isInline() && (!currChild->isRenderInline() || curr->generatesLineBoxesForInlineChild(currChild)))
             return curr;
 
-        if (currChild->isFloating() || currChild->isPositioned())
+        if (currChild->isFloating() || currChild->isOutOfFlowPositioned())
             continue;
 
         if (currChild->isTable() || !currChild->isRenderBlock() || (currChild->isBox() && toRenderBox(currChild)->isWritingModeRoot()))

@@ -152,7 +152,7 @@ const char* RenderMultiColumnBlock::renderName() const
 {    
     if (isFloating())
         return ""RenderMultiColumnBlock (floating)"";
-    if (isPositioned())
+    if (isOutOfFlowPositioned())
         return ""RenderMultiColumnBlock (positioned)"";
     if (isAnonymousBlock())
         return ""RenderMultiColumnBlock (anonymous)"";

@@ -641,7 +641,7 @@ void RenderObject::markContainingBlocksForLayout(bool scheduleRelayout, RenderOb
         RenderObject* container = object->container();
         if (!container && !object->isRenderView())
             return;
-        if (!last->isText() && last->style()->isPositioned()) {
+        if (!last->isText() && last->style()->isOutOfFlowPositioned()) {
             bool willSkipRelativelyPositionedInlines = !object->isRenderBlock() || object->isAnonymousBlock();
             // Skip relatively positioned inlines and anonymous blocks to get to the enclosing RenderBlock.
             while (object && (!object->isRenderBlock() || object->isAnonymousBlock()))
@@ -682,7 +682,7 @@ void RenderObject::setPreferredLogicalWidthsDirty(bool shouldBeDirty, MarkingBeh
 {
     bool alreadyDirty = preferredLogicalWidthsDirty();
     m_bitfields.setPreferredLogicalWidthsDirty(shouldBeDirty);
-    if (shouldBeDirty && !alreadyDirty && markParents == MarkContainingBlockChain && (isText() || !style()->isPositioned()))
+    if (shouldBeDirty && !alreadyDirty && markParents == MarkContainingBlockChain && (isText() || !style()->isOutOfFlowPositioned()))
         invalidateContainerPreferredLogicalWidths();
 }
 
@@ -699,7 +699,7 @@ void RenderObject::invalidateContainerPreferredLogicalWidths()
             break;
 
         o->m_bitfields.setPreferredLogicalWidthsDirty(true);
-        if (o->style()->isPositioned())
+        if (o->style()->isOutOfFlowPositioned())
             // A positioned object has no effect on the min/max width of its containing block ever.
             // We can optimize this case and not go up any further.
             break;
@@ -1806,13 +1806,13 @@ void RenderObject::styleWillChange(StyleDifference diff, const RenderStyle* newS
             // For changes in float styles, we need to conceivably remove ourselves
             // from the floating objects list.
             toRenderBox(this)->removeFloatingOrPositionedChildFromBlockLists();
-        else if (isPositioned() && (m_style->position() != newStyle->position()))
+        else if (isOutOfFlowPositioned() && (m_style->position() != newStyle->position()))
             // For changes in positioning styles, we need to conceivably remove ourselves
             // from the positioned objects list.
             toRenderBox(this)->removeFloatingOrPositionedChildFromBlockLists();
 
-        s_affectsParentBlock = isFloatingOrPositioned() &&
-            (!newStyle->isFloating() && newStyle->position() != AbsolutePosition && newStyle->position() != FixedPosition)
+        s_affectsParentBlock = isFloatingOrOutOfFlowPositioned()
+            && (!newStyle->isFloating() && newStyle->position() != AbsolutePosition && newStyle->position() != FixedPosition)
             && parent() && (parent()->isBlockFlow() || parent()->isRenderInline());
 
         // reset style flags
@@ -2747,7 +2747,7 @@ RenderBoxModelObject* RenderObject::offsetParent() const
     // A is the root element.
     // A is the HTML body element.
     // The computed value of the position property for element A is fixed.
-    if (isRoot() || isBody() || (isPositioned() && style()->position() == FixedPosition))
+    if (isRoot() || isBody() || (isOutOfFlowPositioned() && style()->position() == FixedPosition))
         return 0;
 
     // If A is an area HTML element which has a map HTML element somewhere in the ancestor
@@ -2762,10 +2762,10 @@ RenderBoxModelObject* RenderObject::offsetParent() const
     //       is one of the following HTML elements: td, th, or table.
     //     * Our own extension: if there is a difference in the effective zoom
 
-    bool skipTables = isPositioned() || isRelPositioned();
+    bool skipTables = isOutOfFlowPositioned() || isRelPositioned();
     float currZoom = style()->effectiveZoom();
     RenderObject* curr = parent();
-    while (curr && (!curr->node() || (!curr->isPositioned() && !curr->isRelPositioned() && !curr->isBody()))) {
+    while (curr && (!curr->node() || (!curr->isOutOfFlowPositioned() && !curr->isRelPositioned() && !curr->isBody()))) {
         Node* element = curr->node();
         if (!skipTables && element && (element->hasTagName(tableTag) || element->hasTagName(tdTag) || element->hasTagName(thTag)))
             break;

@@ -500,7 +500,8 @@ public:
     virtual RenderBoxModelObject* virtualContinuation() const { return 0; }
 
     bool isFloating() const { return m_bitfields.floating(); }
-    bool isPositioned() const { return m_bitfields.positioned(); } // absolute or fixed positioning
+    bool isOutOfFlowPositioned() const { return m_bitfields.positioned(); } // absolute or fixed positioning
+    bool isInFlowPositioned() const { return m_bitfields.relPositioned(); } // relative positioning
     bool isRelPositioned() const { return m_bitfields.relPositioned(); } // relative positioning
     bool isText() const  { return m_bitfields.isText(); }
     bool isBox() const { return m_bitfields.isBox(); }
@@ -538,7 +539,7 @@ public:
 
     bool isSelectionBorder() const;
 
-    bool hasClip() const { return isPositioned() && style()->hasClip(); }
+    bool hasClip() const { return isOutOfFlowPositioned() && style()->hasClip(); }
     bool hasOverflowClip() const { return m_bitfields.hasOverflowClip(); }
 
     bool hasTransform() const { return m_bitfields.hasTransform(); }
@@ -780,7 +781,7 @@ public:
 
     virtual unsigned int length() const { return 1; }
 
-    bool isFloatingOrPositioned() const { return (isFloating() || isPositioned()); }
+    bool isFloatingOrOutOfFlowPositioned() const { return (isFloating() || isOutOfFlowPositioned()); }
 
     bool isTransparent() const { return style()->opacity() < 1.0f; }
     float opacity() const { return style()->opacity(); }

@@ -75,7 +75,7 @@ RenderObject* RenderObjectChildList::removeChildNode(RenderObject* owner, Render
 {
     ASSERT(oldChild->parent() == owner);
 
-    if (oldChild->isFloatingOrPositioned())
+    if (oldChild->isFloatingOrOutOfFlowPositioned())
         toRenderBox(oldChild)->removeFloatingOrPositionedChildFromBlockLists();
 
     // So that we'll get the appropriate dirty bit set (either that a normal flow child got yanked or
@@ -111,7 +111,7 @@ RenderObject* RenderObjectChildList::removeChildNode(RenderObject* owner, Render
         if (oldChild->isListItem())
             toRenderListItem(oldChild)->updateListMarkerNumbers();
 
-        if (oldChild->isPositioned() && owner->childrenInline())
+        if (oldChild->isOutOfFlowPositioned() && owner->childrenInline())
             owner->dirtyLinesFromChangedChild(oldChild);
 
         if (oldChild->isRenderRegion())

@@ -238,7 +238,7 @@ static inline bool hasAutoHeightOrContainingBlockWithAutoHeight(const RenderRepl
     // For percentage heights: The percentage is calculated with respect to the height of the generated box's
     // containing block. If the height of the containing block is not specified explicitly (i.e., it depends
     // on content height), and this element is not absolutely positioned, the value computes to 'auto'.
-    if (!logicalHeightLength.isPercent() || replaced->isPositioned() || replaced->document()->inQuirksMode())
+    if (!logicalHeightLength.isPercent() || replaced->isOutOfFlowPositioned() || replaced->document()->inQuirksMode())
         return false;
 
     for (RenderBlock* cb = replaced->containingBlock(); !cb->isRenderView(); cb = cb->containingBlock()) {

@@ -76,7 +76,7 @@ RenderRubyText* RenderRubyRun::rubyText() const
     RenderObject* child = firstChild();
     // If in future it becomes necessary to support floating or positioned ruby text,
     // layout will have to be changed to handle them properly.
-    ASSERT(!child || !child->isRubyText() || !child->isFloatingOrPositioned());
+    ASSERT(!child || !child->isRubyText() || !child->isFloatingOrOutOfFlowPositioned());
     return child && child->isRubyText() ? static_cast<RenderRubyText*>(child) : 0;
 }
 

@@ -114,7 +114,7 @@ void RenderTable::addChild(RenderObject* child, RenderObject* beforeChild)
     if (!beforeChild)
         beforeChild = afterPseudoElementRenderer();
 
-    bool wrapInAnonymousSection = !child->isPositioned();
+    bool wrapInAnonymousSection = !child->isOutOfFlowPositioned();
 
     if (child->isTableCaption()) {
         m_captions.append(toRenderTableCaption(child));
@@ -213,7 +213,7 @@ void RenderTable::computeLogicalWidth()
 {
     recalcSectionsIfNeeded();
 
-    if (isPositioned())
+    if (isOutOfFlowPositioned())
         computePositionedLogicalWidth();
 
     RenderBlock* cb = containingBlock();
@@ -390,7 +390,7 @@ void RenderTable::layout()
 
     setLogicalHeight(logicalHeight() + borderAndPaddingBefore);
 
-    if (!isPositioned())
+    if (!isOutOfFlowPositioned())
         computeLogicalHeight();
 
     Length logicalHeightLength = style()->logicalHeight();
@@ -439,7 +439,7 @@ void RenderTable::layout()
         layoutCaption(m_captions[i]);
     }
 
-    if (isPositioned())
+    if (isOutOfFlowPositioned())
         computeLogicalHeight();
 
     // table can be containing block of positioned elements.

@@ -521,7 +521,7 @@ public:
     bool hasStaticBlockPosition(bool horizontal) const { return horizontal ? hasAutoTopAndBottom() : hasAutoLeftAndRight(); }
 
     EPosition position() const { return static_cast<EPosition>(noninherited_flags._position); }
-    bool isPositioned() const { return position() == AbsolutePosition || position() == FixedPosition; }
+    bool isOutOfFlowPositioned() const { return position() == AbsolutePosition || position() == FixedPosition; }
     EFloat floating() const { return static_cast<EFloat>(noninherited_flags._floating); }
 
     Length width() const { return m_box->width(); }

@@ -2506,7 +2506,7 @@ typedef bool (*PredicateFunction)(RenderLayer*);
 static bool isPositionedContainer(RenderLayer* layer)
 {
     RenderObject* o = layer->renderer();
-    return o->isRenderView() || o->isPositioned() || o->isRelPositioned() || layer->hasTransform();
+    return o->isRenderView() || o->isOutOfFlowPositioned() || o->isRelPositioned() || layer->hasTransform();
 }
 
 static bool isNonRenderViewFixedPositionedContainer(RenderLayer* layer)
@@ -2515,13 +2515,13 @@ static bool isNonRenderViewFixedPositionedContainer(RenderLayer* layer)
     if (o->isRenderView())
         return false;
 
-    return o->isPositioned() && o->style()->position() == FixedPosition;
+    return o->isOutOfFlowPositioned() && o->style()->position() == FixedPosition;
 }
 
 static bool isFixedPositionedContainer(RenderLayer* layer)
 {
     RenderObject* o = layer->renderer();
-    return o->isRenderView() || (o->isPositioned() && o->style()->position() == FixedPosition);
+    return o->isRenderView() || (o->isOutOfFlowPositioned() && o->style()->position() == FixedPosition);
 }
 
 static RenderLayer* findAncestorOrSelfNotMatching(PredicateFunction predicate, RenderLayer* layer)

@@ -297,7 +297,7 @@ static void updateOffsetFromViewportForSelf(RenderLayer* renderLayer)
     if (!style)
         return;
 
-    if (!renderLayer->renderer()->isPositioned() || renderLayer->renderer()->style()->position() != FixedPosition)
+    if (!renderLayer->renderer()->isOutOfFlowPositioned() || renderLayer->renderer()->style()->position() != FixedPosition)
         return;
 
     if (!renderLayer->renderer()->container()->isRenderView())
",0,Rename isPositioned to isOutOfFlowPositioned for clarity
01e5e97026cf0b344abafca22b0336a2c58b2a33,"@@ -111,8 +111,7 @@ read_header:
     av_log(avctx, AV_LOG_DEBUG, ""sod offs: 0x%x\n"", sod_offs);
     if (sos_offs)
     {
-//        init_get_bits(&s->gb, buf+sos_offs, (buf_end - (buf+sos_offs))*8);
-        init_get_bits(&s->gb, buf_ptr+sos_offs, field_size*8);
+        init_get_bits(&s->gb, buf_ptr+sos_offs, FFMIN(field_size, buf_end - (buf_ptr+sos_offs))*8);
         s->mjpb_skiptosod = (sod_offs - sos_offs - show_bits(&s->gb, 16));
         s->start_code = SOS;
         if (ff_mjpeg_decode_sos(s, NULL, NULL) < 0 &&
",0,mjpegbdec: Fix incorrect bitstream buffer size.
01f0e6a0c9270f1d5bef08459a6f167cf55e0596,"@@ -355,8 +355,11 @@ av_cold int ff_vc1_decode_init_alloc_tables(VC1Context *v)
     ff_intrax8_common_init(&v->x8,s);
 
     if (s->avctx->codec_id == AV_CODEC_ID_WMV3IMAGE || s->avctx->codec_id == AV_CODEC_ID_VC1IMAGE) {
-        for (i = 0; i < 4; i++)
-            if (!(v->sr_rows[i >> 1][i & 1] = av_malloc(v->output_width))) return -1;
+        for (i = 0; i < 4; i++) {
+            v->sr_rows[i >> 1][i & 1] = av_malloc(v->output_width);
+            if (!v->sr_rows[i >> 1][i & 1])
+                goto error;
+        }
     }
 
     if (!v->mv_type_mb_plane || !v->direct_mb_plane || !v->acpred_plane || !v->over_flags_plane ||
",0,vc1dec: Fix leak on error for array allocations
01f47e04fd7c8d54399c9e465f823f0017069f8f,"@@ -6018,7 +6018,8 @@ void Lua::setParamsTable(lua_State* vm, const char* table_name,
       char *_equal;
 
       if(strncmp(tok, ""csrf"", strlen(""csrf"")) /* Do not put csrf into the params table */
-	 && (_equal = strchr(tok, '='))) {
+	 && (_equal = strchr(tok, '='))
+	 && (strlen(_equal) > 1)) {
 	char *decoded_buf;
         int len;
 

@@ -2200,6 +2200,8 @@ Host* NetworkInterface::getHost(char *host_ip, u_int16_t vlan_id) {
   struct in6_addr a6;
   Host *h = NULL;
 
+  if(!host_ip) return(NULL);
+
   /* Check if address is invalid */
   if((inet_pton(AF_INET, (const char*)host_ip, &a4) == 0)
      && (inet_pton(AF_INET6, (const char*)host_ip, &a6) == 0)) {
",0,Security fix: prevents empty host from being used
01fe6b6076c5a90e1a5f100f67968fcada8daff8,"@@ -436,6 +436,37 @@ static void fdt_add_gic_node(VirtBoardInfo *vbi, int type)
     qemu_fdt_setprop_cell(vbi->fdt, ""/intc"", ""phandle"", vbi->gic_phandle);
 }
 
+static void fdt_add_pmu_nodes(const VirtBoardInfo *vbi, int gictype)
+{
+    CPUState *cpu;
+    ARMCPU *armcpu;
+    uint32_t irqflags = GIC_FDT_IRQ_FLAGS_LEVEL_HI;
+
+    CPU_FOREACH(cpu) {
+        armcpu = ARM_CPU(cpu);
+        if (!armcpu->has_pmu ||
+            !kvm_arm_pmu_create(cpu, PPI(VIRTUAL_PMU_IRQ))) {
+            return;
+        }
+    }
+
+    if (gictype == 2) {
+        irqflags = deposit32(irqflags, GIC_FDT_IRQ_PPI_CPU_START,
+                             GIC_FDT_IRQ_PPI_CPU_WIDTH,
+                             (1 << vbi->smp_cpus) - 1);
+    }
+
+    armcpu = ARM_CPU(qemu_get_cpu(0));
+    qemu_fdt_add_subnode(vbi->fdt, ""/pmu"");
+    if (arm_feature(&armcpu->env, ARM_FEATURE_V8)) {
+        const char compat[] = ""arm,armv8-pmuv3"";
+        qemu_fdt_setprop(vbi->fdt, ""/pmu"", ""compatible"",
+                         compat, sizeof(compat));
+        qemu_fdt_setprop_cells(vbi->fdt, ""/pmu"", ""interrupts"",
+                               GIC_FDT_IRQ_TYPE_PPI, VIRTUAL_PMU_IRQ, irqflags);
+    }
+}
+
 static void create_v2m(VirtBoardInfo *vbi, qemu_irq *pic)
 {
     int i;
@@ -1259,6 +1290,8 @@ static void machvirt_init(MachineState *machine)
 
     create_gic(vbi, pic, gic_version, vms->secure);
 
+    fdt_add_pmu_nodes(vbi, gic_version);
+
     create_uart(vbi, pic, VIRT_UART, sysmem, serial_hds[0]);
 
     if (vms->secure) {

@@ -522,3 +522,9 @@ bool kvm_arm_hw_debug_active(CPUState *cs)
 {
     return false;
 }
+
+int kvm_arm_pmu_create(CPUState *cs, int irq)
+{
+    qemu_log_mask(LOG_UNIMP, ""%s: not implemented\n"", __func__);
+    return 0;
+}

@@ -382,6 +382,47 @@ static CPUWatchpoint *find_hw_watchpoint(CPUState *cpu, target_ulong addr)
     return NULL;
 }
 
+static bool kvm_arm_pmu_support_ctrl(CPUState *cs, struct kvm_device_attr *attr)
+{
+    return kvm_vcpu_ioctl(cs, KVM_HAS_DEVICE_ATTR, attr) == 0;
+}
+
+int kvm_arm_pmu_create(CPUState *cs, int irq)
+{
+    int err;
+
+    struct kvm_device_attr attr = {
+        .group = KVM_ARM_VCPU_PMU_V3_CTRL,
+        .addr = (intptr_t)&irq,
+        .attr = KVM_ARM_VCPU_PMU_V3_IRQ,
+        .flags = 0,
+    };
+
+    if (!kvm_arm_pmu_support_ctrl(cs, &attr)) {
+        return 0;
+    }
+
+    err = kvm_vcpu_ioctl(cs, KVM_SET_DEVICE_ATTR, &attr);
+    if (err < 0) {
+        fprintf(stderr, ""KVM_SET_DEVICE_ATTR failed: %s\n"",
+                strerror(-err));
+        abort();
+    }
+
+    attr.group = KVM_ARM_VCPU_PMU_V3_CTRL;
+    attr.attr = KVM_ARM_VCPU_PMU_V3_INIT;
+    attr.addr = 0;
+    attr.flags = 0;
+
+    err = kvm_vcpu_ioctl(cs, KVM_SET_DEVICE_ATTR, &attr);
+    if (err < 0) {
+        fprintf(stderr, ""KVM_SET_DEVICE_ATTR failed: %s\n"",
+                strerror(-err));
+        abort();
+    }
+
+    return 1;
+}
 
 static inline void set_feature(uint64_t *features, int feature)
 {

@@ -194,6 +194,8 @@ int kvm_arm_sync_mpstate_to_qemu(ARMCPU *cpu);
 
 int kvm_arm_vgic_probe(void);
 
+int kvm_arm_pmu_create(CPUState *cs, int irq);
+
 #else
 
 static inline int kvm_arm_vgic_probe(void)
@@ -201,6 +203,11 @@ static inline int kvm_arm_vgic_probe(void)
     return 0;
 }
 
+static inline int kvm_arm_pmu_create(CPUState *cs, int irq)
+{
+    return 0;
+}
+
 #endif
 
 static inline const char *gic_class_name(void)
",0,hw/arm/virt: Add PMU node for virt machine
0208def1cadd4f72f862e62548c2af268a543b20,"@@ -151,6 +151,26 @@ void pci_bridge_write_config(PCIDevice *d,
     }
 }
 
+void pci_bridge_disable_base_limit(PCIDevice *dev)
+{
+    uint8_t *conf = dev->config;
+
+    pci_byte_test_and_set_mask(conf + PCI_IO_BASE,
+                               PCI_IO_RANGE_MASK & 0xff);
+    pci_byte_test_and_clear_mask(conf + PCI_IO_LIMIT,
+                                 PCI_IO_RANGE_MASK & 0xff);
+    pci_word_test_and_set_mask(conf + PCI_MEMORY_BASE,
+                               PCI_MEMORY_RANGE_MASK & 0xffff);
+    pci_word_test_and_clear_mask(conf + PCI_MEMORY_LIMIT,
+                                 PCI_MEMORY_RANGE_MASK & 0xffff);
+    pci_word_test_and_set_mask(conf + PCI_PREF_MEMORY_BASE,
+                               PCI_PREF_RANGE_MASK & 0xffff);
+    pci_word_test_and_clear_mask(conf + PCI_PREF_MEMORY_LIMIT,
+                                 PCI_PREF_RANGE_MASK & 0xffff);
+    pci_set_word(conf + PCI_PREF_BASE_UPPER32, 0);
+    pci_set_word(conf + PCI_PREF_LIMIT_UPPER32, 0);
+}
+
 /* reset bridge specific configuration registers */
 void pci_bridge_reset_reg(PCIDevice *dev)
 {
@@ -161,12 +181,28 @@ void pci_bridge_reset_reg(PCIDevice *dev)
     conf[PCI_SUBORDINATE_BUS] = 0;
     conf[PCI_SEC_LATENCY_TIMER] = 0;
 
-    conf[PCI_IO_BASE] = 0;
-    conf[PCI_IO_LIMIT] = 0;
-    pci_set_word(conf + PCI_MEMORY_BASE, 0);
-    pci_set_word(conf + PCI_MEMORY_LIMIT, 0);
-    pci_set_word(conf + PCI_PREF_MEMORY_BASE, 0);
-    pci_set_word(conf + PCI_PREF_MEMORY_LIMIT, 0);
+    /*
+     * the default values for base/limit registers aren't specified
+     * in the PCI-to-PCI-bridge spec. So we don't thouch them here.
+     * Each implementation can override it.
+     * typical implementation does
+     * zero base/limit registers or
+     * disable forwarding: pci_bridge_disable_base_limit()
+     * If disable forwarding is wanted, call pci_bridge_disable_base_limit()
+     * after this function.
+     */
+    pci_byte_test_and_clear_mask(conf + PCI_IO_BASE,
+                                 PCI_IO_RANGE_MASK & 0xff);
+    pci_byte_test_and_clear_mask(conf + PCI_IO_LIMIT,
+                                 PCI_IO_RANGE_MASK & 0xff);
+    pci_word_test_and_clear_mask(conf + PCI_MEMORY_BASE,
+                                 PCI_MEMORY_RANGE_MASK & 0xffff);
+    pci_word_test_and_clear_mask(conf + PCI_MEMORY_LIMIT,
+                                 PCI_MEMORY_RANGE_MASK & 0xffff);
+    pci_word_test_and_clear_mask(conf + PCI_PREF_MEMORY_BASE,
+                                 PCI_PREF_RANGE_MASK & 0xffff);
+    pci_word_test_and_clear_mask(conf + PCI_PREF_MEMORY_LIMIT,
+                                 PCI_PREF_RANGE_MASK & 0xffff);
     pci_set_word(conf + PCI_PREF_BASE_UPPER32, 0);
     pci_set_word(conf + PCI_PREF_LIMIT_UPPER32, 0);
 
",0,pci/bridge: fix pci_bridge_reset()
0220f39fac21d169a834ef91de362f4169f2eef5,"@@ -47,6 +47,7 @@ XSLStyleSheet::XSLStyleSheet(XSLImportRule* parentRule, const String& originalUR
     , m_processed(false) // Child sheets get marked as processed when the libxslt engine has finally seen them.
     , m_stylesheetDoc(0)
     , m_stylesheetDocTaken(false)
+    , m_compilationFailed(false)
     , m_parentStyleSheet(parentRule ? parentRule->parentStyleSheet() : 0)
 {
 }
@@ -60,6 +61,7 @@ XSLStyleSheet::XSLStyleSheet(Node* parentNode, const String& originalURL, const
     , m_processed(true) // The root sheet starts off processed.
     , m_stylesheetDoc(0)
     , m_stylesheetDocTaken(false)
+    , m_compilationFailed(false)
     , m_parentStyleSheet(0)
 {
 }
@@ -226,12 +228,19 @@ xsltStylesheetPtr XSLStyleSheet::compileStyleSheet()
     if (m_embedded)
         return xsltLoadStylesheetPI(document());
 
+    // Certain libxslt versions are corrupting the xmlDoc on compilation failures -
+    // hence attempting to recompile after a failure is unsafe.
+    if (m_compilationFailed)
+        return 0;
+
     // xsltParseStylesheetDoc makes the document part of the stylesheet
     // so we have to release our pointer to it.
     ASSERT(!m_stylesheetDocTaken);
     xsltStylesheetPtr result = xsltParseStylesheetDoc(m_stylesheetDoc);
     if (result)
         m_stylesheetDocTaken = true;
+    else
+        m_compilationFailed = true;
     return result;
 }
 
",0,Avoid reparsing an XSLT stylesheet after the first failure.
022d22e5810d1c90f618fddd751b1f03502d6021,"@@ -74,7 +74,8 @@ static int dca_find_frame_end(DCAParseContext * pc1, const uint8_t * buf,
             if (IS_MARKER(state, i, buf, buf_size) && (state == pc1->lastmarker || pc1->lastmarker == DCA_HD_MARKER)) {
                 if(pc1->framesize > pc1->size)
                     continue;
-                if(!pc1->framesize){
+                // We have to check that we really read a full frame here, and that it isn't a pure HD frame, because their size is not constant.
+                if(!pc1->framesize && state == pc1->lastmarker && state != DCA_HD_MARKER){
                     pc1->framesize = pc1->hd_pos ? pc1->hd_pos : pc1->size;
                 }
                 pc->frame_start_found = 0;
",0,Fix a regression in the dca parser introduced by dts express support.
0232f788b6b0855db1771dbf8d7174e2eda2ff45,"@@ -149,11 +149,11 @@ int swr_init(struct SwrContext *s){
     s->out_sample_fmt= av_get_alt_sample_fmt(s->out_sample_fmt, 0);
 
     if(s-> in_sample_fmt >= AV_SAMPLE_FMT_NB){
-        av_log(s, AV_LOG_ERROR, ""Requested sample format %s is invalid\n"", av_get_sample_fmt_name(s->in_sample_fmt));
+        av_log(s, AV_LOG_ERROR, ""Requested input sample format %d is invalid\n"", s->in_sample_fmt);
         return AVERROR(EINVAL);
     }
     if(s->out_sample_fmt >= AV_SAMPLE_FMT_NB){
-        av_log(s, AV_LOG_ERROR, ""Requested sample format %s is invalid\n"", av_get_sample_fmt_name(s->out_sample_fmt));
+        av_log(s, AV_LOG_ERROR, ""Requested output sample format %d is invalid\n"", s->out_sample_fmt);
         return AVERROR(EINVAL);
     }
 
",0,swr: fix invalid sample format message.
0247bdee2581a6857a24c5ff297f01d3a3112b11,"@@ -83,7 +83,8 @@ void av_log_default_callback(void* ptr, int level, const char* fmt, va_list vl)
 {
     static int print_prefix=1;
     static int count;
-    static char line[1024], prev[1024];
+    static char prev[1024];
+    char line[1024];
     static int is_atty;
     AVClass* avc= ptr ? *(AVClass**)ptr : NULL;
     if(level>av_log_level)
@@ -108,7 +109,7 @@ void av_log_default_callback(void* ptr, int level, const char* fmt, va_list vl)
     if(!is_atty) is_atty= isatty(2) ? 1 : -1;
 #endif
 
-    if(print_prefix && (flags & AV_LOG_SKIP_REPEATED) && !strcmp(line, prev)){
+    if(print_prefix && (flags & AV_LOG_SKIP_REPEATED) && !strncmp(line, prev, sizeof line)){
         count++;
         if(is_atty==1)
             fprintf(stderr, ""    Last message repeated %d times\r"", count);
@@ -119,7 +120,7 @@ void av_log_default_callback(void* ptr, int level, const char* fmt, va_list vl)
         count=0;
     }
     colored_fputs(av_clip(level>>3, 0, 6), line);
-    strcpy(prev, line);
+    strncpy(prev, line, sizeof line);
 }
 
 static void (*av_log_callback)(void*, int, const char*, va_list) = av_log_default_callback;
",0,Fix races in default av_log handler
02490bf3587d86a730e0de12572026504e2cb942,"@@ -826,7 +826,7 @@ static int rtmp_open(URLContext *s, const char *uri, int flags)
 
     rt->state = STATE_START;
     if (rtmp_handshake(s, rt))
-        return -1;
+        goto fail;
 
     rt->chunk_size = 128;
     rt->state = STATE_HANDSHAKED;
",0,rtmp: Clean up properly if the handshake failed
024e5bb664bda54b393e405f425f10fa9d3fbd1a,"@@ -156,7 +156,8 @@ typedef struct dp8393xState {
     int64_t wt_last_update;
     NICConf conf;
     NICState *nic;
-    int mmio_index;
+    MemoryRegion *address_space;
+    MemoryRegion mmio;
 
     /* Registers */
     uint8_t cam[16][6];
@@ -664,16 +665,12 @@ static void dp8393x_writel(void *opaque, target_phys_addr_t addr, uint32_t val)
     dp8393x_writew(opaque, addr + 2, (val >> 16) & 0xffff);
 }
 
-static CPUReadMemoryFunc * const dp8393x_read[3] = {
-    dp8393x_readb,
-    dp8393x_readw,
-    dp8393x_readl,
-};
-
-static CPUWriteMemoryFunc * const dp8393x_write[3] = {
-    dp8393x_writeb,
-    dp8393x_writew,
-    dp8393x_writel,
+static const MemoryRegionOps dp8393x_ops = {
+    .old_mmio = {
+        .read = { dp8393x_readb, dp8393x_readw, dp8393x_readl, },
+        .write = { dp8393x_writeb, dp8393x_writew, dp8393x_writel, },
+    },
+    .endianness = DEVICE_NATIVE_ENDIAN,
 };
 
 static int nic_can_receive(VLANClientState *nc)
@@ -865,7 +862,8 @@ static void nic_cleanup(VLANClientState *nc)
 {
     dp8393xState *s = DO_UPCAST(NICState, nc, nc)->opaque;
 
-    cpu_unregister_io_memory(s->mmio_index);
+    memory_region_del_subregion(s->address_space, &s->mmio);
+    memory_region_destroy(&s->mmio);
 
     qemu_del_timer(s->watchdog);
     qemu_free_timer(s->watchdog);
@@ -882,6 +880,7 @@ static NetClientInfo net_dp83932_info = {
 };
 
 void dp83932_init(NICInfo *nd, target_phys_addr_t base, int it_shift,
+                  MemoryRegion *address_space,
                   qemu_irq irq, void* mem_opaque,
                   void (*memory_rw)(void *opaque, target_phys_addr_t addr, uint8_t *buf, int len, int is_write))
 {
@@ -891,6 +890,7 @@ void dp83932_init(NICInfo *nd, target_phys_addr_t base, int it_shift,
 
     s = g_malloc0(sizeof(dp8393xState));
 
+    s->address_space = address_space;
     s->mem_opaque = mem_opaque;
     s->memory_rw = memory_rw;
     s->it_shift = it_shift;
@@ -908,7 +908,7 @@ void dp83932_init(NICInfo *nd, target_phys_addr_t base, int it_shift,
     qemu_register_reset(nic_reset, s);
     nic_reset(s);
 
-    s->mmio_index = cpu_register_io_memory(dp8393x_read, dp8393x_write, s,
-                                           DEVICE_NATIVE_ENDIAN);
-    cpu_register_physical_memory(base, 0x40 << it_shift, s->mmio_index);
+    memory_region_init_io(&s->mmio, &dp8393x_ops, s,
+                          ""dp8393x"", 0x40 << it_shift);
+    memory_region_add_subregion(address_space, base, &s->mmio);
 }

@@ -227,7 +227,7 @@ static void mips_jazz_init(MemoryRegion *address_space,
         if (!nd->model)
             nd->model = g_strdup(""dp83932"");
         if (strcmp(nd->model, ""dp83932"") == 0) {
-            dp83932_init(nd, 0x80001000, 2, rc4030[4],
+            dp83932_init(nd, 0x80001000, 2, get_system_memory(), rc4030[4],
                          rc4030_opaque, rc4030_dma_memory_rw);
             break;
         } else if (strcmp(nd->model, ""?"") == 0) {
",0,dp8393x: convert to memory API
02591641f88097aec2a573f0ae384c8b87bcfe3b,"@@ -83,6 +83,7 @@ typedef struct ShortenContext {
 
     int32_t *decoded[MAX_CHANNELS];
     int32_t *offset[MAX_CHANNELS];
+    int *coeffs;
     uint8_t *bitstream;
     int bitstream_size;
     int bitstream_index;
@@ -112,6 +113,8 @@ static av_cold int shorten_decode_init(AVCodecContext * avctx)
 static int allocate_buffers(ShortenContext *s)
 {
     int i, chan;
+    int *coeffs;
+
     for (chan=0; chan<s->channels; chan++) {
         if(FFMAX(1, s->nmean) >= UINT_MAX/sizeof(int32_t)){
             av_log(s->avctx, AV_LOG_ERROR, ""nmean too large\n"");
@@ -129,6 +132,12 @@ static int allocate_buffers(ShortenContext *s)
             s->decoded[chan][i] = 0;
         s->decoded[chan] += s->nwrap;
     }
+
+    coeffs = av_realloc(s->coeffs, s->nwrap * sizeof(*s->coeffs));
+    if (!coeffs)
+        return AVERROR(ENOMEM);
+    s->coeffs = coeffs;
+
     return 0;
 }
 
@@ -253,7 +262,7 @@ static int16_t * interleave_buffer(int16_t *samples, int nchan, int blocksize, i
 static void decode_subframe_lpc(ShortenContext *s, int channel, int residual_size, int pred_order)
 {
     int sum, i, j;
-    int coeffs[pred_order];
+    int *coeffs = s->coeffs;
 
     for (i=0; i<pred_order; i++)
         coeffs[i] = get_sr_golomb_shorten(&s->gb, LPCQUANT);
@@ -427,6 +436,12 @@ static int shorten_decode_frame(AVCodecContext *avctx,
                         case FN_QLPC:
                             {
                                 int pred_order = get_ur_golomb_shorten(&s->gb, LPCQSIZE);
+                                if (pred_order > s->nwrap) {
+                                    av_log(avctx, AV_LOG_ERROR,
+                                           ""invalid pred_order %d\n"",
+                                           pred_order);
+                                    return -1;
+                                }
                                 for (i=0; i<pred_order; i++)
                                     s->decoded[channel][i - pred_order] -= coffset;
                                 decode_subframe_lpc(s, channel, residual_size, pred_order);
@@ -515,6 +530,7 @@ static av_cold int shorten_decode_close(AVCodecContext *avctx)
         av_freep(&s->offset[i]);
     }
     av_freep(&s->bitstream);
+    av_freep(&s->coeffs);
     return 0;
 }
 
",0,shorten: remove VLA and check for buffer overflow
025b168ca674e42896c573fdbddf3090c6dc0d8f,"@@ -600,31 +600,37 @@ static int ehci_get_fetch_addr(EHCIState *s, int async)
 
 static void ehci_trace_qh(EHCIQueue *q, target_phys_addr_t addr, EHCIqh *qh)
 {
-    trace_usb_ehci_qh(q, addr, qh->next,
-                      qh->current_qtd, qh->next_qtd, qh->altnext_qtd,
-                      get_field(qh->epchar, QH_EPCHAR_RL),
-                      get_field(qh->epchar, QH_EPCHAR_MPLEN),
-                      get_field(qh->epchar, QH_EPCHAR_EPS),
-                      get_field(qh->epchar, QH_EPCHAR_EP),
-                      get_field(qh->epchar, QH_EPCHAR_DEVADDR),
-                      (bool)(qh->epchar & QH_EPCHAR_C),
-                      (bool)(qh->epchar & QH_EPCHAR_H),
-                      (bool)(qh->epchar & QH_EPCHAR_DTC),
-                      (bool)(qh->epchar & QH_EPCHAR_I));
+    /* need three here due to argument count limits */
+    trace_usb_ehci_qh_ptrs(q, addr, qh->next,
+                           qh->current_qtd, qh->next_qtd, qh->altnext_qtd);
+    trace_usb_ehci_qh_fields(addr,
+                             get_field(qh->epchar, QH_EPCHAR_RL),
+                             get_field(qh->epchar, QH_EPCHAR_MPLEN),
+                             get_field(qh->epchar, QH_EPCHAR_EPS),
+                             get_field(qh->epchar, QH_EPCHAR_EP),
+                             get_field(qh->epchar, QH_EPCHAR_DEVADDR));
+    trace_usb_ehci_qh_bits(addr,
+                           (bool)(qh->epchar & QH_EPCHAR_C),
+                           (bool)(qh->epchar & QH_EPCHAR_H),
+                           (bool)(qh->epchar & QH_EPCHAR_DTC),
+                           (bool)(qh->epchar & QH_EPCHAR_I));
 }
 
 static void ehci_trace_qtd(EHCIQueue *q, target_phys_addr_t addr, EHCIqtd *qtd)
 {
-    trace_usb_ehci_qtd(q, addr, qtd->next, qtd->altnext,
-                       get_field(qtd->token, QTD_TOKEN_TBYTES),
-                       get_field(qtd->token, QTD_TOKEN_CPAGE),
-                       get_field(qtd->token, QTD_TOKEN_CERR),
-                       get_field(qtd->token, QTD_TOKEN_PID),
-                       (bool)(qtd->token & QTD_TOKEN_IOC),
-                       (bool)(qtd->token & QTD_TOKEN_ACTIVE),
-                       (bool)(qtd->token & QTD_TOKEN_HALT),
-                       (bool)(qtd->token & QTD_TOKEN_BABBLE),
-                       (bool)(qtd->token & QTD_TOKEN_XACTERR));
+    /* need three here due to argument count limits */
+    trace_usb_ehci_qtd_ptrs(q, addr, qtd->next, qtd->altnext);
+    trace_usb_ehci_qtd_fields(addr,
+                              get_field(qtd->token, QTD_TOKEN_TBYTES),
+                              get_field(qtd->token, QTD_TOKEN_CPAGE),
+                              get_field(qtd->token, QTD_TOKEN_CERR),
+                              get_field(qtd->token, QTD_TOKEN_PID));
+    trace_usb_ehci_qtd_bits(addr,
+                            (bool)(qtd->token & QTD_TOKEN_IOC),
+                            (bool)(qtd->token & QTD_TOKEN_ACTIVE),
+                            (bool)(qtd->token & QTD_TOKEN_HALT),
+                            (bool)(qtd->token & QTD_TOKEN_BABBLE),
+                            (bool)(qtd->token & QTD_TOKEN_XACTERR));
 }
 
 static void ehci_trace_itd(EHCIState *s, target_phys_addr_t addr, EHCIitd *itd)
",0,usb-ehci: split trace calls to handle arg count limits
025fd76e1a2623c858d8c686a73cc30980a314b0,"@@ -135,7 +135,7 @@ static int dxtory_decode_v2(AVCodecContext *avctx, AVFrame *pic,
     if (!nslices || avctx->height % nslices) {
         avpriv_request_sample(avctx, ""%d slices for %dx%d"", nslices,
                               avctx->width, avctx->height);
-        return AVERROR(ENOSYS);
+        return AVERROR_PATCHWELCOME;
     }
 
     ref_slice_height = avctx->height / nslices;
",0,dxtory: change error code for unexpected slice configuration
02660a871301adada14b0e0fe64c66f73c2e4541,"@@ -961,18 +961,20 @@ static int decode_codestream(J2kDecoderContext *s)
 
 static int jp2_find_codestream(J2kDecoderContext *s)
 {
-    int32_t atom_size;
+    uint32_t atom_size;
     int found_codestream = 0, search_range = 10;
 
     // skip jpeg2k signature atom
     s->buf += 12;
 
-    while(!found_codestream && search_range) {
+    while(!found_codestream && search_range && s->buf_end - s->buf >= 8) {
         atom_size = AV_RB32(s->buf);
         if(AV_RB32(s->buf + 4) == JP2_CODESTREAM) {
             found_codestream = 1;
             s->buf += 8;
         } else {
+            if (s->buf_end - s->buf < atom_size)
+                return 0;
             s->buf += atom_size;
             search_range--;
         }
@@ -1005,7 +1007,8 @@ static int decode_frame(AVCodecContext *avctx,
         return AVERROR(EINVAL);
 
     // check if the image is in jp2 format
-    if((AV_RB32(s->buf) == 12) && (AV_RB32(s->buf + 4) == JP2_SIG_TYPE) &&
+    if(s->buf_end - s->buf >= 12 &&
+       (AV_RB32(s->buf) == 12) && (AV_RB32(s->buf + 4) == JP2_SIG_TYPE) &&
        (AV_RB32(s->buf + 8) == JP2_SIG_VALUE)) {
         if(!jp2_find_codestream(s)) {
             av_log(avctx, AV_LOG_ERROR, ""couldn't find jpeg2k codestream atom\n"");
",0,Check for out of bound reads in jpeg 2000 decoder.
027d9a7d2911e993cdcbd21c7c35d1dd058f05bb,"@@ -192,7 +192,7 @@ static inline tcg_target_ulong cpu_tb_exec(CPUState *cpu, TranslationBlock *itb)
         /* We were asked to stop executing TBs (probably a pending
          * interrupt. We've now stopped, so clear the flag.
          */
-        cpu->tcg_exit_req = 0;
+        atomic_set(&cpu->tcg_exit_req, 0);
     }
     return ret;
 }
@@ -490,8 +490,8 @@ static inline void cpu_handle_interrupt(CPUState *cpu,
             *last_tb = NULL;
         }
     }
-    if (unlikely(cpu->exit_request || replay_has_interrupt())) {
-        cpu->exit_request = 0;
+    if (unlikely(atomic_read(&cpu->exit_request) || replay_has_interrupt())) {
+        atomic_set(&cpu->exit_request, 0);
         cpu->exception_index = EXCP_INTERRUPT;
         cpu_loop_exit(cpu);
     }
@@ -503,7 +503,7 @@ static inline void cpu_loop_exec_tb(CPUState *cpu, TranslationBlock *tb,
 {
     uintptr_t ret;
 
-    if (unlikely(cpu->exit_request)) {
+    if (unlikely(atomic_read(&cpu->exit_request))) {
         return;
     }
 

@@ -120,10 +120,10 @@ void cpu_reset_interrupt(CPUState *cpu, int mask)
 
 void cpu_exit(CPUState *cpu)
 {
-    cpu->exit_request = 1;
+    atomic_set(&cpu->exit_request, 1);
     /* Ensure cpu_exec will see the exit request after TCG has exited.  */
     smp_wmb();
-    cpu->tcg_exit_req = 1;
+    atomic_set(&cpu->tcg_exit_req, 1);
 }
 
 int cpu_write_elf32_qemunote(WriteCoreDumpFunction f, CPUState *cpu,
",0,cpu: atomically modify cpu->exit_request
027ef6c87853b0a9df53175063028edb4950d476,"@@ -146,8 +146,7 @@ static inline unsigned long pmd_pfn(pmd_t pmd)
 
 static inline int pmd_large(pmd_t pte)
 {
-	return (pmd_flags(pte) & (_PAGE_PSE | _PAGE_PRESENT)) ==
-		(_PAGE_PSE | _PAGE_PRESENT);
+	return pmd_flags(pte) & _PAGE_PSE;
 }
 
 #ifdef CONFIG_TRANSPARENT_HUGEPAGE
@@ -415,7 +414,13 @@ static inline int pte_hidden(pte_t pte)
 
 static inline int pmd_present(pmd_t pmd)
 {
-	return pmd_flags(pmd) & _PAGE_PRESENT;
+	/*
+	 * Checking for _PAGE_PSE is needed too because
+	 * split_huge_page will temporarily clear the present bit (but
+	 * the _PAGE_PSE flag will remain set at all times while the
+	 * _PAGE_PRESENT bit is clear).
+	 */
+	return pmd_flags(pmd) & (_PAGE_PRESENT | _PAGE_PROTNONE | _PAGE_PSE);
 }
 
 static inline int pmd_none(pmd_t pmd)
",0,mm: thp: fix pmd_present for split_huge_page and PROT_NONE with THP
0281d32550639c806b7eccd2b17cc5d125e4253d,"@@ -391,7 +391,7 @@ static void fill_caches(H264Context *h, int mb_type, int for_deblock){
                 }
             }
 
-            if((for_deblock || (IS_DIRECT(mb_type) && !h->direct_spatial_mv_pred)) && !FRAME_MBAFF)
+            if(for_deblock || ((IS_DIRECT(mb_type) && !h->direct_spatial_mv_pred) && !FRAME_MBAFF))
                 continue;
 
             if(USES_LIST(topleft_type, list)){
",0,Do not execute the part of fill_caches() for the loopfilter that overwrites
028cc42a1638e6f93a857f11c2568d1c3a51e612,"@@ -817,7 +817,7 @@ static int avi_read_header(AVFormatContext *s)
 }
 
 static int read_gab2_sub(AVStream *st, AVPacket *pkt) {
-    if (!strcmp(pkt->data, ""GAB2"") && AV_RL16(pkt->data+5) == 2) {
+    if (pkt->data && !strcmp(pkt->data, ""GAB2"") && AV_RL16(pkt->data+5) == 2) {
         uint8_t desc[256];
         int score = AVPROBE_SCORE_MAX / 2, ret;
         AVIStream *ast = st->priv_data;
",0,read_gab2_sub: fix null pointer dereference
0290b57bdfec83ca78b6d119ea9847bb17943328,"@@ -1249,17 +1249,18 @@ void main_loop_wait(int nonblocking)
         IOHandlerRecord *pioh;
 
         QLIST_FOREACH_SAFE(ioh, &io_handlers, next, pioh) {
-            if (ioh->deleted) {
-                QLIST_REMOVE(ioh, next);
-                qemu_free(ioh);
-                continue;
-            }
-            if (ioh->fd_read && FD_ISSET(ioh->fd, &rfds)) {
+            if (!ioh->deleted && ioh->fd_read && FD_ISSET(ioh->fd, &rfds)) {
                 ioh->fd_read(ioh->opaque);
             }
-            if (ioh->fd_write && FD_ISSET(ioh->fd, &wfds)) {
+            if (!ioh->deleted && ioh->fd_write && FD_ISSET(ioh->fd, &wfds)) {
                 ioh->fd_write(ioh->opaque);
             }
+
+            /* Do this last in case read/write handlers marked it for deletion */
+            if (ioh->deleted) {
+                QLIST_REMOVE(ioh, next);
+                qemu_free(ioh);
+            }
         }
     }
 
",0,Delete IOHandlers after potentially running them
02a89b219039621c940863aa5a9da4fec81a1546,"@@ -104,6 +104,7 @@ static void pc_init1(ram_addr_t ram_size,
         pci_bus = i440fx_init(&i440fx_state, &piix3_devfn, isa_irq, ram_size);
     } else {
         pci_bus = NULL;
+        i440fx_state = NULL;
         isa_bus_new(NULL);
     }
     isa_bus_irqs(isa_irq);
",0,isapc: fix segfault.
02b33596d09bafed5d58366403a2d369f0d1047e,"@@ -1144,6 +1144,12 @@ static void dec_fpu(DisasContext *dc)
 
 static void dec_null(DisasContext *dc)
 {
+    if ((dc->tb_flags & MSR_EE_FLAG)
+          && (dc->env->pvr.regs[2] & PVR2_ILL_OPCODE_EXC_MASK)) {
+        tcg_gen_movi_tl(cpu_SR[SR_ESR], ESR_EC_ILLEGAL_OP);
+        t_gen_raise_exception(dc, EXCP_HW_EXCP);
+        return;
+    }
     qemu_log (""unknown insn pc=%x opc=%x\n"", dc->pc, dc->opcode);
     dc->abort_at_next_insn = 1;
 }
",0,microblaze: Trap if QEMU finds an unknown insns.
02ba9265e8d65f24d0cdca158d96e0b0451f6b71,"@@ -439,7 +439,7 @@ void *colo_process_incoming_thread(void *opaque)
     }
 
     while (mis->state == MIGRATION_STATUS_COLO) {
-        int request;
+        int request = 0;
 
         colo_wait_handle_message(mis->from_src_file, &request, &local_err);
         if (local_err) {
",0,migration: fix compiler warning on uninitialized variable
02c4f26b1517d9e403ec10d6f6ca3c0276d19e43,"@@ -131,7 +131,7 @@ static int bochs_open(BlockDriverState *bs, QDict *options, int flags,
         return -EFBIG;
     }
 
-    s->catalog_bitmap = g_try_malloc(s->catalog_size * 4);
+    s->catalog_bitmap = g_try_new(uint32_t, s->catalog_size);
     if (s->catalog_size && s->catalog_bitmap == NULL) {
         error_setg(errp, ""Could not allocate memory for catalog"");
         return -ENOMEM;

@@ -121,7 +121,7 @@ static int parallels_open(BlockDriverState *bs, QDict *options, int flags,
         ret = -EFBIG;
         goto fail;
     }
-    s->catalog_bitmap = g_try_malloc(s->catalog_size * 4);
+    s->catalog_bitmap = g_try_new(uint32_t, s->catalog_size);
     if (s->catalog_size && s->catalog_bitmap == NULL) {
         ret = -ENOMEM;
         goto fail;

@@ -50,7 +50,7 @@ Qcow2Cache *qcow2_cache_create(BlockDriverState *bs, int num_tables)
 
     c = g_malloc0(sizeof(*c));
     c->size = num_tables;
-    c->entries = g_malloc0(sizeof(*c->entries) * num_tables);
+    c->entries = g_new0(Qcow2CachedTable, num_tables);
 
     for (i = 0; i < c->size; i++) {
         c->entries[i].table = qemu_try_blockalign(bs->file, s->cluster_size);

@@ -227,8 +227,7 @@ int qed_check(BDRVQEDState *s, BdrvCheckResult *result, bool fix)
     };
     int ret;
 
-    check.used_clusters = g_try_malloc0(((check.nclusters + 31) / 32) *
-                                        sizeof(check.used_clusters[0]));
+    check.used_clusters = g_try_new0(uint32_t, (check.nclusters + 31) / 32);
     if (check.nclusters && check.used_clusters == NULL) {
         return -ENOMEM;
     }

@@ -862,7 +862,7 @@ static int qemu_rbd_snap_list(BlockDriverState *bs,
     int max_snaps = RBD_MAX_SNAPS;
 
     do {
-        snaps = g_malloc(sizeof(*snaps) * max_snaps);
+        snaps = g_new(rbd_snap_info_t, max_snaps);
         snap_count = rbd_snap_list(s->image, snaps, &max_snaps);
         if (snap_count <= 0) {
             g_free(snaps);

@@ -2357,7 +2357,7 @@ static int sd_snapshot_list(BlockDriverState *bs, QEMUSnapshotInfo **psn_tab)
         goto out;
     }
 
-    sn_tab = g_malloc0(nr * sizeof(*sn_tab));
+    sn_tab = g_new0(QEMUSnapshotInfo, nr);
 
     /* calculate a vdi id with hash function */
     hval = fnv_64a_buf(s->name, strlen(s->name), FNV1A_64_INIT);

@@ -319,7 +319,7 @@ static void nvme_init_sq(NvmeSQueue *sq, NvmeCtrl *n, uint64_t dma_addr,
     sq->size = size;
     sq->cqid = cqid;
     sq->head = sq->tail = 0;
-    sq->io_req = g_malloc(sq->size * sizeof(*sq->io_req));
+    sq->io_req = g_new(NvmeRequest, sq->size);
 
     QTAILQ_INIT(&sq->req_list);
     QTAILQ_INIT(&sq->out_req_list);
@@ -773,9 +773,9 @@ static int nvme_init(PCIDevice *pci_dev)
     n->reg_size = 1 << qemu_fls(0x1004 + 2 * (n->num_queues + 1) * 4);
     n->ns_size = bs_size / (uint64_t)n->num_namespaces;
 
-    n->namespaces = g_malloc0(sizeof(*n->namespaces)*n->num_namespaces);
-    n->sq = g_malloc0(sizeof(*n->sq)*n->num_queues);
-    n->cq = g_malloc0(sizeof(*n->cq)*n->num_queues);
+    n->namespaces = g_new0(NvmeNamespace, n->num_namespaces);
+    n->sq = g_new0(NvmeSQueue *, n->num_queues);
+    n->cq = g_new0(NvmeCQueue *, n->num_queues);
 
     memory_region_init_io(&n->iomem, OBJECT(n), &nvme_mmio_ops, n,
                           ""nvme"", n->reg_size);

@@ -29,7 +29,7 @@ static int compare_cmdname(const void *a, const void *b)
 
 void qemuio_add_command(const cmdinfo_t *ci)
 {
-    cmdtab = g_realloc(cmdtab, ++ncmds * sizeof(*cmdtab));
+    cmdtab = g_renew(cmdinfo_t, cmdtab, ++ncmds);
     cmdtab[ncmds - 1] = *ci;
     qsort(cmdtab, ncmds, sizeof(*cmdtab), compare_cmdname);
 }
@@ -122,7 +122,7 @@ static char **breakline(char *input, int *count)
             continue;
         }
         c++;
-        tmp = g_realloc(rval, sizeof(*rval) * (c + 1));
+        tmp = g_renew(char *, rval, (c + 1));
         if (!tmp) {
             g_free(rval);
             rval = NULL;
@@ -1264,9 +1264,9 @@ static int multiwrite_f(BlockDriverState *bs, int argc, char **argv)
         }
     }
 
-    reqs = g_malloc0(nr_reqs * sizeof(*reqs));
-    buf = g_malloc0(nr_reqs * sizeof(*buf));
-    qiovs = g_malloc(nr_reqs * sizeof(*qiovs));
+    reqs = g_new0(BlockRequest, nr_reqs);
+    buf = g_new0(char *, nr_reqs);
+    qiovs = g_new(QEMUIOVector, nr_reqs);
 
     for (i = 0; i < nr_reqs && optind < argc; i++) {
         int j;
",0,block: Use g_new() & friends to avoid multiplying sizes
02c8303512ebed345011f7b545e2f418799be2f0,"@@ -79,11 +79,11 @@ namespace {
 
 class CreateFileHelper FINAL : public AsyncFileSystemCallbacks {
 public:
-    class CreateFileResult : public RefCountedWillBeGarbageCollected<CreateFileResult> {
+    class CreateFileResult : public GarbageCollectedFinalized<CreateFileResult> {
       public:
-        static PassRefPtrWillBeRawPtr<CreateFileResult> create()
+        static CreateFileResult* create()
         {
-            return adoptRefWillBeNoop(new CreateFileResult());
+            return new CreateFileResult();
         }
 
         bool m_failed;
@@ -101,17 +101,9 @@ public:
             , m_code(0)
         {
         }
-
-#if !ENABLE(OILPAN)
-        ~CreateFileResult()
-        {
-        }
-#endif
-
-        friend class RefCountedWillBeGarbageCollected<CreateFileResult>;
     };
 
-    static PassOwnPtr<AsyncFileSystemCallbacks> create(PassRefPtrWillBeRawPtr<CreateFileResult> result, const String& name, const KURL& url, FileSystemType type)
+    static PassOwnPtr<AsyncFileSystemCallbacks> create(CreateFileResult* result, const String& name, const KURL& url, FileSystemType type)
     {
         return adoptPtr(static_cast<AsyncFileSystemCallbacks*>(new CreateFileHelper(result, name, url, type)));
     }
@@ -155,7 +147,7 @@ public:
     }
 
 private:
-    CreateFileHelper(PassRefPtrWillBeRawPtr<CreateFileResult> result, const String& name, const KURL& url, FileSystemType type)
+    CreateFileHelper(CreateFileResult* result, const String& name, const KURL& url, FileSystemType type)
         : m_result(result)
         , m_name(name)
         , m_url(url)
@@ -163,7 +155,7 @@ private:
     {
     }
 
-    RefPtrWillBePersistent<CreateFileResult> m_result;
+    Persistent<CreateFileResult> m_result;
     String m_name;
     KURL m_url;
     FileSystemType m_type;
@@ -174,7 +166,7 @@ private:
 PassRefPtrWillBeRawPtr<File> DOMFileSystemSync::createFile(const FileEntrySync* fileEntry, ExceptionState& exceptionState)
 {
     KURL fileSystemURL = createFileSystemURL(fileEntry);
-    RefPtrWillBeRawPtr<CreateFileHelper::CreateFileResult> result(CreateFileHelper::CreateFileResult::create());
+    CreateFileHelper::CreateFileResult* result(CreateFileHelper::CreateFileResult::create());
     fileSystem()->createSnapshotFileAndReadMetadata(fileSystemURL, CreateFileHelper::create(result, fileEntry->name(), fileSystemURL, type()));
     if (result->m_failed) {
         exceptionState.throwDOMException(result->m_code, ""Could not create '"" + fileEntry->name() + ""'."");

@@ -54,7 +54,7 @@ DirectoryReaderSync* DirectoryEntrySync::createReader()
 FileEntrySync* DirectoryEntrySync::getFile(const String& path, const Dictionary& options, ExceptionState& exceptionState)
 {
     FileSystemFlags flags(options);
-    RefPtr<EntrySyncCallbackHelper> helper = EntrySyncCallbackHelper::create();
+    EntrySyncCallbackHelper* helper = EntrySyncCallbackHelper::create();
     m_fileSystem->getFile(this, path, flags, helper->successCallback(), helper->errorCallback(), DOMFileSystemBase::Synchronous);
     return static_cast<FileEntrySync*>(helper->getResult(exceptionState));
 }
@@ -62,14 +62,14 @@ FileEntrySync* DirectoryEntrySync::getFile(const String& path, const Dictionary&
 DirectoryEntrySync* DirectoryEntrySync::getDirectory(const String& path, const Dictionary& options, ExceptionState& exceptionState)
 {
     FileSystemFlags flags(options);
-    RefPtr<EntrySyncCallbackHelper> helper = EntrySyncCallbackHelper::create();
+    EntrySyncCallbackHelper* helper = EntrySyncCallbackHelper::create();
     m_fileSystem->getDirectory(this, path, flags, helper->successCallback(), helper->errorCallback(), DOMFileSystemBase::Synchronous);
     return static_cast<DirectoryEntrySync*>(helper->getResult(exceptionState));
 }
 
 void DirectoryEntrySync::removeRecursively(ExceptionState& exceptionState)
 {
-    RefPtr<VoidSyncCallbackHelper> helper = VoidSyncCallbackHelper::create();
+    VoidSyncCallbackHelper* helper = VoidSyncCallbackHelper::create();
     m_fileSystem->removeRecursively(this, helper->successCallback(), helper->errorCallback(), DOMFileSystemBase::Synchronous);
     helper->getResult(exceptionState);
 }

@@ -52,28 +52,28 @@ EntrySync* EntrySync::create(EntryBase* entry)
 
 Metadata* EntrySync::getMetadata(ExceptionState& exceptionState)
 {
-    RefPtr<MetadataSyncCallbackHelper> helper = MetadataSyncCallbackHelper::create();
+    MetadataSyncCallbackHelper* helper = MetadataSyncCallbackHelper::create();
     m_fileSystem->getMetadata(this, helper->successCallback(), helper->errorCallback(), DOMFileSystemBase::Synchronous);
     return helper->getResult(exceptionState);
 }
 
 EntrySync* EntrySync::moveTo(DirectoryEntrySync* parent, const String& name, ExceptionState& exceptionState) const
 {
-    RefPtr<EntrySyncCallbackHelper> helper = EntrySyncCallbackHelper::create();
+    EntrySyncCallbackHelper* helper = EntrySyncCallbackHelper::create();
     m_fileSystem->move(this, parent, name, helper->successCallback(), helper->errorCallback(), DOMFileSystemBase::Synchronous);
     return helper->getResult(exceptionState);
 }
 
 EntrySync* EntrySync::copyTo(DirectoryEntrySync* parent, const String& name, ExceptionState& exceptionState) const
 {
-    RefPtr<EntrySyncCallbackHelper> helper = EntrySyncCallbackHelper::create();
+    EntrySyncCallbackHelper* helper = EntrySyncCallbackHelper::create();
     m_fileSystem->copy(this, parent, name, helper->successCallback(), helper->errorCallback(), DOMFileSystemBase::Synchronous);
     return helper->getResult(exceptionState);
 }
 
 void EntrySync::remove(ExceptionState& exceptionState) const
 {
-    RefPtr<VoidSyncCallbackHelper> helper = VoidSyncCallbackHelper::create();
+    VoidSyncCallbackHelper* helper = VoidSyncCallbackHelper::create();
     m_fileSystem->remove(this, helper->successCallback(), helper->errorCallback(), DOMFileSystemBase::Synchronous);
     helper->getResult(exceptionState);
 }

@@ -57,7 +57,7 @@ void reportFailure(ExecutionContext*, PassOwnPtr<AsyncFileSystemCallbacks> callb
 
 } // namespace
 
-class CallbackWrapper : public RefCounted<CallbackWrapper> {
+class CallbackWrapper FINAL : public GarbageCollectedFinalized<CallbackWrapper> {
 public:
     CallbackWrapper(PassOwnPtr<AsyncFileSystemCallbacks> c)
         : m_callbacks(c)
@@ -69,6 +69,8 @@ public:
         return m_callbacks.release();
     }
 
+    void trace(Visitor*) { }
+
 private:
     OwnPtr<AsyncFileSystemCallbacks> m_callbacks;
 };
@@ -85,7 +87,7 @@ LocalFileSystem::~LocalFileSystem()
 void LocalFileSystem::resolveURL(ExecutionContext* context, const KURL& fileSystemURL, PassOwnPtr<AsyncFileSystemCallbacks> callbacks)
 {
     RefPtrWillBeRawPtr<ExecutionContext> contextPtr(context);
-    RefPtr<CallbackWrapper> wrapper = adoptRef(new CallbackWrapper(callbacks));
+    CallbackWrapper* wrapper = new CallbackWrapper(callbacks);
     requestFileSystemAccessInternal(context,
         bind(&LocalFileSystem::resolveURLInternal, this, contextPtr, fileSystemURL, wrapper),
         bind(&LocalFileSystem::fileSystemNotAllowedInternal, this, contextPtr, wrapper));
@@ -94,7 +96,7 @@ void LocalFileSystem::resolveURL(ExecutionContext* context, const KURL& fileSyst
 void LocalFileSystem::requestFileSystem(ExecutionContext* context, FileSystemType type, long long size, PassOwnPtr<AsyncFileSystemCallbacks> callbacks)
 {
     RefPtrWillBeRawPtr<ExecutionContext> contextPtr(context);
-    RefPtr<CallbackWrapper> wrapper = adoptRef(new CallbackWrapper(callbacks));
+    CallbackWrapper* wrapper = new CallbackWrapper(callbacks);
     requestFileSystemAccessInternal(context,
         bind(&LocalFileSystem::fileSystemAllowedInternal, this, contextPtr, type, wrapper),
         bind(&LocalFileSystem::fileSystemNotAllowedInternal, this, contextPtr, wrapper));
@@ -106,7 +108,7 @@ void LocalFileSystem::deleteFileSystem(ExecutionContext* context, FileSystemType
     ASSERT(context);
     ASSERT_WITH_SECURITY_IMPLICATION(context->isDocument());
 
-    RefPtr<CallbackWrapper> wrapper = adoptRef(new CallbackWrapper(callbacks));
+    CallbackWrapper* wrapper = new CallbackWrapper(callbacks);
     requestFileSystemAccessInternal(context,
         bind(&LocalFileSystem::deleteFileSystemInternal, this, contextPtr, type, wrapper),
         bind(&LocalFileSystem::fileSystemNotAllowedInternal, this, contextPtr, wrapper));
@@ -139,14 +141,14 @@ void LocalFileSystem::requestFileSystemAccessInternal(ExecutionContext* context,
 
 void LocalFileSystem::fileSystemNotAvailable(
     PassRefPtrWillBeRawPtr<ExecutionContext> context,
-    PassRefPtr<CallbackWrapper> callbacks)
+    CallbackWrapper* callbacks)
 {
     context->postTask(createCrossThreadTask(&reportFailure, callbacks->release(), FileError::ABORT_ERR));
 }
 
 void LocalFileSystem::fileSystemNotAllowedInternal(
     PassRefPtrWillBeRawPtr<ExecutionContext> context,
-    PassRefPtr<CallbackWrapper> callbacks)
+    CallbackWrapper* callbacks)
 {
     context->postTask(createCrossThreadTask(&reportFailure, callbacks->release(), FileError::ABORT_ERR));
 }
@@ -154,7 +156,7 @@ void LocalFileSystem::fileSystemNotAllowedInternal(
 void LocalFileSystem::fileSystemAllowedInternal(
     PassRefPtrWillBeRawPtr<ExecutionContext> context,
     FileSystemType type,
-    PassRefPtr<CallbackWrapper> callbacks)
+    CallbackWrapper* callbacks)
 {
     if (!fileSystem()) {
         fileSystemNotAvailable(context, callbacks);
@@ -168,7 +170,7 @@ void LocalFileSystem::fileSystemAllowedInternal(
 void LocalFileSystem::resolveURLInternal(
     PassRefPtrWillBeRawPtr<ExecutionContext> context,
     const KURL& fileSystemURL,
-    PassRefPtr<CallbackWrapper> callbacks)
+    CallbackWrapper* callbacks)
 {
     if (!fileSystem()) {
         fileSystemNotAvailable(context, callbacks);
@@ -180,7 +182,7 @@ void LocalFileSystem::resolveURLInternal(
 void LocalFileSystem::deleteFileSystemInternal(
     PassRefPtrWillBeRawPtr<ExecutionContext> context,
     FileSystemType type,
-    PassRefPtr<CallbackWrapper> callbacks)
+    CallbackWrapper* callbacks)
 {
     if (!fileSystem()) {
         fileSystemNotAvailable(context, callbacks);

@@ -45,7 +45,6 @@
 #include ""modules/filesystem/MetadataCallback.h""
 #include ""platform/heap/Handle.h""
 #include ""wtf/PassRefPtr.h""
-#include ""wtf/RefCounted.h""
 
 namespace blink {
 
@@ -54,7 +53,7 @@ struct HelperResultType {
     DISALLOW_ALLOCATION();
 public:
     typedef ResultType* ReturnType;
-    typedef Persistent<ResultType> StorageType;
+    typedef Member<ResultType> StorageType;
 
     static ReturnType createFromCallbackArg(CallbackArg argument)
     {
@@ -64,16 +63,16 @@ public:
 
 // A helper template for FileSystemSync implementation.
 template <typename SuccessCallback, typename CallbackArg, typename ResultType>
-class SyncCallbackHelper FINAL : public RefCounted<SyncCallbackHelper<SuccessCallback, CallbackArg, ResultType> > {
+class SyncCallbackHelper FINAL : public GarbageCollected<SyncCallbackHelper<SuccessCallback, CallbackArg, ResultType> > {
 public:
     typedef SyncCallbackHelper<SuccessCallback, CallbackArg, ResultType> HelperType;
     typedef HelperResultType<ResultType, CallbackArg> ResultTypeTrait;
     typedef typename ResultTypeTrait::StorageType ResultStorageType;
     typedef typename ResultTypeTrait::ReturnType ResultReturnType;
 
-    static PassRefPtr<HelperType> create()
+    static HelperType* create()
     {
-        return adoptRef(new SyncCallbackHelper());
+        return new SyncCallbackHelper();
     }
 
     ResultReturnType getResult(ExceptionState& exceptionState)
@@ -87,6 +86,11 @@ public:
     PassOwnPtr<SuccessCallback> successCallback() { return SuccessCallbackImpl::create(this); }
     PassOwnPtr<ErrorCallback> errorCallback() { return ErrorCallbackImpl::create(this); }
 
+    void trace(Visitor* visitor)
+    {
+        visitor->trace(m_result);
+    }
+
 private:
     SyncCallbackHelper()
         : m_errorCode(FileError::OK)
@@ -96,7 +100,7 @@ private:
 
     class SuccessCallbackImpl FINAL : public SuccessCallback {
     public:
-        static PassOwnPtr<SuccessCallbackImpl> create(PassRefPtr<HelperType> helper)
+        static PassOwnPtr<SuccessCallbackImpl> create(HelperType* helper)
         {
             return adoptPtr(new SuccessCallbackImpl(helper));
         }
@@ -112,16 +116,16 @@ private:
         }
 
     private:
-        explicit SuccessCallbackImpl(PassRefPtr<HelperType> helper)
+        explicit SuccessCallbackImpl(HelperType* helper)
             : m_helper(helper)
         {
         }
-        RefPtr<HelperType> m_helper;
+        Persistent<HelperType> m_helper;
     };
 
     class ErrorCallbackImpl FINAL : public ErrorCallback {
     public:
-        static PassOwnPtr<ErrorCallbackImpl> create(PassRefPtr<HelperType> helper)
+        static PassOwnPtr<ErrorCallbackImpl> create(HelperType* helper)
         {
             return adoptPtr(new ErrorCallbackImpl(helper));
         }
@@ -133,11 +137,11 @@ private:
         }
 
     private:
-        explicit ErrorCallbackImpl(PassRefPtr<HelperType> helper)
+        explicit ErrorCallbackImpl(HelperType* helper)
             : m_helper(helper)
         {
         }
-        RefPtr<HelperType> m_helper;
+        Persistent<HelperType> m_helper;
     };
 
     void setError(FileError::ErrorCode code)

@@ -76,7 +76,7 @@ DOMFileSystemSync* WorkerGlobalScopeFileSystem::webkitRequestFileSystemSync(Work
         return 0;
     }
 
-    RefPtr<FileSystemSyncCallbackHelper> helper = FileSystemSyncCallbackHelper::create();
+    FileSystemSyncCallbackHelper* helper = FileSystemSyncCallbackHelper::create();
     OwnPtr<AsyncFileSystemCallbacks> callbacks = FileSystemCallbacks::create(helper->successCallback(), helper->errorCallback(), &worker, fileSystemType);
     callbacks->setShouldBlockUntilCompletion(true);
 
@@ -115,7 +115,7 @@ EntrySync* WorkerGlobalScopeFileSystem::webkitResolveLocalFileSystemSyncURL(Work
         return 0;
     }
 
-    RefPtr<EntrySyncCallbackHelper> resolveURLHelper = EntrySyncCallbackHelper::create();
+    EntrySyncCallbackHelper* resolveURLHelper = EntrySyncCallbackHelper::create();
     OwnPtr<AsyncFileSystemCallbacks> callbacks = ResolveURICallbacks::create(resolveURLHelper->successCallback(), resolveURLHelper->errorCallback(), &worker);
     callbacks->setShouldBlockUntilCompletion(true);
 
",0,"Oilpan: Ship Oilpan for SyncCallbackHelper, CreateFileResult and CallbackWrapper in filesystem/"
02ce232c5051854bf49e6d2816c65e00f6d7e036,"@@ -126,6 +126,9 @@ static void qemu_clock_init(QEMUClockType type)
 {
     QEMUClock *clock = qemu_clock_ptr(type);
 
+    /* Assert that the clock of type TYPE has not been initialized yet. */
+    assert(main_loop_tlg.tl[type] == NULL);
+
     clock->type = type;
     clock->enabled = true;
     clock->last = INT64_MIN;

@@ -3024,7 +3024,6 @@ int main(int argc, char **argv, char **envp)
 
     runstate_init();
 
-    init_clocks();
     rtc_clock = QEMU_CLOCK_HOST;
 
     qemu_init_auxval(envp);
",0,vl.c: remove init_clocks call from main
02d6d053396626ff5b3390e48a9933e0d4164b28,"@@ -2247,6 +2247,8 @@ static int dca_decode_frame(AVCodecContext *avctx, void *data,
                 } else {
                     s->channel_order_tab = dca_channel_reorder_nolfe_xch[s->amode];
                 }
+                if (s->channel_order_tab[s->xch_base_channel] < 0)
+                    return AVERROR_INVALIDDATA;
             } else {
                 channels = num_core_channels + !!s->lfe;
                 s->xch_present = 0; /* disable further xch processing */
",0,dcadec: check xch_base_channel against channel_order_tab.
02dadf116124cfba35d7ebd9ced3e5ad0be0f176,"@@ -1442,7 +1442,8 @@ static void WriteTo8BimProfile(Image *image,const char *name,
     count=(ssize_t) value;
     if ((count & 0x01) != 0)
       count++;
-    if ((p > (datum+length-count)) || (count > (ssize_t) length))
+    if ((count < 0) || (p > (datum+length-count)) ||
+        (count > (ssize_t) length))
       break;
     if (id != profile_id)
       p+=count;
",0,Fixed SEGV reported in https://github.com/ImageMagick/ImageMagick/issues/130
02dd3666c2944a3db44ba13916ba40dbdd41f9b1,"@@ -75,7 +75,7 @@ static int h264_mp4toannexb_filter(AVBitStreamFilterContext *bsfc,
     if (!ctx->extradata_parsed) {
         uint16_t unit_size;
         uint64_t total_size = 0;
-        uint8_t *out = NULL, unit_nb, sps_done = 0;
+        uint8_t *out = NULL, unit_nb, sps_done = 0, sps_seen = 0, pps_seen = 0;
         const uint8_t *extradata = avctx->extradata+4;
         static const uint8_t nalu_header[4] = {0, 0, 0, 1};
 
@@ -89,7 +89,15 @@ static int h264_mp4toannexb_filter(AVBitStreamFilterContext *bsfc,
         if (!unit_nb) {
             unit_nb = *extradata++; /* number of pps unit(s) */
             sps_done++;
+
+            if (unit_nb)
+                pps_seen = 1;
+        }
+        else
+        {
+            sps_seen = 1;
         }
+
         while (unit_nb--) {
             void *tmp;
 
@@ -114,7 +122,14 @@ static int h264_mp4toannexb_filter(AVBitStreamFilterContext *bsfc,
                 unit_nb = *extradata++; /* number of pps unit(s) */
         }
 
-        memset(out + total_size, 0, FF_INPUT_BUFFER_PADDING_SIZE);
+        if(out)
+            memset(out + total_size, 0, FF_INPUT_BUFFER_PADDING_SIZE);
+
+        if (!sps_seen)
+            av_log(avctx, AV_LOG_WARNING, ""Warning: SPS NALU missing or invalid. The resulting stream may not play.\n"");
+        if (!pps_seen)
+            av_log(avctx, AV_LOG_WARNING, ""Warning: PPS NALU missing or invalid. The resulting stream may not play.\n"");
+
         av_free(avctx->extradata);
         avctx->extradata      = out;
         avctx->extradata_size = total_size;
",0,"h264_mp3toannexb_bsg: don't crash, but warn, if PPS/SPS not found."
02e976d4426a1319a7af7d26d7aba9d8c6077570,"@@ -888,14 +888,18 @@ bool JT_PushMessage::take(const QDomElement &e)
 	QDomElement forward;
 	Message::CarbonDir cd = Message::NoCarbon;
 
+	Jid fromJid = Jid(e1.attribute(QLatin1String(""from"")));
 	// Check for Carbon
 	QDomNodeList list = e1.childNodes();
 	for (int i = 0; i < list.size(); ++i) {
 		QDomElement el = list.at(i).toElement();
 
-		if (el.attribute(""xmlns"") == QLatin1String(""urn:xmpp:carbons:2"") && (el.tagName() == QLatin1String(""received"") || el.tagName() == QLatin1String(""sent""))) {
+		if (el.attribute(""xmlns"") == QLatin1String(""urn:xmpp:carbons:2"")
+		    && (el.tagName() == QLatin1String(""received"") || el.tagName() == QLatin1String(""sent""))
+		    && fromJid.compare(Jid(e1.attribute(QLatin1String(""to""))), false)) {
 			QDomElement el1 = el.firstChildElement();
-			if (el1.tagName() == QLatin1String(""forwarded"") && el1.attribute(QLatin1String(""xmlns"")) == QLatin1String(""urn:xmpp:forward:0"")) {
+			if (el1.tagName() == QLatin1String(""forwarded"")
+			    && el1.attribute(QLatin1String(""xmlns"")) == QLatin1String(""urn:xmpp:forward:0"")) {
 				QDomElement el2 = el1.firstChildElement(QLatin1String(""message""));
 				if (!el2.isNull()) {
 					forward = el2;
@@ -904,7 +908,8 @@ bool JT_PushMessage::take(const QDomElement &e)
 				}
 			}
 		}
-		else if (el.tagName() == QLatin1String(""forwarded"") && el.attribute(QLatin1String(""xmlns"")) == QLatin1String(""urn:xmpp:forward:0"")) {
+		else if (el.tagName() == QLatin1String(""forwarded"")
+			 && el.attribute(QLatin1String(""xmlns"")) == QLatin1String(""urn:xmpp:forward:0"")) {
 			forward = el.firstChildElement(QLatin1String(""message"")); // currently only messages are supportted
 			// TODO <delay> element support
 			if (!forward.isNull()) {
@@ -913,7 +918,6 @@ bool JT_PushMessage::take(const QDomElement &e)
 		}
 	}
 
-	QString from = e1.attribute(QLatin1String(""from""));
 	Stanza s = client()->stream().createStanza(addCorrectNS(forward.isNull()? e1 : forward));
 	if(s.isNull()) {
 		//printf(""take: bad stanza??\n"");
@@ -926,7 +930,7 @@ bool JT_PushMessage::take(const QDomElement &e)
 		return false;
 	}
 	if (!forward.isNull()) {
-		m.setForwardedFrom(Jid(from));
+		m.setForwardedFrom(fromJid);
 		m.setCarbonDirection(cd);
 	}
 
",0,Try to fix XMPP Client User Impersonation Vulnerability
02ed3e7c1665205ddae052774d6f26c71d3d9b30,"@@ -337,7 +337,18 @@ static void virtio_crypto_free_request(VirtIOCryptoReq *req)
 {
     if (req) {
         if (req->flags == CRYPTODEV_BACKEND_ALG_SYM) {
-            g_free(req->u.sym_op_info);
+            size_t max_len;
+            CryptoDevBackendSymOpInfo *op_info = req->u.sym_op_info;
+
+            max_len = op_info->iv_len +
+                      op_info->aad_len +
+                      op_info->src_len +
+                      op_info->dst_len +
+                      op_info->digest_result_len;
+
+            /* Zeroize and free request data structure */
+            memset(op_info, 0, sizeof(*op_info) + max_len);
+            g_free(op_info);
         }
         g_free(req);
     }
",0,virtio-crypto: zeroize the key material before free
02f292d9051f616511f482275b571c6153e3a48b,"@@ -2452,6 +2452,7 @@ static gint machine_class_cmp(gconstpointer a, gconstpointer b)
         mc = find_machine(name);
     }
     if (mc) {
+        g_slist_free(machines);
         return mc;
     }
     if (name && !is_help_option(name)) {
",0,vl.c: fix memory leak spotted by valgrind
0305cd5f7fca85dae392b9ba85b116896eb7c1c7,"@@ -4217,6 +4217,47 @@ static int truncate_space_check(struct btrfs_trans_handle *trans,
 
 }
 
+static int truncate_inline_extent(struct inode *inode,
+				  struct btrfs_path *path,
+				  struct btrfs_key *found_key,
+				  const u64 item_end,
+				  const u64 new_size)
+{
+	struct extent_buffer *leaf = path->nodes[0];
+	int slot = path->slots[0];
+	struct btrfs_file_extent_item *fi;
+	u32 size = (u32)(new_size - found_key->offset);
+	struct btrfs_root *root = BTRFS_I(inode)->root;
+
+	fi = btrfs_item_ptr(leaf, slot, struct btrfs_file_extent_item);
+
+	if (btrfs_file_extent_compression(leaf, fi) != BTRFS_COMPRESS_NONE) {
+		loff_t offset = new_size;
+		loff_t page_end = ALIGN(offset, PAGE_CACHE_SIZE);
+
+		/*
+		 * Zero out the remaining of the last page of our inline extent,
+		 * instead of directly truncating our inline extent here - that
+		 * would be much more complex (decompressing all the data, then
+		 * compressing the truncated data, which might be bigger than
+		 * the size of the inline extent, resize the extent, etc).
+		 * We release the path because to get the page we might need to
+		 * read the extent item from disk (data not in the page cache).
+		 */
+		btrfs_release_path(path);
+		return btrfs_truncate_page(inode, offset, page_end - offset, 0);
+	}
+
+	btrfs_set_file_extent_ram_bytes(leaf, fi, size);
+	size = btrfs_file_extent_calc_inline_size(size);
+	btrfs_truncate_item(root, path, size, 1);
+
+	if (test_bit(BTRFS_ROOT_REF_COWS, &root->state))
+		inode_sub_bytes(inode, item_end + 1 - new_size);
+
+	return 0;
+}
+
 /*
  * this can truncate away extent items, csum items and directory items.
  * It starts at a high offset and removes keys until it can't find
@@ -4411,27 +4452,40 @@ int btrfs_truncate_inode_items(struct btrfs_trans_handle *trans,
 			 * special encodings
 			 */
 			if (!del_item &&
-			    btrfs_file_extent_compression(leaf, fi) == 0 &&
 			    btrfs_file_extent_encryption(leaf, fi) == 0 &&
 			    btrfs_file_extent_other_encoding(leaf, fi) == 0) {
-				u32 size = new_size - found_key.offset;
-
-				if (test_bit(BTRFS_ROOT_REF_COWS, &root->state))
-					inode_sub_bytes(inode, item_end + 1 -
-							new_size);
 
 				/*
-				 * update the ram bytes to properly reflect
-				 * the new size of our item
+				 * Need to release path in order to truncate a
+				 * compressed extent. So delete any accumulated
+				 * extent items so far.
 				 */
-				btrfs_set_file_extent_ram_bytes(leaf, fi, size);
-				size =
-				    btrfs_file_extent_calc_inline_size(size);
-				btrfs_truncate_item(root, path, size, 1);
+				if (btrfs_file_extent_compression(leaf, fi) !=
+				    BTRFS_COMPRESS_NONE && pending_del_nr) {
+					err = btrfs_del_items(trans, root, path,
+							      pending_del_slot,
+							      pending_del_nr);
+					if (err) {
+						btrfs_abort_transaction(trans,
+									root,
+									err);
+						goto error;
+					}
+					pending_del_nr = 0;
+				}
+
+				err = truncate_inline_extent(inode, path,
+							     &found_key,
+							     item_end,
+							     new_size);
+				if (err) {
+					btrfs_abort_transaction(trans,
+								root, err);
+					goto error;
+				}
 			} else if (test_bit(BTRFS_ROOT_REF_COWS,
 					    &root->state)) {
-				inode_sub_bytes(inode, item_end + 1 -
-						found_key.offset);
+				inode_sub_bytes(inode, item_end + 1 - new_size);
 			}
 		}
 delete:
",0,Btrfs: fix truncation of compressed and inlined extents
030c7f0309ec0e3cadb990408b4bb9b7fd739425,"@@ -631,6 +631,8 @@ static int epic_decode_run_length(ePICContext *dc, int x, int y, int tile_width,
               (NN  != N)  << 1 |
               (NNW != NW);
         WWneW = ff_els_decode_bit(&dc->els_ctx, &dc->W_ctx_rung[idx]);
+        if (WWneW < 0)
+            return WWneW;
     }
 
     if (WWneW)
@@ -837,10 +839,13 @@ static int epic_decode_tile(ePICContext *dc, uint8_t *out, int tile_height,
                 if (y < 2 || x < 2 || x == tile_width - 1) {
                     run       = 1;
                     got_pixel = epic_handle_edges(dc, x, y, curr_row, above_row, &pix);
-                } else
+                } else {
                     got_pixel = epic_decode_run_length(dc, x, y, tile_width,
                                                        curr_row, above_row,
                                                        above2_row, &pix, &run);
+                    if (got_pixel < 0)
+                        return got_pixel;
+                }
 
                 if (!got_pixel && !epic_predict_from_NW_NE(dc, x, y, run,
                                                            tile_width, curr_row,
",0,avcodec/g2meet: Check for ff_els_decode_bit() failure in epic_decode_run_length()
0314dead4e7c058568e792842405190c06d71da5,"@@ -369,8 +369,12 @@ AVEvalExpr * ff_parse(const char *s, const char * const *const_name,
                double (**func2)(void *, double, double), const char **func2_name,
                const char **error){
     Parser p;
-    AVEvalExpr * e;
-    char w[strlen(s) + 1], * wp = w;
+    AVEvalExpr *e = NULL;
+    char *w = av_malloc(strlen(s) + 1);
+    char *wp = w;
+
+    if (!w)
+        goto end;
 
     while (*s)
         if (!isspace(*s++)) *wp++ = s[-1];
@@ -388,8 +392,10 @@ AVEvalExpr * ff_parse(const char *s, const char * const *const_name,
     e = parse_expr(&p);
     if (!verify_expr(e)) {
         ff_eval_free(e);
-        return NULL;
+        e = NULL;
     }
+end:
+    av_free(w);
     return e;
 }
 
",0,eval: replace variable-length array with av_malloc/free
03289958938e91dc9bc398fdf1489677c6030063,"@@ -205,7 +205,7 @@ static void id3v2_read_ttag(AVFormatContext *s, int taglen, char *dst, int dstle
         break;
 
     case 3:  /* UTF-8 */
-        len = FFMIN(taglen, dstlen);
+        len = FFMIN(taglen, dstlen-1);
         get_buffer(s->pb, dst, len);
         dst[len] = 0;
         break;
",0,"All mp3 parsers are buggy fix 2 of n (out of array write, i suspect not exploitable)"
032a7c4e425f1f0b71942768696f53f93947f8fa,"@@ -116,7 +116,7 @@ static int lance_init(SysBusDevice *dev)
     SysBusPCNetState *d = FROM_SYSBUS(SysBusPCNetState, dev);
     PCNetState *s = &d->state;
 
-    memory_region_init_io(&s->mmio, &lance_mem_ops, s, ""lance-mmio"", 4);
+    memory_region_init_io(&s->mmio, &lance_mem_ops, d, ""lance-mmio"", 4);
 
     qdev_init_gpio_in(&dev->qdev, parent_lance_reset, 1);
 
",0,lance: unbreak after memory API conversion
035cb12f392860113dce96116a5150e2fde6f0cc,"@@ -542,6 +542,22 @@ status_t SoundTriggerHwService::Module::loadSoundModel(const sp<IMemory>& modelM
     struct sound_trigger_sound_model *sound_model =
             (struct sound_trigger_sound_model *)modelMemory->pointer();
 
+    size_t structSize;
+    if (sound_model->type == SOUND_MODEL_TYPE_KEYPHRASE) {
+        structSize = sizeof(struct sound_trigger_phrase_sound_model);
+    } else {
+        structSize = sizeof(struct sound_trigger_sound_model);
+    }
+
+    if (sound_model->data_offset < structSize ||
+           sound_model->data_size > (UINT_MAX - sound_model->data_offset) ||
+           modelMemory->size() < sound_model->data_offset ||
+           sound_model->data_size > (modelMemory->size() - sound_model->data_offset)) {
+        android_errorWriteLog(0x534e4554, ""30148546"");
+        ALOGE(""loadSoundModel() data_size is too big"");
+        return BAD_VALUE;
+    }
+
     AutoMutex lock(mLock);
 
     if (mModels.size() >= mDescriptor.properties.max_sound_models) {
@@ -607,11 +623,23 @@ status_t SoundTriggerHwService::Module::startRecognition(sound_model_handle_t ha
         return PERMISSION_DENIED;
     }
 
-    if (dataMemory != 0 && dataMemory->pointer() == NULL) {
-        ALOGE(""startRecognition() dataMemory is non-0 but has NULL pointer()"");
+    if (dataMemory == 0 || dataMemory->pointer() == NULL) {
+        ALOGE(""startRecognition() dataMemory is 0 or has NULL pointer()"");
         return BAD_VALUE;
 
     }
+
+    struct sound_trigger_recognition_config *config =
+            (struct sound_trigger_recognition_config *)dataMemory->pointer();
+
+    if (config->data_offset < sizeof(struct sound_trigger_recognition_config) ||
+            config->data_size > (UINT_MAX - config->data_offset) ||
+            dataMemory->size() < config->data_offset ||
+            config->data_size > (dataMemory->size() - config->data_offset)) {
+        ALOGE(""startRecognition() data_size is too big"");
+        return BAD_VALUE;
+    }
+
     AutoMutex lock(mLock);
     if (mServiceState == SOUND_TRIGGER_STATE_DISABLED) {
         return INVALID_OPERATION;
@@ -620,17 +648,11 @@ status_t SoundTriggerHwService::Module::startRecognition(sound_model_handle_t ha
     if (model == 0) {
         return BAD_VALUE;
     }
-    if ((dataMemory == 0) ||
-            (dataMemory->size() < sizeof(struct sound_trigger_recognition_config))) {
-        return BAD_VALUE;
-    }
 
     if (model->mState == Model::STATE_ACTIVE) {
         return INVALID_OPERATION;
     }
 
-    struct sound_trigger_recognition_config *config =
-            (struct sound_trigger_recognition_config *)dataMemory->pointer();
 
     //TODO: get capture handle and device from audio policy service
     config->capture_handle = model->mCaptureIOHandle;
",0,soundtrigger: add size check on sound model and recogntion data
036b9ee1c959d88d5ae7f1df21b2d36ab286b3cc,"@@ -402,7 +402,7 @@ static int ogg_build_opus_headers(AVCodecContext *avctx,
 static int ogg_write_header(AVFormatContext *s)
 {
     OGGContext *ogg = s->priv_data;
-    OGGStreamContext *oggstream;
+    OGGStreamContext *oggstream = NULL;
     int i, j;
 
     if (ogg->pref_size)
",0,"oggenc: fix ""oggstream may be used uninitialized in this function"" warning"
037422178d7f1d0dd09e1ce424dd61a69e77668b,"@@ -1527,7 +1527,7 @@ static int read_diff_float_data(ALSDecContext *ctx, unsigned int ra_frame) {
             if (!get_bits1(gb)) { //uncompressed
                 for (i = 0; i < frame_length; ++i) {
                     if (ctx->raw_samples[c][i] != 0) {
-                        raw_mantissa[c][i] = get_bits(gb, nbits[i]);
+                        raw_mantissa[c][i] = nbits[i] ? get_bits(gb, nbits[i]) : 0;
                     }
                 }
             } else { //compressed
",0,avcodec/alsdec: Fix reading 0 mantisse bits
0379f474ddebfc69f42fa8231d86687cf29d997b,"@@ -193,6 +193,26 @@ static ssize_t read_sync(int fd, void *buffer, size_t size)
     return nbd_wr_sync(fd, buffer, size, true);
 }
 
+static ssize_t drop_sync(int fd, size_t size)
+{
+    ssize_t ret, dropped = size;
+    uint8_t *buffer = g_malloc(MIN(65536, size));
+
+    while (size > 0) {
+        ret = read_sync(fd, buffer, MIN(65536, size));
+        if (ret < 0) {
+            g_free(buffer);
+            return ret;
+        }
+
+        assert(ret <= size);
+        size -= ret;
+    }
+
+    g_free(buffer);
+    return dropped;
+}
+
 static ssize_t write_sync(int fd, void *buffer, size_t size)
 {
     int ret;
@@ -303,6 +323,9 @@ static int nbd_handle_list(NBDClient *client, uint32_t length)
 
     csock = client->sock;
     if (length) {
+        if (drop_sync(csock, length) != length) {
+            return -EIO;
+        }
         return nbd_send_rep(csock, NBD_REP_ERR_INVALID, NBD_OPT_LIST);
     }
 
",0,nbd: Drop unexpected data for NBD_OPT_LIST
037e1d009e2fcb80784d37f0e12aa999787d46d4,"@@ -2662,11 +2662,12 @@ static void disas_pc_rel_adr(DisasContext *s, uint32_t insn)
 {
     unsigned int page, rd;
     uint64_t base;
-    int64_t offset;
+    uint64_t offset;
 
     page = extract32(insn, 31, 1);
     /* SignExtend(immhi:immlo) -> offset */
-    offset = ((int64_t)sextract32(insn, 5, 19) << 2) | extract32(insn, 29, 2);
+    offset = sextract64(insn, 5, 19);
+    offset = offset << 2 | extract32(insn, 29, 2);
     rd = extract32(insn, 0, 5);
     base = s->pc - 4;
 
",0,target-arm: A64: Avoid left shifting negative integers in disas_pc_rel_addr
0380aef323154205a7d838fb9953423621290d41,"@@ -44,7 +44,7 @@ static bool is_blacklisted(const char *arch, const char *mach)
     return false;
 }
 
-static void test_properties(const char *path)
+static void test_properties(const char *path, bool recurse)
 {
     char *child_path;
     QDict *response, *tuple;
@@ -56,14 +56,21 @@ static void test_properties(const char *path)
                    ""  'arguments': { 'path': '%s' } }"", path);
     g_assert(response);
 
+    if (!recurse) {
+        return;
+    }
+
     g_assert(qdict_haskey(response, ""return""));
     list = qobject_to_qlist(qdict_get(response, ""return""));
     QLIST_FOREACH_ENTRY(list, entry) {
         tuple = qobject_to_qdict(qlist_entry_obj(entry));
-        if (strstart(qdict_get_str(tuple, ""type""), ""child<"", NULL)) {
+        bool is_child = strstart(qdict_get_str(tuple, ""type""), ""child<"", NULL);
+        bool is_link = strstart(qdict_get_str(tuple, ""type""), ""link<"", NULL);
+
+        if (is_child || is_link) {
             child_path = g_strdup_printf(""%s/%s"",
                                          path, qdict_get_str(tuple, ""name""));
-            test_properties(child_path);
+            test_properties(child_path, is_child);
             g_free(child_path);
         } else {
             const char *prop = qdict_get_str(tuple, ""name"");
@@ -87,7 +94,7 @@ static void test_machine(gconstpointer data)
     args = g_strdup_printf(""-machine %s"", machine);
     qtest_start(args);
 
-    test_properties(""/machine"");
+    test_properties(""/machine"", true);
 
     response = qmp(""{ 'execute': 'quit' }"");
     g_assert(qdict_haskey(response, ""return""));
",0,qom-test: Test qom-list on link<> properties
038268e2e8087ee2fd8987a77ba580e15f14c147,"@@ -579,6 +579,7 @@ void ide_dma_cb(void *opaque, int ret)
     IDEState *s = opaque;
     int n;
     int64_t sector_num;
+    bool stay_active = false;
 
     if (ret < 0) {
         int op = BM_STATUS_DMA_RETRY;
@@ -594,6 +595,14 @@ void ide_dma_cb(void *opaque, int ret)
     }
 
     n = s->io_buffer_size >> 9;
+    if (n > s->nsector) {
+        /* The PRDs were longer than needed for this request. Shorten them so
+         * we don't get a negative remainder. The Active bit must remain set
+         * after the request completes. */
+        n = s->nsector;
+        stay_active = true;
+    }
+
     sector_num = ide_get_sector(s);
     if (n > 0) {
         dma_buf_commit(s);
@@ -646,6 +655,9 @@ eot:
         bdrv_acct_done(s->bs, &s->acct);
     }
     ide_set_inactive(s);
+    if (stay_active) {
+        s->bus->dma->ops->add_status(s->bus->dma, BM_STATUS_DMAING);
+    }
 }
 
 static void ide_sector_start_dma(IDEState *s, enum ide_dma_cmd dma_cmd)
",0,ide: Fix crash with too long PRD
038f3a173f59c9fc3396aa38e7972661da7ca504,"@@ -482,6 +482,9 @@ static int concat_read_packet(AVFormatContext *avf, AVPacket *pkt)
     ConcatStream *cs;
     AVStream *st;
 
+    if (!cat->avf)
+        return AVERROR(EIO);
+
     while (1) {
         ret = av_read_frame(cat->avf, pkt);
         if (ret == AVERROR_EOF) {
",0,avformat/concatdec: avoid NULL dereference when failed to open file.
039380a8e18f618cdacf72486449c04dc1b70eef,"@@ -291,6 +291,11 @@ void qtest_qmp(QTestState *s, const char *fmt, ...)
             continue;
         }
 
+        if (len == -1 || len == 0) {
+            fprintf(stderr, ""Broken pipe\n"");
+            exit(1);
+        }
+
         switch (c) {
         case '{':
             nesting++;
",0,qtest: fix infinite loop when QEMU aborts abruptly
0393cf15dbe3b136647b81676a105815924eebcd,"@@ -23,7 +23,6 @@
 #include <string.h>
 
 #include ""parser.h""
-#include ""internal.h""
 #include ""libavutil/mem.h""
 
 static AVCodecParser *av_first_parser = NULL;
@@ -68,10 +67,7 @@ AVCodecParserContext *av_parser_init(int codec_id)
     s->fetch_timestamp=1;
     s->pict_type = AV_PICTURE_TYPE_I;
     if (parser->parser_init) {
-        if (ff_lock_avcodec(NULL) < 0)
-            goto err_out;
         ret = parser->parser_init(s);
-        ff_unlock_avcodec();
         if (ret != 0)
             goto err_out;
     }
@@ -206,11 +202,8 @@ int av_parser_change(AVCodecParserContext *s,
 void av_parser_close(AVCodecParserContext *s)
 {
     if(s){
-        if (s->parser->parser_close) {
-            ff_lock_avcodec(NULL);
+        if (s->parser->parser_close)
             s->parser->parser_close(s);
-            ff_unlock_avcodec();
-        }
         av_free(s->priv_data);
         av_free(s);
     }
",0,"Revert ""Acquire lock when initializing parsers."""
0399fe0fd23ff272282dd093cc2720deb6f87ea8,"@@ -102,7 +102,7 @@ void ff_lzw_decode_tail(LZWState *p)
 
     if(s->mode == FF_LZW_GIF) {
         while (s->bs > 0) {
-            if (s->pbuf + s->bs >= s->ebuf) {
+            if (s->bs >= s->ebuf - s->pbuf) {
                 s->pbuf = s->ebuf;
                 break;
             } else {
",0,lzw: fix potential integer overflow.
